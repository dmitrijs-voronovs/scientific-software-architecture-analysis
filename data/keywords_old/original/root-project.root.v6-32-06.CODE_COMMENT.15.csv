id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:440,Safety,abort,abort,440,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:211,Testability,log,logical,211,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:4,Usability,Clear,Clears,4,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:441,Performance,load,loads,441,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:377,Safety,abort,abort,377,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:435,Safety,abort,abort,435,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:206,Testability,log,logical,206,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:181,Testability,log,logical,181,"/// Get the current value of the user interrupt flag (UIF). Can be executed; /// regardless of CPL and inside a transactional region. Can be executed only; /// if CR4.UINT = 1, the logical processor is in 64-bit mode, and software is; /// not executing inside an enclave; otherwise, it causes an invalid-opcode; /// exception.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> TESTUI </c> instruction.; ///; /// \returns The current value of the user interrupt flag (UIF).; ///; /// \code{.operation}; /// CF := UIF; /// ZF := 0; /// AF := 0; /// OF := 0; /// PF := 0; /// SF := 0; /// dst := CF; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:414,Testability,TEST,TESTUI,414,"/// Get the current value of the user interrupt flag (UIF). Can be executed; /// regardless of CPL and inside a transactional region. Can be executed only; /// if CR4.UINT = 1, the logical processor is in 64-bit mode, and software is; /// not executing inside an enclave; otherwise, it causes an invalid-opcode; /// exception.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> TESTUI </c> instruction.; ///; /// \returns The current value of the user interrupt flag (UIF).; ///; /// \code{.operation}; /// CF := UIF; /// ZF := 0; /// AF := 0; /// OF := 0; /// PF := 0; /// SF := 0; /// dst := CF; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:1005,Deployability,release,release,1005,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:1238,Deployability,release,release,1238,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:327,Performance,perform,performed,327,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:314,Security,access,accesses,314,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:105,Testability,log,logical,105,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:144,Integrability,depend,depend,144,"/* It is a bit strange for a header to play with the visibility of the; symbols it declares, but this matches gcc's behavior and some programs; depend on it */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:12,Performance,cache,cache,12,/* unwinder cache (private fields for the unwinder's use) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:15,Integrability,rout,routine,15,/* personality routine */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:23,Performance,cache,cache,23,/* propagation barrier cache (valid after phase 1) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:11,Performance,cache,cache,11,/* cleanup cache (preserved over cleanup) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:15,Performance,cache,cache,15,/* personality cache (for personality's benefit) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:37,Availability,avail,available,37,/* DWARF EH functions; currently not available on Darwin/ARM */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/varargs.h:22,Modifiability,Variab,Variable,22,"/*===---- varargs.h - Variable argument handling -------------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/varargs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/varargs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/velintrin.h:10,Availability,mask,mask,10,// Vector mask registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/velintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/velintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:39,Modifiability,portab,portable,39,"/*===---- wasm_simd128.h - WebAssembly portable SIMD intrinsics ------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:21,Security,access,access,21,// UB-free unaligned access copied from xmmintrin.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:21,Security,access,access,21,// UB-free unaligned access copied from xmmintrin.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h:81,Modifiability,extend,extended,81,"// When in 64-bit target, the 32-bit operands generate a 32-bit result,; // zero-extended to a 64-bit result in the destination general-purpose,; // It means ""mov x %ebx"" will clobber the higher 32 bits of rbx, so we; // should preserve the 64-bit register rbx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:143,Performance,Load,Loads,143,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:153,Performance,cache,cache,153,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:509,Performance,cache,cache,509,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:683,Security,access,access,683,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,Availability,mask,mask,129,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:219,Availability,mask,mask,219,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:288,Availability,mask,mask,288,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:493,Availability,mask,mask,493,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:729,Availability,mask,mask,729,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:107,Integrability,depend,depends,107,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Performance,Perform,Performs,4,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,Availability,mask,mask,129,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:219,Availability,mask,mask,219,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:288,Availability,mask,mask,288,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:493,Availability,mask,mask,493,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:731,Availability,mask,mask,731,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:107,Integrability,depend,depends,107,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Performance,Perform,Performs,4,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:46,Modifiability,variab,variables,46,"/*===---- cuda_builtin_vars.h - CUDA built-in variables ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:37,Modifiability,variab,variables,37,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:168,Modifiability,variab,variable,168,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:147,Security,access,accesses,147,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:56,Modifiability,variab,variable,56,"// Make sure nobody can create instances of the special variable types. nvcc; // also disallows taking address of special variables, so we disable address-of; // operator as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:122,Modifiability,variab,variables,122,"// Make sure nobody can create instances of the special variable types. nvcc; // also disallows taking address of special variables, so we disable address-of; // operator as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:257,Safety,avoid,avoid,257,"// For OpenMP we work around some old system headers that have non-conforming; // `isinf(float)` and `isnan(float)` implementations that return an `int`. We do; // this by providing two versions of these functions, differing only in the; // return type. To avoid conflicting definitions we disable implicit base; // function generation. That means we will end up with two specializations, one; // per type, but only one has a base function defined by the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:221,Safety,avoid,avoid,221,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:418,Safety,avoid,avoid,418,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:143,Availability,avail,available,143,"// For inscrutable reasons, __finite(), the double-precision version of; // __finitef, does not exist when compiling for MacOS. __isfinited is available; // everywhere and is just as good.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:121,Availability,avail,available,121,"// This header defines __muldc3, __mulsc3, __divdc3, and __divsc3. These are; // libgcc functions that clang assumes are available when compiling c99 complex; // operations. (These implementations come from libc++, and have been modified; // to work with CUDA and OpenMP target offloading [in C and C++ mode].)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:26,Availability,avail,available,26,// To make the algorithms available for C and C++ in CUDA and OpenMP we select; // different but equivalent function versions. TODO: For OpenMP we currently; // select the native builtins as the overload support for templates is lacking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:65,Availability,avail,available,65,"// Rather than pulling in std::max from algorithm everytime, use available ::max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:70,Integrability,wrap,wrappers,70,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:214,Integrability,wrap,wrappers,214,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:137,Safety,avoid,avoid,137,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:194,Performance,optimiz,optimized,194,"// CUDA_VERSION >= 9020; // CUDA no longer provides inline assembly (or bitcode) implementation of these; // functions, so we have to reimplment them. The implementation is naive and is; // not optimized for performance.; // Helper function to convert N-bit boolean subfields into all-0 or all-1.; // E.g. __bool2mask(0x01000100,8) -> 0xff00ff00; // __bool2mask(0x00010000,16) -> 0xffff0000",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:208,Performance,perform,performance,208,"// CUDA_VERSION >= 9020; // CUDA no longer provides inline assembly (or bitcode) implementation of these; // functions, so we have to reimplment them. The implementation is naive and is; // not optimized for performance.; // Helper function to convert N-bit boolean subfields into all-0 or all-1.; // E.g. __bool2mask(0x01000100,8) -> 0xff00ff00; // __bool2mask(0x00010000,16) -> 0xffff0000",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:237,Availability,mask,mask,237,// Based on ITEM 23 in AIM-239: http://dspace.mit.edu/handle/1721.1/6086; // (a & b) + (a | b) = a + b = (a ^ b) + 2 * (a & b) =>; // (a + b) / 2 = ((a ^ b) >> 1) + (a & b); // To operate on multiple sub-elements we need to make sure to mask out bits; // that crossed over into adjacent elements during the shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:64,Integrability,wrap,wrappers,64,"/*===--- __clang_cuda_intrinsics.h - Device-side CUDA intrinsic wrappers ---===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:32,Availability,down,down,32,"// sm_30 intrinsics: __shfl_{up,down,xor}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:34,Availability,mask,mask,34,"// We use 0 rather than 31 as our mask, because shfl.up applies to lanes >=; // maxLane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:26,Availability,avail,available,26,// __shfl_sync_* variants available in CUDA-9,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:34,Availability,mask,mask,34,"// We use 0 rather than 31 as our mask, because shfl.up applies to lanes >=; // maxLane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:80,Performance,load,load,80,"// We can assume that ptr is aligned at least to char2's alignment, but the; // load will assume that ptr is aligned to char2's alignment. This is only; // safe if alignof(c2) <= alignof(char2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:156,Safety,safe,safe,156,"// We can assume that ptr is aligned at least to char2's alignment, but the; // load will assume that ptr is aligned to char2's alignment. This is only; // safe if alignof(c2) <= alignof(char2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:275,Availability,avail,available,275,"// TODO: it appears to provide compiler with some sort of a hint. We do not; // know what exactly it is supposed to do. However, CUDA headers suggest that; // just passing through __ptr should not affect correctness. They do so on; // pre-sm80 GPUs where this builtin is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:70,Integrability,wrap,wrappers,70,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:214,Integrability,wrap,wrappers,214,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:137,Safety,avoid,avoid,137,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:128,Integrability,depend,depends,128,// libdevice provides fast low precision and slow full-recision implementations; // for some functions. Which one gets selected depends on; // __CLANG_CUDA_APPROX_TRANSCENDENTALS__ which gets defined by clang if; // -ffast-math or -fgpu-approx-transcendentals are in effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:748,Deployability,pipeline,pipeline,748,"/*===---- __clang_cuda_runtime_wrapper.h - CUDA runtime support -------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * WARNING: This header is intended to be directly -include'd by; * the compiler and is not supposed to be included by users.; *; * CUDA headers are implemented in a way that currently makes it; * impossible for user code to #include directly when compiling with; * Clang. They present different view of CUDA-supplied functions; * depending on where in NVCC's compilation pipeline the headers are; * included. Neither of these modes provides function definitions with; * correct attributes, so we use preprocessor to force the headers; * into a form that Clang can use.; *; * Similarly to NVCC which -include's cuda_runtime.h, Clang -include's; * this file during every CUDA compilation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:707,Integrability,depend,depending,707,"/*===---- __clang_cuda_runtime_wrapper.h - CUDA runtime support -------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * WARNING: This header is intended to be directly -include'd by; * the compiler and is not supposed to be included by users.; *; * CUDA headers are implemented in a way that currently makes it; * impossible for user code to #include directly when compiling with; * Clang. They present different view of CUDA-supplied functions; * depending on where in NVCC's compilation pipeline the headers are; * included. Neither of these modes provides function definitions with; * correct attributes, so we use preprocessor to force the headers; * into a form that Clang can use.; *; * Similarly to NVCC which -include's cuda_runtime.h, Clang -include's; * this file during every CUDA compilation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:89,Integrability,depend,depend,89,"// Define __CUDACC__ early as libstdc++ standard headers with GNU extensions; // enabled depend on it to avoid using __float128, which is unsupported in; // CUDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:105,Safety,avoid,avoid,105,"// Define __CUDACC__ early as libstdc++ standard headers with GNU extensions; // enabled depend on it to avoid using __float128, which is unsupported in; // CUDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:36,Safety,avoid,avoid,36,// Include some standard headers to avoid CUDA headers including them; // while some required macros (like __THROW) are in a weird state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:43,Availability,avail,available,43,// Make largest subset of device functions available during host; // compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:109,Modifiability,variab,variables,109,// No need for device_launch_parameters.h as __clang_cuda_builtin_vars.h above; // has taken care of builtin variables declared in the file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:55,Testability,stub,stubs,55,// Disables definitions of device-side runtime support stubs in; // cuda_device_runtime_api.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:175,Usability,simpl,simple,175,"// math_functions.hpp expects this host function be defined on MacOS, but it; // ends up not being there because of the games we play here. Just define it; // ourselves; it's simple enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers for many device-side standard library functions, incl. math; // functions, became compiler builtins in CUDA-9 and have been removed from the; // CUDA headers. Clang now provides its own implementation of the wrappers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:220,Integrability,wrap,wrappers,220,"// Wrappers for many device-side standard library functions, incl. math; // functions, became compiler builtins in CUDA-9 and have been removed from the; // CUDA headers. Clang now provides its own implementation of the wrappers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:222,Safety,detect,detect,222,"// CUDA 8.0.41 relies on __USE_FAST_MATH__ and __CUDA_PREC_DIV's values.; // Previous versions used to check whether they are defined or not.; // CU_DEVICE_INVALID macro is only defined in 8.0.41, so we use it; // here to detect the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:45,Availability,avail,available,45,// Pull in host-only functions that are only available when neither; // __CUDACC__ nor __CUDABE__ are defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:196,Performance,optimiz,optimizer,196,"// Don't include sm_30_intrinsics.h and sm_32_intrinsics.h. These define the; // __shfl and __ldg intrinsics using inline (volatile) asm, but we want to; // define them using builtins so that the optimizer can reason about and across; // these instructions. In particular, using intrinsics for ldg gets us the; // [addr+imm] addressing mode, which, although it doesn't actually exist in the; // hardware, seems to generate faster machine code because ptxas can more easily; // reason about our code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:104,Integrability,wrap,wrapper,104,// CUDA-9 omits device-side definitions of some math functions if it sees; // include guard from math.h wrapper from libstdc++. We have to undo the header; // guard temporarily to get the definitions we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:139,Usability,undo,undo,139,// CUDA-9 omits device-side definitions of some math functions if it sees; // include guard from math.h wrapper from libstdc++. We have to undo the header; // guard temporarily to get the definitions we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:19,Usability,undo,undo,19,// We also need to undo another guard that checks for libc++ 3.8+,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:145,Integrability,depend,depend,145,// __clang_cuda_texture_intrinsics.h must be included first in order to provide; // implementation for __nv_tex_surf_handler that CUDA's headers depend on.; // The implementation requires c++11 and only works with CUDA-9 or newer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:170,Availability,error,error,170,"// Textures in CUDA-8 and older are not supported by clang.There's no; // convenient way to intercept texture use in these versions, so we can't; // produce a meaningful error. The source code that attempts to use textures; // will continue to fail as it does now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:87,Integrability,interoperab,interoperability,87,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:163,Integrability,wrap,wrappers,163,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:78,Usability,guid,guide-to-interoperability,78,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:139,Testability,assert,assert,139,// __assertfail() used to have a `noreturn` attribute. Unfortunately that; // contributed to triggering the longstanding bug in ptxas when assert was used; // in sufficiently convoluted code. See; // https://bugs.llvm.org/show_bug.cgi?id=27738 for the details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:25,Testability,assert,assert,25,// In order for standard assert() macro on linux to work we need to; // provide device-side __assert_fail(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:76,Deployability,configurat,configuration,76,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:76,Modifiability,config,configuration,76,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:51,Security,access,access,51,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:26,Usability,undo,undocumented,26,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:140,Safety,avoid,avoid,140,// Put all functions into anonymous namespace so they have internal linkage.; // The device-only function here must be internal in order to avoid ODR; // violations in case they are used from the files compiled with; // -fgpu-rdc. E.g. a library and an app using it may be built with a different; // version of this header file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:28,Security,hash,hash,28,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:270,Security,hash,hash,270,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:400,Security,hash,hashing,400,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:453,Security,hash,hash,453,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:646,Security,hash,hash,646,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:440,Testability,test,test,440,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:34,Availability,avail,available,34,"// Same, but for sparse ops. Only available on sm_60+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:101,Modifiability,inherit,inherit,101,"// CUDA headers have some 'legacy' texture oprerations that duplicate; // functionality. So, we just inherit it, instead of refining a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:285,Performance,optimiz,optimize,285,"// texture<> objects get magically converted into a texture reference. However,; // there's no way to convert them to cudaTextureObject_t on C++ level. So, we; // cheat a bit and use inline assembly to do it. It costs us an extra register; // and a move, but that is easy for ptxas to optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:48,Integrability,depend,dependent,48,"// The value returned by fpclassify is platform dependent, therefore it is not; // supported by hipRTC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:257,Safety,avoid,avoid,257,"// For OpenMP we work around some old system headers that have non-conforming; // `isinf(float)` and `isnan(float)` implementations that return an `int`. We do; // this by providing two versions of these functions, differing only in the; // return type. To avoid conflicting definitions we disable implicit base; // function generation. That means we will end up with two specializations, one; // per type, but only one has a base function defined by the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:221,Safety,avoid,avoid,221,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:418,Safety,avoid,avoid,418,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:20,Availability,avail,available,20,// decltype is only available in C++11 and above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:120,Availability,error,error,120,// namespace __hip; // __HIP_OVERLOAD1 is used to resolve function calls with integer argument to; // avoid compilation error due to ambibuity. e.g. floor(5) is resolved with; // floor(double).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:102,Safety,avoid,avoid,102,// namespace __hip; // __HIP_OVERLOAD1 is used to resolve function calls with integer argument to; // avoid compilation error due to ambibuity. e.g. floor(5) is resolved with; // floor(double).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:122,Availability,error,error,122,"// __HIP_OVERLOAD2 is used to resolve function calls with mixed float/double; // or integer argument to avoid compilation error due to ambibuity. e.g.; // max(5.0f, 6.0) is resolved with max(double, double).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:104,Safety,avoid,avoid,104,"// __HIP_OVERLOAD2 is used to resolve function calls with mixed float/double; // or integer argument to avoid compilation error due to ambibuity. e.g.; // max(5.0f, 6.0) is resolved with max(double, double).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h:43,Deployability,release,releases,43,"// Deprecated, should be removed when rocm releases using it are no longer; // relevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:133,Integrability,depend,depends,133,// Device library provides fast low precision and slow full-recision; // implementations for some functions. Which one gets selected depends on; // __CLANG_GPU_APPROX_TRANSCENDENTALS__ which gets defined by clang if; // -ffast-math or -fgpu-approx-transcendentals are in effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:35,Security,encrypt,encryption,35,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:592,Security,encrypt,encrypted,592,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:36,Security,encrypt,encryption,36,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:597,Security,encrypt,encrypted,597,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs a single round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDEC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs the final round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDECLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:34,Security,encrypt,encryption,34,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:535,Security,encrypt,encryption,535,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:619,Security,encrypt,encryption,619,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:677,Security,encrypt,encryption,677,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:142,Availability,error,error,142,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:124,Safety,avoid,avoid,124,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h:142,Availability,error,error,142,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h:124,Safety,avoid,avoid,124,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h:85,Testability,log,log,85,//===----------------------------------------------------------------------===//; // log builtins; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard assert.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h:31,Testability,assert,assert,31,"//===-- Wrapper for C standard assert.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard ctype.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,Availability,redundant,redundantly,58,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,Safety,redund,redundantly,58,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard inttypes.h declarations on the GPU ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard stdio.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard stdlib.h declarations on the GPU -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard string.h declarations on the GPU -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard time.h declarations on the GPU -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h:35,Integrability,wrap,wrapper,35,"/*===-- complex --- OpenMP complex wrapper for target regions --------- c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h:437,Usability,simpl,simplified,437,"//===------------------------- __complex_cmath.h --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // std::complex header copied from the libcxx source and simplified for use in; // OpenMP target offload regions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h:3,Testability,log,log,3,// log,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:790,Availability,error,errors,790,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:933,Integrability,depend,dependence,933,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:803,Safety,avoid,avoids,803,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h:38,Integrability,wrap,wrapper,38,"/*===---- time.h - OpenMP time header wrapper ------------------------ c ---===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- bmiintrin.h - Implementation of BMI2 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:24,Availability,mask,mask,24,/* The pop-count of the mask gives the number of the bits from; source to process. This is also needed to shift bits from the; source into the correct position for the result. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:49,Availability,mask,mask,49,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:73,Availability,mask,mask,73,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:58,Usability,clear,clearing,58,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:10,Availability,mask,mask,10,/* if the mask is constant and selects 8 bits or less we can use; the Power8 Bit permute instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:20,Availability,mask,mask,20,"/* Also if the pext mask is constant, then the popcount is; constant, we can evaluate the following loop at compile; time and use a constant bit permute vector. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:188,Availability,mask,mask,188,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:119,Safety,avoid,avoids,119,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:215,Testability,test,test,215,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:175,Usability,clear,clearing,175,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:32,Integrability,depend,depend,32,/* these 32-bit implementations depend on 64-bit pdep/pext; which depend on _ARCH_PWR7. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:66,Integrability,depend,depend,66,/* these 32-bit implementations depend on 64-bit pdep/pext; which depend on _ARCH_PWR7. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- bmiintrin.h - Implementation of BMI intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:185,Energy Efficiency,Power,PowerPC,185,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:517,Energy Efficiency,POWER,POWER,517,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:600,Energy Efficiency,Power,PowerISA,600,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:777,Energy Efficiency,efficient,efficiently,777,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:658,Modifiability,portab,portable,658,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:761,Performance,perform,performed,761,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:830,Performance,optimiz,optimized,830,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:687,Security,access,access,687,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we do the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:26,Testability,log,logically,26,/* Pre-rotate __A left 3 (logically right 1) elements. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:82,Availability,mask,mask,82,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 2-bit mask from the most significant bits of the DPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 2-bit mask from the most significant bits of the DPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:108,Performance,load,load,108,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:101,Safety,avoid,avoid,101,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:75,Availability,mask,mask,75,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Return a mask created from the most significant bit of each 8-bit; element in A. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Return a mask created from the most significant bit of each 8-bit; element in A. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:367,Performance,perform,performed,367,"/* Note: vec_sum2s could be used here, but on little-endian, vector; shifts are added that are not needed for this use-case.; A vector shift to correctly position the 32-bit integer results; (currently at [0] and [2]) to [1] and [3] would then need to be; swapped back again since the desired results are two 64-bit; integers ([1]|[0] and [3]|[2]). Thus, no shift is performed. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block flush. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:29,Performance,load,load,29,/* Use light weight sync for load to load ordering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:37,Performance,load,load,37,/* Use light weight sync for load to load ordering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h:62,Energy Efficiency,Power,PowerPC,62,"/*===---- immintrin.h - Implementation of Intel intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:123,Energy Efficiency,Power,PowerPC,123,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:377,Energy Efficiency,Power,PowerPC,377,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:473,Energy Efficiency,efficient,efficient,473,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:704,Energy Efficiency,efficient,efficient,704,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:690,Modifiability,portab,portable,690,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:20,Energy Efficiency,Power,PowerPC,20,/* nothing to do on PowerPC. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:20,Energy Efficiency,Power,PowerPC,20,/* nothing to do on PowerPC. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h:12,Integrability,depend,depend,12,/* We can't depend on <stdlib.h> since the prototype of posix_memalign; may not be visible. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- nmmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- pmmintrin.h - Implementation of SSE3 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- pmmintrin.h - Implementation of SSE3 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:463,Energy Efficiency,Power,PowerPC,463,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:884,Energy Efficiency,schedul,schedule,884,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:964,Energy Efficiency,monitor,monitor,964,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:1034,Energy Efficiency,Power,PowerISA,1034,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:927,Performance,latency,latency,927,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:909,Safety,avoid,avoid,909,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- smmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. NOTE: This is NOT a complete implementation of the SSE4 intrinsics! */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:451,Usability,Guid,Guide,451,"/*===---- smmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. NOTE: This is NOT a complete implementation of the SSE4 intrinsics! */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:366,Modifiability,portab,portable,366,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:387,Performance,optimiz,optimized,387,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:62,Energy Efficiency,Power,PowerPC,62,"/*===---- tmmintrin.h - Implementation of SSSE3 intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- tmmintrin.h - Implementation of SSSE3 intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:356,Modifiability,portab,portable,356,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:377,Performance,optimiz,optimized,377,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h:66,Energy Efficiency,Power,PowerPC,66,"/*===--- x86gprintrin.h - Implementation of X86 GPR intrinsics on PowerPC --===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- x86intrin.h - Implementation of X86 intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- xmmintrin.h - Implementation of SSE intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- xmmintrin.h - Implementation of SSE intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:170,Energy Efficiency,Power,PowerPC,170,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:502,Energy Efficiency,POWER,POWER,502,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:585,Energy Efficiency,Power,PowerISA,585,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:761,Energy Efficiency,efficient,efficiently,761,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:643,Modifiability,portab,portable,643,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:745,Performance,perform,performed,745,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:814,Performance,optimiz,optimized,814,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:672,Security,access,access,672,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower float); * results. So to insure we don't generate spurious exceptions; * (from the upper float values) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower float); * results. So to insure we don't generate spurious exceptions; * (from the upper float values) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we do the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:11,Energy Efficiency,Power,PowerPC,11,/* Current PowerPC will ignores the hint parameters. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:82,Availability,mask,mask,82,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 4-bit mask from the most significant bits of the SPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 4-bit mask from the most significant bits of the SPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:153,Usability,clear,cleared,153,/* Compute the sum of the absolute differences of the unsigned 8-bit; values in A and B. Return the value in the lower 16-bit word; the; upper words are cleared. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:63,Performance,cache,caches,63,/* Stores the data in A to the address P without polluting the caches. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:433,Deployability,release,release,433,"/* On power8 and later processors we can depend on Program Priority; (PRI) and associated ""very low"" PPI setting. Since we don't know; what PPI this thread is running at we: 1) save the current PRI; from the PPR SPR into a local GRP, 2) set the PRI to ""very low*; via the special or 31,31,31 encoding. 3) issue an ""isync"" to; insure the PRI change takes effect before we execute any more; instructions.; Now we can execute a lwsync (release barrier) while we execute; this thread at ""very low"" PRI. Finally we restore the original; PRI and continue execution. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:41,Integrability,depend,depend,41,"/* On power8 and later processors we can depend on Program Priority; (PRI) and associated ""very low"" PPI setting. Since we don't know; what PPI this thread is running at we: 1) save the current PRI; from the PPR SPR into a local GRP, 2) set the PRI to ""very low*; via the special or 31,31,31 encoding. 3) issue an ""isync"" to; insure the PRI change takes effect before we execute any more; instructions.; Now we can execute a lwsync (release barrier) while we execute; this thread at ""very low"" PRI. Finally we restore the original; PRI and continue execution. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:89,Integrability,depend,depend,89,/* For older processor where we may not even have Program Priority; controls we can only depend on Heavy Weight Sync. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp:4,Availability,avail,availability,4,// 'availability' attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:21,Integrability,message,message,21,// Implicit property message sends are not 'implicit'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:84,Integrability,message,message,84,"// No need to do a handleReference for the objc method, because there will; // be a message expr as part of PseudoObjectExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:25,Integrability,depend,dependent,25,// FIXME: Try to resolve dependent field references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:207,Testability,test,tests,207,// Visit implicit @synthesize property implementations first as their; // location is reported at the name of the @implementation block. This; // serves no purpose other than to simplify the FileCheck-based tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:178,Usability,simpl,simplify,178,// Visit implicit @synthesize property implementations first as their; // location is reported at the name of the @implementation block. This; // serves no purpose other than to simplify the FileCheck-based tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:247,Integrability,interface,interface,247,"// For synthesized ivars, use the location of its name in the; // corresponding @synthesize. If there isn't one, use the containing; // @implementation's location, rather than the property's location,; // otherwise the header file containing the @interface will have different; // indexing contents based on whether the @implementation was present or; // not in the translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:39,Integrability,depend,dependent,39,"// FIXME: Ignore a class template in a dependent context, these are not; // linked properly with their redeclarations, ending up with duplicate; // USRs.; // See comment ""Friend templates are visible in fairly strange ways."" in; // SemaTemplate.cpp which precedes code that prevents the friend template; // from becoming visible from the enclosing context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp:55,Availability,avail,available,55,// Fallback to primary template if no instantiation is available yet (e.g.; // the type doesn't need to be complete).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp:124,Testability,test,test,124,"/// \returns true if \c D is in a subclass of 'XCTestCase', returns void, has; /// no parameters, and its name starts with 'test'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:346,Modifiability,inherit,inherited,346,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:176,Safety,Avoid,Avoiding,176,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:84,Usability,clear,clear,84,"// The relations we have to `Parent` do not apply to our template arguments,; // so clear them while visiting the args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:27,Integrability,Rout,Routines,27,"//===- USRGeneration.cpp - Routines for USR generation --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:205,Availability,error,error,205,//===----------------------------------------------------------------------===//; // USR generation.; //===----------------------------------------------------------------------===//; /// \returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:38,Integrability,protocol,protocol,38,/// Generate a USR for an Objective-C protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:3,Modifiability,Variab,Variables,3,// Variables always have simple names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:25,Usability,simpl,simple,25,// Variables always have simple names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:162,Availability,avail,available,162,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:34,Integrability,interface,interface,34,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:146,Integrability,interface,interface,146,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:162,Availability,avail,available,162,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:34,Integrability,interface,interface,34,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:146,Integrability,interface,interface,146,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:104,Testability,log,logic,104,"// This method mangles in USR information for types. It can possibly; // just reuse the naming-mangling logic used by codegen, although the; // requirements for USRs might not be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:16,Integrability,depend,dependent,16,// FIXME: Visit dependent template names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:3,Usability,Simpl,Simple,3,// Simple name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:417,Performance,perform,performs,417,"//===------ CodeCompletion.cpp - Code Completion for ClangRepl -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the classes which performs code completion at the REPL.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:53,Integrability,interface,interfaces,53,"/// The class CompletionContextHandler contains four interfaces, each of; /// which handles one type of completion result.; /// Its derived classes are used to create concrete handlers based on; /// \c CodeCompletionContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:246,Modifiability,variab,variable,246,"// Load all external decls into current context. Under the hood, it calls; // ExternalSource::completeVisibleDeclsMap, which make all decls on the redecl; // chain visible.; //; // This is crucial to code completion on dot members, since a bound variable; // before ""."" would be otherwise treated out-of-scope.; //; // clang-repl> Foo f1;; // clang-repl> f1.<tab>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:3,Performance,Load,Load,3,"// Load all external decls into current context. Under the hood, it calls; // ExternalSource::completeVisibleDeclsMap, which make all decls on the redecl; // chain visible.; //; // This is crucial to code completion on dot members, since a bound variable; // before ""."" would be otherwise treated out-of-scope.; //; // clang-repl> Foo f1;; // clang-repl> f1.<tab>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:9,Availability,error,error,9,"// if an error happens, it usually means the decl has already been; // imported or the decl is a result of a failed import. But in our; // case, every import is fresh each time code completion is; // triggered. So Import usually doesn't fail. If it does, it just means; // the related decl can't be used in code completion and we can safely; // drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:334,Safety,safe,safely,334,"// if an error happens, it usually means the decl has already been; // imported or the decl is a result of a failed import. But in our; // case, every import is fresh each time code completion is; // triggered. So Import usually doesn't fail. If it does, it just means; // the related decl can't be used in code completion and we can safely; // drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:38,Deployability,release,release,38,"// we don't want the AU destructor to release the memory buffer that MB; // owns twice, because MB handles its resource on its own.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp:420,Performance,perform,performs,420,"//===--- IncrementalExecutor.cpp - Incremental Execution --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h:420,Performance,perform,performs,420,"//===--- IncrementalExecutor.h - Incremental Execution ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:419,Performance,perform,performs,419,"//===--------- IncrementalParser.cpp - Incremental Compilation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:390,Availability,alive,alive,390,/// A custom action enabling the incremental processing functionality.; ///; /// The usual \p FrontendAction expects one call to ExecuteAction and once it; /// sees a call to \p EndSourceFile it deletes some of the important objects; /// such as \p Preprocessor and \p Sema assuming no further input will come.; ///; /// \p IncrementalAction ensures it keep its underlying action's objects alive; /// as long as the \p IncrementalParser needs them.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:97,Availability,alive,alive,97,// Do not terminate after processing the input. This allows us to keep various; // clang objects alive and to incrementally grow the current TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:52,Availability,error,error,52,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:7,Integrability,Wrap,WrappedAction,7,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Performance,Load,LoadedID,2,/*LoadedID=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Performance,Load,LoadedOffset,2,/*LoadedOffset=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:420,Performance,perform,performs,420,"//===--- IncrementalParser.h - Incremental Compilation ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:22,Performance,perform,performing,22,/// Compiler instance performing the incremental compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:103,Availability,alive,alive,103,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:56,Performance,cache,cached,56,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:40,Performance,cache,cache,40,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:50,Safety,avoid,avoids,50,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:424,Performance,perform,performs,424,"//===------ Interpreter.cpp - Incremental Compilation and Execution -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the component which performs incremental code; // compilation and execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:94,Testability,test,test,94,// FIXME: Figure out how to unify with namespace init_convenience from; // tools/clang-import-test/clang-import-test.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:112,Testability,test,test,112,// FIXME: Figure out how to unify with namespace init_convenience from; // tools/clang-import-test/clang-import-test.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:96,Availability,error,error,96,/// Retrieves the clang CC1 specific flags out of the compilation's jobs.; /// \returns NULL on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.; // FIXME: Clang should register these container operations automatically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:9,Usability,clear,clear,9,"// Don't clear the AST before backend codegen since we do codegen multiple; // times, reusing the same AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:55,Availability,avail,availability,55,// FIXME: This is a ugly hack. Undo command checks its availability by looking; // at the size of the PTU list. However we have parsed something in the; // beginning of the REPL so we have to mark them as 'Irrevocable'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:31,Usability,Undo,Undo,31,// FIXME: This is a ugly hack. Undo command checks its availability by looking; // at the size of the PTU list. However we have parsed something in the; // beginning of the REPL so we have to mark them as 'Irrevocable'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:3,Safety,avoid,avoid,3,// avoid writing fat binary to disk using an in-memory virtual file system,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:39,Energy Efficiency,reduce,reduce,39,// Force cast these types to uint64 to reduce the number of overloads of; // `__clang_Interpreter_SetValueNoAlloc`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:56,Deployability,canary,canary,56,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:141,Deployability,canary,canary,141,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:41,Security,validat,validating,41,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:18,Deployability,canary,canary,18,// These are some canary bits that are used for protecting the storage been; // damaged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:565,Availability,down,down,565,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:546,Energy Efficiency,reduce,reduces,546,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:7,Integrability,Depend,DependencyDirectivesScanner,7,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:408,Integrability,interface,interface,408,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:648,Testability,log,logic,648,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:12,Energy Efficiency,efficient,efficient,12,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:47,Safety,detect,detect,47,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:86,Availability,error,error,86,/// Lex the provided source and emit the directive tokens.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:65,Performance,perform,performing,65,/// Returns the spelling of a string literal or identifier after performing; /// any processing needed to handle \c clang::Token::NeedsCleaning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:186,Usability,clear,cleared,186,"/// Keeps track of the tokens for the currently lexed directive. Once a; /// directive is fully lexed and ""committed"" then the tokens get appended to; /// \p Tokens and \p CurDirToks is cleared for the next directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:39,Modifiability,extend,extend,39,// String and character literals don't extend past the end of the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:37,Safety,avoid,avoid,37,// Iterate over strings correctly to avoid comments and newlines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:66,Energy Efficiency,allocate,allocated,66,// Use a new scanner instance since the tokens will be inside the allocated; // string. We should already have captured all the relevant tokens in the; // current scanner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:4,Usability,Clear,Clear,4,"/// Clear Scanner's CurDirToks before returning, in case we didn't push a; /// new directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:130,Integrability,depend,dependency,130,"// A \p tok::hashhash at this location is passed by the preprocessor to the; // parser to interpret, like any other token. So for dependency scanning; // skip it like a normal token not affecting the preprocessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:13,Security,hash,hashhash,13,"// A \p tok::hashhash at this location is passed by the preprocessor to the; // parser to interpret, like any other token. So for dependency scanning; // skip it like a normal token not affecting the preprocessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:52,Testability,test,testing,52,// Add a space separator where it is convenient for testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:418,Integrability,interface,interface,418,"//===--- HeaderMap.cpp - A file that acts like dir of symlinks ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the HeaderMap interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:4,Security,Hash,HashHMapKey,4,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:43,Security,hash,hash,43,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:119,Security,hash,hash,119,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:135,Security,hash,hash,135,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:151,Usability,simpl,simple,151,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:452,Availability,error,error,452,"//===----------------------------------------------------------------------===//; // Verification and Construction; //===----------------------------------------------------------------------===//; /// HeaderMap::Create - This attempts to load the specified file as a header; /// map. If it doesn't look like a HeaderMap, it gives up and returns null.; /// If it looks like a HeaderMap but is obviously corrupted, it puts a reason; /// into the string error argument and returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:239,Performance,load,load,239,"//===----------------------------------------------------------------------===//; // Verification and Construction; //===----------------------------------------------------------------------===//; /// HeaderMap::Create - This attempts to load the specified file as a header; /// map. If it doesn't look like a HeaderMap, it gives up and returns null.; /// If it looks like a HeaderMap but is obviously corrupted, it puts a reason; /// into the string error argument and returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:47,Energy Efficiency,power,power,47,"// Check the number of buckets. It should be a power of two, and there; // should be enough space in the file for all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:37,Security,hash,hash,37,"/// getBucket - Return the specified hash table bucket from the header map,; /// bswap'ing its fields as appropriate. If the bucket number is not valid,; /// this return a bucket with an empty key (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:3,Performance,Load,Load,3,"// Load the values, bswapping as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:22,Security,hash,hash,22,// Linearly probe the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:3,Security,Hash,Hash,3,"// Hash miss.; // See if the key matches. If not, probe on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:33,Security,hash,hash,33,"// If so, we have a match in the hash table. Construct the destination; // path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:441,Integrability,interface,interfaces,441,"//===- HeaderSearch.cpp - Resolve Header File Locations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DirectoryLookup and HeaderSearch interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:18,Usability,clear,clear,18,//LookupFileCache.clear();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:42,Performance,load,load,42,"// The ModuleMap maybe a nullptr, when we load a cached C++ module without; // *.modulemap file. In this case, just return an empty string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:49,Performance,cache,cached,49,"// The ModuleMap maybe a nullptr, when we load a cached C++ module without; // *.modulemap file. In this case, just return an empty string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:197,Safety,avoid,avoid,197,"// The separator of C++20 modules partitions (':') is not good for file; // systems, here clang and gcc choose '-' by default since it is not a; // valid character of C++ indentifiers. So we could avoid conflicts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:130,Availability,failure,failure,130,// If we have the same ModuleCachePath and PrebuiltModulePath pointing; // to the same folder we should not cache the file lookup failure as it; // may be currently building an implicit module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:108,Performance,cache,cache,108,// If we have the same ModuleCachePath and PrebuiltModulePath pointing; // to the same folder we should not cache the file lookup failure as it; // may be currently building an implicit module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:29,Performance,cache,cache,29,"// If we don't have a module cache path or aren't supposed to use one, we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:170,Safety,safe,safe,170,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:297,Safety,avoid,avoid,297,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:36,Security,hash,hash,36,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:161,Security,hash,hash,161,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:430,Integrability,depend,dependencies,430,"// The facility for ""private modules"" -- adjacent, optional module maps named; // module.private.modulemap that are supposed to define private submodules --; // may have different flavors of names: FooPrivate, Foo_Private and Foo.Private.; //; // Foo.Private is now deprecated in favor of Foo_Private. Users of FooPrivate; // should also rename to Foo_Private. Representing private as submodules; // could force building unwanted dependencies into the parent module and cause; // dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:480,Integrability,depend,dependency,480,"// The facility for ""private modules"" -- adjacent, optional module maps named; // module.private.modulemap that are supposed to define private submodules --; // may have different flavors of names: FooPrivate, Foo_Private and Foo.Private.; //; // Foo.Private is now deprecated in favor of Foo_Private. Users of FooPrivate; // should also rename to Foo_Private. Representing private as submodules; // could force building unwanted dependencies into the parent module and cause; // dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:60,Availability,avail,available,60,"// Look through the various header search paths to load any available module; // maps, searching for a module map that describes this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:51,Performance,load,load,51,"// Look through the various header search paths to load any available module; // maps, searching for a module map that describes this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:69,Availability,avail,available,69,// We just loaded a module map file; check whether the module is; // available now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:11,Performance,load,loaded,11,// We just loaded a module map file; check whether the module is; // available now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:14,Performance,load,loaded,14,"// If we just loaded a module map file, look for the module again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:20,Performance,perform,performed,20,"// If we've already performed the exhaustive search for module maps in this; // search directory, don't do it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load all module maps in the immediate subdirectories of this search; // directory if ModuleName was from @import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:55,Performance,load,load,55,"// If we have a module map that might map this header, load it and; // check whether we'll have a suggestion for a module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:24,Availability,error,errors,24,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:77,Integrability,message,message,77,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:183,Testability,log,logic,183,// Header maps need to be marked as used whenever the filename matches.; // The case where the target file **exists** is handled by callee of this; // function as part of the regular logic that applies to include search paths.; // The case where the target file **does not exist** is handled here:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:470,Security,access,access,470,"// Note: as an egregious but useful hack we use the real path here, because; // frameworks moving between top-level frameworks to embedded frameworks tend; // to be symlinked, and we base the logical structure of modules on the; // physical layout. In particular, we need to deal with crazy includes like; //; // #include <Foo/Frameworks/Bar.framework/Headers/Wibble.h>; //; // where 'Bar' used to be embedded in 'Foo', is now a top-level framework; // which one should access with, e.g.,; //; // #include <Bar/Wibble.h>; //; // Similar issues occur when a top-level framework has moved into an; // embedded framework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:192,Testability,log,logical,192,"// Note: as an egregious but useful hack we use the real path here, because; // frameworks moving between top-level frameworks to embedded frameworks tend; // to be symlinked, and we base the logical structure of modules on the; // physical layout. In particular, we need to deal with crazy includes like; //; // #include <Foo/Frameworks/Bar.framework/Headers/Wibble.h>; //; // where 'Bar' used to be embedded in 'Foo', is now a top-level framework; // which one should access with, e.g.,; //; // #include <Bar/Wibble.h>; //; // Similar issues occur when a top-level framework has moved into an; // embedded framework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,cache,cache,10,"// If the cache entry was unresolved, populate it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Safety,Detect,Detect,3,"// Detect different types of framework style paths:; //; // ...Foo.framework/{Headers,PrivateHeaders}; // ...Foo.framework/Versions/{A,Current}/{Headers,PrivateHeaders}; // ...Foo.framework/Frameworks/Nested.framework/{Headers,PrivateHeaders}; // ...<other variations with 'Versions' like in the above path>; //; // and some other variations among these lines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:178,Integrability,depend,dependency,178,"// Headers in Foo.framework/Headers should not include headers; // from Foo.framework/PrivateHeaders, since this violates public/private; // API boundaries and can cause modular dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:100,Availability,failure,failure,100,"/// LookupFile - Given a ""foo"" or \<foo> reference, look up the indicated file,; /// return null on failure. isAngled indicates whether the file reference is; /// for system \#include's or not (i.e. using <> instead of """"). Includers, if; /// non-empty, indicates where the \#including file(s) are, in case a relative; /// search is needed. Microsoft mode will pass all \#including files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:19,Performance,cache,cache,19,"// FIXME: We don't cache the result of getFileInfo across the call to; // getFileAndSuggestModule, because it's a reference to an element of; // a container that could be reallocated across this call.; //; // If we have no includer, that means we're processing a #include; // from a module build. We should treat this as a system header if we're; // building a [system] module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Cache,Cache,3,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:28,Performance,perform,performed,28,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:116,Performance,optimiz,optimization,116,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:83,Safety,avoid,avoid,83,// Handle cold misses of user includes in the presence of many header; // maps. We avoid searching perhaps thousands of header maps by; // jumping directly to the correct one or jumping beyond all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Cache,Cache,3,// Cache subframework.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:401,Performance,cache,cached,401,"// Modules with builtins are special; multiple modules use builtins as; // modular headers, example:; //; // module stddef { header ""stddef.h"" export * }; //; // After module map parsing, this expands to:; //; // module stddef {; // header ""/path_to_builtin_dirs/stddef.h""; // textual ""stddef.h""; // }; //; // It's common that libc++ and system modules will both define such; // submodules. Make sure cached results for a builtin header won't; // prevent other builtin modules from potentially entering the builtin; // header. Note that builtins are header guarded and the decision to; // actually enter them is postponed to the controlling macros logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:648,Testability,log,logic,648,"// Modules with builtins are special; multiple modules use builtins as; // modular headers, example:; //; // module stddef { header ""stddef.h"" export * }; //; // After module map parsing, this expands to:; //; // module stddef {; // header ""/path_to_builtin_dirs/stddef.h""; // textual ""stddef.h""; // }; //; // It's common that libc++ and system modules will both define such; // submodules. Make sure cached results for a builtin header won't; // prevent other builtin modules from potentially entering the builtin; // header. Note that builtins are header guarded and the decision to; // actually enter them is postponed to the controlling macros logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:37,Integrability,wrap,wrapped,37,"// Next, check to see if the file is wrapped with #ifndef guards. If so, and; // if the macro that guards it is defined, we know the #include has no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load the module map file in this directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:54,Modifiability,inherit,inherit,54,// Success. All of the directories we stepped through inherit this module; // map file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:98,Integrability,depend,dependency,98,"// If this module specifies [no_undeclared_includes], we cannot find any; // file that's in a non-dependency module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,"// Load this framework module. If that succeeds, find the suggested module; // for this header, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:184,Availability,down,down,184,"// FIXME: This can find a module not part of ModuleName, which is; // important so that we're consistent about whether this header; // corresponds to a module. Possibly we should lock down framework modules; // so that this is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:15,Testability,assert,assert,15,// FIXME: This assert can fail if there's a race between the above check; // and the removal of the directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:31,Performance,load,loaded,31,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:80,Performance,load,loaded,80,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:117,Performance,load,load,117,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a corresponding private module map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load module maps for each of the header search directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:50,Performance,load,load,50,"// Search each of the "".framework"" directories to load them as modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load this framework module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file for the search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load module map files for immediate subdirectories of this; // search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load module maps for each of the header search directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file for the search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:138,Deployability,update,updates,138,"// Checks whether `Dir` is a strict path prefix of `File`. If so and that's; // the longest prefix we've seen so for it, returns true and updates the; // `BestPrefixLength` accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:64,Performance,perform,performing,64,"/// Add the specified path to the specified group list, without performing any; /// sysroot remapping.; /// Returns true if the path exists, false if it was ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:27,Modifiability,config,configure,27,// Add dirs specified via 'configure --with-c-include-dirs'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:48,Testability,log,logic,48,// NB: This code path is going away. All of the logic is moving into the; // driver which has the information necessary to do target-specific; // selections of default include paths. Each target which moves there will be; // exempted from this logic in ShouldAddDefaultIncludePaths() until we can; // delete the entire pile of code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:244,Testability,log,logic,244,// NB: This code path is going away. All of the logic is moving into the; // driver which has the information necessary to do target-specific; // selections of default include paths. Each target which moves there will be; // exempted from this logic in ShouldAddDefaultIncludePaths() until we can; // delete the entire pile of code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:39,Testability,log,logic,39,// NOTE: some additional header search logic is handled in the driver for; // Darwin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:182,Deployability,update,update,182,"/// If there are duplicate directory entries in the specified search list,; /// remove the later (dead) ones. Returns the number of non-system headers; /// removed, which is used to update NumAngled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:424,Integrability,interface,interfaces,424,"//===- Lexer.cpp - C Language Family Lexer --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Lexer and Token interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:255,Integrability,rout,routine,255,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:544,Integrability,wrap,wrapper,544,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:725,Integrability,interface,interface,725,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:14,Performance,load,load,14,// Try to the load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:163,Energy Efficiency,allocate,allocate,163,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The actual length of the token is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:538,Safety,avoid,avoiding,538,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The actual length of the token is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:41,Testability,test,testing,41,// NOTE: this has to be checked *before* testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:40,Testability,test,testing,40,// NOTE: this can be checked even after testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:81,Availability,failure,failure,81,"/// Relex the token at the specified location.; /// \returns true if there was a failure, false on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:47,Testability,log,logical,47,// LexStart should point at first character of logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:108,Availability,avail,available,108,"// Figure out which directive this is. Since we're lexing raw tokens,; // we don't have an identifier table available. Instead, just look at; // the raw identifier to recognize and categorize preprocessor directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,Usability,simpl,simple,141,"// The usual case is that tokens don't contain anything interesting. Skip; // over the uninteresting characters. If a token only consists of simple; // chars, this method is extremely fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:109,Integrability,rout,routine,109,"/// Computes the source location just past the end of the; /// token at this source location.; ///; /// This routine can be used to produce a source location that; /// points just past the end of the token referenced by \p Loc, and; /// is generally used when a diagnostic needs to point just after a; /// token where it expected something different that it received. If; /// the returned source location would not be meaningful (e.g., if; /// it points into a macro), this routine returns an invalid; /// source location.; ///; /// \param Offset an offset from the end of the token, where the source; /// location should refer to. The default offset (0) produces a source; /// location pointing just past the end of the token; an offset of 1 produces; /// a source location pointing to the last character in the token, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:474,Integrability,rout,routine,474,"/// Computes the source location just past the end of the; /// token at this source location.; ///; /// This routine can be used to produce a source location that; /// points just past the end of the token referenced by \p Loc, and; /// is generally used when a diagnostic needs to point just after a; /// token where it expected something different that it received. If; /// the returned source location would not be meaningful (e.g., if; /// it points into a macro), this routine returns an invalid; /// source location.; ///; /// \param Offset an offset from the end of the token, where the source; /// location should refer to. The default offset (0) produces a source; /// location pointing just past the end of the token; an offset of 1 produces; /// a source location pointing to the last character in the token, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:14,Performance,load,load,14,// Try to the load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:332,Performance,perform,perform,332,"//===----------------------------------------------------------------------===//; // Diagnostics forwarding code.; //===----------------------------------------------------------------------===//; /// GetMappedTokenLoc - If lexing out of a 'mapped buffer', where we pretend the; /// lexer buffer was all expanded at a single point, perform the mapping.; /// This is currently only used for _Pragma implementation, so it is the slow; /// path of the hot getSourceLocation method. Do not allow it to be inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:48,Usability,simpl,simple,48,"// In the normal case, we're just lexing from a simple file buffer, return; // the file id from FileLoc with the offset specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:742,Deployability,update,updated,742,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:799,Deployability,update,updated,799,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:295,Integrability,depend,depending,295,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:246,Deployability,update,updated,246,"/// getCharAndSizeSlowNoWarn - Handle the slow/uncommon case of the; /// getCharAndSizeNoWarn method. Here we know that we can accumulate into Size,; /// and that we have already incremented Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlow (above) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:297,Deployability,update,updated,297,"/// getCharAndSizeSlowNoWarn - Handle the slow/uncommon case of the; /// getCharAndSizeNoWarn method. Here we know that we can accumulate into Size,; /// and that we have already incremented Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlow (above) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:199,Integrability,Rout,Routine,199,//===----------------------------------------------------------------------===//; // Helper methods for lexing.; //===----------------------------------------------------------------------===//; /// Routine that indiscriminately sets the offset into the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Modifiability,extend,extends,166,"// To mitigate https://github.com/llvm/llvm-project/issues/54732,; // we allow ""Mathematical Notation Characters"" in identifiers.; // This is a proposed profile that extends the XID_Start/XID_continue; // with mathematical symbols, superscipts and subscripts digits; // found in some production software.; // https://www.unicode.org/L2/L2022/22230-math-profile.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Testability,LOG,LOGICAL,3,// LOGICAL AND,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Availability,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part.; // Carry on as if the codepoint was valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Safety,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part.; // Carry on as if the codepoint was valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Availability,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part. Carry on as if the codepoint was; // valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Safety,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part. Carry on as if the codepoint was; // valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:37,Deployability,update,update,37,"// Fill in Result.IdentifierInfo and update the token kind,; // looking up the identifier in the identifier table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:235,Usability,simpl,simple,235,"// Skip the code-completion char and all immediate identifier characters.; // This ensures we get consistent behavior when completing at any point in; // an identifier (i.e. at the start, in the middle, at the end). Note that; // only simple cases (i.e. [a-zA-Z0-9_]) are supported to keep the code; // simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:303,Usability,simpl,simpler,303,"// Skip the code-completion char and all immediate identifier characters.; // This ensures we get consistent behavior when completing at any point in; // an identifier (i.e. at the start, in the middle, at the end). Note that; // only simple cases (i.e. [a-zA-Z0-9_]) are supported to keep the code; // simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of the token as well as the BufferPtr instance var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:179,Performance,perform,performed,179,"// This function doesn't use getAndAdvanceChar because C++0x [lex.pptoken]p3:; // Between the initial and final double quote characters of the raw string,; // any transformations performed in phases 1 and 2 (trigraphs,; // universal-character-names, and line splicing) are reverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:83,Deployability,Update,Update,83,/// SkipWhitespace - Efficiently skip over a series of whitespace characters.; /// Update BufferPtr to point to the next non-whitespace character and return.; ///; /// This method forms a token and returns true if KeepWhitespaceMode is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:21,Energy Efficiency,Efficient,Efficiently,21,/// SkipWhitespace - Efficiently skip over a series of whitespace characters.; /// Update BufferPtr to point to the next non-whitespace character and return.; ///; /// This method forms a token and returns true if KeepWhitespaceMode is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:27,Energy Efficiency,efficient,efficiently,27,// Skip consecutive spaces efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:132,Deployability,update,update,132,"/// We have just read the // characters from input. Skip until we find the; /// newline character that terminates the comment. Then update BufferPtr and; /// return.; ///; /// If we're in KeepCommentMode or any CommentHandler has inserted; /// some tokens, this will store the first token and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:174,Performance,optimiz,optimize,174,"// Scan over the body of the comment. The common case, when scanning, is that; // the comment contains normal ascii characters with nothing interesting in; // them. As such, optimize for this case with the inner loop.; //; // This loop terminates with CurPtr pointing at the newline (or end of buffer); // character that ends the line comment.; // C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:511,Safety,avoid,avoid,511,"// Scan over the body of the comment. The common case, when scanning, is that; // the comment contains normal ascii characters with nothing interesting in; // them. As such, optimize for this case with the inner loop.; //; // This loop terminates with CurPtr pointing at the newline (or end of buffer); // character that ends the line comment.; // C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:127,Safety,avoid,avoid,127,"// Otherwise, this is a hard case. Fall back on getAndAdvanceChar to; // properly decode the character. Read it in raw mode to avoid emitting; // diagnostics about things like trigraphs. If we see an escaped newline,; // we'll handle it below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:150,Performance,optimiz,optimization,150,"// Scan one character past where we should, looking for a '/' character. Once; // we find it, check to see if it was preceded by a *. This common; // optimization helps people who like to put a lot of * characters in their; // comments.; // The first character we get with newlines and trigraphs skipped to handle; // the degenerate /*/ case below correctly if the * has an escaped newline; // after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Safety,avoid,avoid,166,"// C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:39,Safety,avoid,avoid,39,// If there is a code-completion point avoid the fast scan because it; // doesn't check for '\0'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,Energy Efficiency,efficient,efficiently,141,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Safety,safe,safe,166,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:44,Modifiability,variab,variable,44,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:12,Performance,Cache,Cache,12,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:105,Availability,error,error,105,"// Issue diagnostics for unterminated #if and missing newline.; // If we are in a #if directive, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:156,Availability,error,error,156,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:171,Availability,recover,recover,171,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:171,Safety,recover,recover,171,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:114,Integrability,depend,depends,114,"// We do not offer misspelled character names suggestions here; // as the set of what would be a valid suggestion depends on context,; // and we should not make invalid suggestions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,Availability,recover,recover,112,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,Safety,recover,recover,112,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:291,Integrability,interface,interface,291,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:88,Performance,perform,performance,88,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:41,Usability,simpl,simple,41,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:353,Usability,clear,cleared,353,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:44,Modifiability,variab,variable,44,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:12,Performance,Cache,Cache,12,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:19,Performance,perform,performing,19,// Check if we are performing code completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:139,Safety,avoid,avoid,139,"// KeepWhitespaceMode; // We know the lexer hasn't changed, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:65,Energy Efficiency,efficient,efficiently,65,"// If the next token is obviously a // or /* */ comment, skip it efficiently; // too (without going through the big switch stmt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:106,Safety,avoid,avoid,106,"// We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:203,Energy Efficiency,efficient,efficiently,203,"// There is a token to return.; // It is common for the tokens immediately after a // comment to be; // whitespace (indentation for the next line). Instead of going through; // the big switch, handle it efficiently now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:138,Safety,avoid,avoid,138,"// There is a token to return.; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,Availability,recover,recover,97,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,Safety,recover,recover,97,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:58,Safety,avoid,avoid,58,// Suggest adding a space between the '<=' and the '>' to avoid a; // change in semantics if this turns up in C++ <=17 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,Availability,recover,recover,78,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,Safety,recover,recover,78,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:131,Safety,avoid,avoid,131,"// We're pretending the character didn't exist, so just try again with; // this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:54,Security,hash,hash,54,// Read something other than a preprocessor directive hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:477,Integrability,interface,interfaces,477,"//===--- LiteralSupport.cpp - Code to parse and process literals ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the NumericLiteralParser, CharLiteralParser, and; // StringLiteralParser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:61,Availability,mask,mask,61,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:97,Integrability,depend,depending,97,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Deployability,Update,Update,3,// Update the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:8,Integrability,rout,routine,8,"// This routine assumes that the range begin/end matches the regex for integer; // and FP constants (specifically, the 'pp-number' regex), and assumes that; // the byte at ""*end"" is both valid and not part of the regex. Because of; // this, it doesn't have to check for 'overscan' in various places.; // Note: For HLSL, the end token is allowed to be '.' which would be in the; // 'pp-number' regex. This is required to support vector swizzles on numeric; // constants (i.e. 1.xx or 1.5f.rrr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:98,Safety,avoid,avoid,98,"// CUDA host and device may have different _Float16 support, therefore; // allows f16 literals to avoid false alarm.; // When we compile for OpenMP target offloading on NVPTX, f16 suffix; // should also be supported.; // ToDo: more precise check for CUDA.; // TODO: AMDGPU might also support it in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for floating constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:36,Availability,error,error,36,"// If we reached here, there was an error or a ud-suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:13,Availability,error,error,13,// Report an error if there are any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:102,Availability,error,error,102,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:175,Safety,detect,detects,175,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:56,Safety,avoid,avoid,56,"/// Determine whether a suffix is a valid ud-suffix. We avoid treating reserved; /// suffixes as ud-suffixes, because the diagnostic experience is better if we; /// treat it as an invalid suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:10,Usability,simpl,simple,10,// Handle simple binary numbers 0b01010,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:9,Usability,simpl,simple,9,"// Done, simple octal number like 01234; // If we have some other non-octal digit that *is* a decimal digit, see if; // this is part of a floating point number like 094.123 or 09e1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:216,Safety,avoid,avoids,216,"// Fast path: Compute a conservative bound on the maximum number of; // bits per digit in this radix. If we can't possibly overflow a; // uint64 based on that bound then do the simple conversion to; // integer. This avoids the expensive overflow checking below, and; // handles the common cases that matter (small decimal integers and; // hex/octal values which don't overflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:177,Usability,simpl,simple,177,"// Fast path: Compute a conservative bound on the maximum number of; // bits per digit in this radix. If we can't possibly overflow a; // uint64 based on that bound then do the simple conversion to; // integer. This avoids the expensive overflow checking below, and; // handles the common cases that matter (small decimal integers and; // hex/octal values which don't overflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:54,Usability,Simpl,Simply,54,// This will truncate the value to Val's input width. Simply check; // for overflow by comparing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:285,Usability,simpl,simplicity,285,"// Number of bits needed for decimal literal is; // ceil(NumDigits * log2(10)) Integral part; // + Scale Fractional part; // + ceil(Exponent * log2(10)) Exponent; // --------------------------------------------------; // ceil((NumDigits + Exponent) * log2(10)) + Scale; //; // But for simplicity in handling integers, we can round up log2(10) to 4,; // making:; // 4 * (NumDigits + Exponent) + Scale; //; // Number of digits needed for hexadecimal literal is; // 4 * NumDigits Integral part; // + Scale Fractional part; // + Exponent Exponent; // --------------------------------------------------; // (4 * NumDigits) + Scale + Exponent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:584,Usability,simpl,simple-escape-sequence,584,"/// \verbatim; /// user-defined-character-literal: [C++11 lex.ext]; /// character-literal ud-suffix; /// ud-suffix:; /// identifier; /// character-literal: [C++11 lex.ccon]; /// ' c-char-sequence '; /// u' c-char-sequence '; /// U' c-char-sequence '; /// L' c-char-sequence '; /// u8' c-char-sequence ' [C++1z lex.ccon]; /// c-char-sequence:; /// c-char; /// c-char-sequence c-char; /// c-char:; /// any member of the source character set except the single-quote ',; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// escape-sequence:; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name: [C++11 lex.charset]; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:672,Usability,simpl,simple-escape-sequence,672,"/// \verbatim; /// user-defined-character-literal: [C++11 lex.ext]; /// character-literal ud-suffix; /// ud-suffix:; /// identifier; /// character-literal: [C++11 lex.ccon]; /// ' c-char-sequence '; /// u' c-char-sequence '; /// U' c-char-sequence '; /// L' c-char-sequence '; /// u8' c-char-sequence ' [C++1z lex.ccon]; /// c-char-sequence:; /// c-char; /// c-char-sequence c-char; /// c-char:; /// any member of the source character set except the single-quote ',; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// escape-sequence:; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name: [C++11 lex.charset]; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:74,Usability,simpl,simply,74,"// If we see bad encoding for unprefixed character literals, warn and; // simply copy the byte values, for compatibility with gcc and; // older versions of clang.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:46,Modifiability,extend,extend,46,"// If this is a single narrow character, sign extend it (e.g. '\xFF' is ""-1""); // if 'char' is signed for this target (C99 6.4.4.4p10). Note that multiple; // character constants are not sign extended in the this implementation:; // '\xFF\xFF' = 65536 and '\x0\xFF' = 255, which matches GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:192,Modifiability,extend,extended,192,"// If this is a single narrow character, sign extend it (e.g. '\xFF' is ""-1""); // if 'char' is signed for this target (C99 6.4.4.4p10). Note that multiple; // character constants are not sign extended in the this implementation:; // '\xFF\xFF' = 65536 and '\x0\xFF' = 255, which matches GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:1106,Usability,simpl,simple-escape-sequence,1106,"/// \verbatim; /// string-literal: [C++0x lex.string]; /// encoding-prefix "" [s-char-sequence] ""; /// encoding-prefix R raw-string; /// encoding-prefix:; /// u8; /// u; /// U; /// L; /// s-char-sequence:; /// s-char; /// s-char-sequence s-char; /// s-char:; /// any member of the source character set except the double-quote "",; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// raw-string:; /// "" d-char-sequence ( r-char-sequence ) d-char-sequence ""; /// r-char-sequence:; /// r-char; /// r-char-sequence r-char; /// r-char:; /// any member of the source character set, except a right parenthesis ); /// followed by the initial d-char-sequence (which may be empty); /// followed by a double quote "".; /// d-char-sequence:; /// d-char; /// d-char-sequence d-char; /// d-char:; /// any member of the basic source character set except:; /// space, the left parenthesis (, the right parenthesis ),; /// the backslash \, and the control characters representing horizontal; /// tab, vertical tab, form feed, and newline.; /// escape-sequence: [C++0x lex.ccon]; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name:; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:1194,Usability,simpl,simple-escape-sequence,1194,"/// \verbatim; /// string-literal: [C++0x lex.string]; /// encoding-prefix "" [s-char-sequence] ""; /// encoding-prefix R raw-string; /// encoding-prefix:; /// u8; /// u; /// U; /// L; /// s-char-sequence:; /// s-char; /// s-char-sequence s-char; /// s-char:; /// any member of the source character set except the double-quote "",; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// raw-string:; /// "" d-char-sequence ( r-char-sequence ) d-char-sequence ""; /// r-char-sequence:; /// r-char; /// r-char-sequence r-char; /// r-char:; /// any member of the source character set, except a right parenthesis ); /// followed by the initial d-char-sequence (which may be empty); /// followed by a double quote "".; /// d-char-sequence:; /// d-char; /// d-char-sequence d-char; /// d-char:; /// any member of the basic source character set except:; /// space, the left parenthesis (, the right parenthesis ),; /// the backslash \, and the control characters representing horizontal; /// tab, vertical tab, form feed, and newline.; /// escape-sequence: [C++0x lex.ccon]; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name:; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:90,Availability,error,error,90,"// The literal token may have come from an invalid source location (e.g. due; // to a PCH error), in which case the token length will be 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:58,Performance,load,loading,58,// The file may have come from PCH and then changed after loading the; // PCH; Fail gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:58,Performance,load,loading,58,// The file may have come from PCH and then changed after loading the; // PCH; Fail gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:143,Performance,Perform,Performs,143,"/// This function copies from Fragment, which is a sequence of bytes; /// within Tok's contents (which begin at TokBegin) into ResultPtr.; /// Performs widening for multi-byte characters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:71,Usability,simpl,simply,71,"// If we see bad encoding for unprefixed string literals, warn and; // simply copy the byte values, for compatibility with gcc and older; // versions of clang.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:25,Usability,simpl,simply,25,// Step over non-escapes simply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:56,Safety,avoid,avoid,56,"/// Determine whether a suffix is a valid ud-suffix. We avoid treating reserved; /// suffixes as ud-suffixes, because the diagnostic experience is better if we; /// treat it as an invalid suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:418,Integrability,interface,interface,418,"//===--- MacroArgs.cpp - Formal argument info for Macros ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MacroArgs interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate memory for a MacroArgs object with the lexer tokens at the end,; // and construct the MacroArgs object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:9,Usability,clear,clear,9,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:37,Usability,clear,clear,37,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:56,Usability,Clear,Clearing,56,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:3,Deployability,Release,Release,3,// Release the memory for the object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:191,Deployability,install,installed,191,"// Include the EOF.; // Otherwise, we have to pre-expand this argument, populating Result. To do; // this, we set up a fake TokenLexer to lex from the unexpanded argument; // list. With this installed, we lex expanded tokens until we hit the EOF; // token at the end of the unexp list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:90,Safety,avoid,avoid,90,"// Otherwise, just append the token. Do some gymnastics to get the token; // in place and avoid copies where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:120,Availability,error,error,120,"// Count the number of consecutive \ characters. If even, then they are; // just escaped backslashes, otherwise it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:12,Availability,error,errors,12,// Diagnose errors for things like: #define F(X) #X / F(\),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp:418,Integrability,interface,interface,418,"//===- MacroInfo.cpp - Information about #defined identifiers -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MacroInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:66,Usability,simpl,simple,66,// The lack of 'framework' keyword in a module declaration it's a simple; // mistake we can diagnose when the header exists within the proper; // framework style path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:5,Security,Sanitiz,Sanitize,5,"/// ""Sanitize"" a filename so that it can be used as an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:99,Security,sanitiz,sanitized,99,"// If we don't already have something with the form of an identifier,; // create a buffer with the sanitized name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:6,Availability,error,errors,6,// No errors for indirect modules. This may be a bit of a problem for modules; // with no source files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:10,Availability,avail,available,10,// Prefer available modules.; // FIXME: Considering whether the module is available rather than merely; // importable is non-hermetic and can result in surprising behavior for; // prebuilt modules. Consider only checking for importability here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:74,Availability,avail,available,74,// Prefer available modules.; // FIXME: Considering whether the module is available rather than merely; // importable is non-hermetic and can result in surprising behavior for; // prebuilt modules. Consider only checking for importability here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:32,Availability,avail,available,32,"// When no requesting module is available, the caller is looking if a; // header is part a module by only looking into the module map. This is; // done by warn_uncovered_module_header checks; don't consider textual; // headers part of it in this mode, otherwise we get misleading warnings; // that a umbrella header is not including a textual header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:170,Usability,simpl,simplify,170,// Note: Here the `IsExplicit` parameter refers to the semantics in clang; // modules. All the non-explicit submodules in clang modules will be exported; // too. Here we simplify the implementation by using the concept.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:7,Integrability,interface,interface,7,// The interface for this implementation must exist and be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:59,Performance,load,loaded,59,// The interface for this implementation must exist and be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:34,Performance,Load,Load,34,"// We haven't looked here before. Load a module map, if there is; // one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:85,Performance,load,load,85,"// FIXME: If there's no umbrella header, we could probably scan the; // framework to load *everything*. But, it's not clear that this is a good; // idea.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:118,Usability,clear,clear,118,"// FIXME: If there's no umbrella header, we could probably scan the; // framework to load *everything*. But, it's not clear that this is a good; // idea.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:76,Integrability,wrap,wrap,76,"// If there is a builtin counterpart to this file, add it now so it can; // wrap the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,Integrability,inject,inject,97,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,Security,inject,inject,97,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:75,Performance,Perform,Perform,75,// We don't have stat information or can't defer looking this file up.; // Perform the lookup now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:21,Testability,log,logically,21,// This operation is logically const; we're just changing how we represent; // the header information for this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,Availability,redundant,redundant,249,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,Safety,redund,redundant,249,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:15,Availability,error,error,15,/// Whether an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:215,Testability,assert,assert,215,"/// Whether a module uses the 'requires excluded' hack to mark its; /// contents as 'textual'.; ///; /// On older Darwin SDK versions, 'requires excluded' is used to mark the; /// contents of the Darwin.C.excluded (assert.h) and Tcl.Private modules as; /// non-modular headers. For backwards compatibility, we continue to; /// support this idiom for just these modules, and map the headers to; /// 'textual' to match the original intent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:98,Testability,log,logic,98,"/// Private modules are canonicalized as Foo_Private. Clang provides extra; /// module map search logic to find the appropriate private module when PCH; /// is used with implicit module maps. Warn when private modules are written; /// in other ways (FooPrivate and Foo.Private), providing notes and fixits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:120,Availability,error,error,120,"/// Parse a module-id.; ///; /// module-id:; /// identifier; /// identifier '.' module-id; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:112,Testability,log,logic,112,"// namespace; /// Private modules are canonicalized as Foo_Private. Clang provides extra; /// module map search logic to find the appropriate private module when PCH; /// is used with implicit module maps. Warn when private modules are written; /// in other ways (FooPrivate and Foo.Private), providing notes and fixits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:114,Performance,load,loaded,114,"// We might see a (re)definition of a module that we already have a; // definition for in four cases:; // - If we loaded one definition from an AST file and we've just found a; // corresponding definition in a module map file, or",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:62,Performance,load,loaded,62,// - If we're building a (preprocessed) module and we've just loaded the; // module map file from which it was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:85,Availability,error,error,85,"// Private modules named as FooPrivate, Foo.Private or similar are likely a; // user error; provide warnings, notes and fixits to direct users to use; // Foo_Private instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:550,Testability,assert,assert,550,"/// Whether to add the requirement \p Feature to the module \p M.; ///; /// This preserves backwards compatibility for two hacks in the Darwin system; /// module map files:; ///; /// 1. The use of 'requires excluded' to make headers non-modular, which; /// should really be mapped to 'textual' now that we have this feature. We; /// drop the 'excluded' requirement, and set \p IsRequiresExcludedHack to; /// true. Later, this bit will be used to map all the headers inside this; /// module to 'textual'.; ///; /// This affects Darwin.C.excluded (for assert.h) and Tcl.Private.; ///; /// 2. Removes a bogus cplusplus requirement from IOKit.avc. This requirement; /// was never correct and causes issues now that we check it, so drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:45,Integrability,depend,depend,45,// Sort header paths so that the pcm doesn't depend on iteration order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:12,Deployability,configurat,configuration,12,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:12,Modifiability,config,configuration,12,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:112,Modifiability,config,config-macro-list,112,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:141,Modifiability,config,config-macro-list,141,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:35,Deployability,configurat,configuration,35,// Only top-level modules can have configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:35,Modifiability,config,configuration,35,// Only top-level modules can have configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:13,Integrability,message,message,13,// Parse the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:234,Availability,error,error,234,"/// Parse optional attributes.; ///; /// attributes:; /// attribute attributes; /// attribute; ///; /// attribute:; /// [ identifier ]; ///; /// \param Attrs Will be filled in with the parsed attributes.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:431,Integrability,interface,interface,431,"//===--- PPCaching.cpp - Handle caching lexed tokens ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements pieces of the Preprocessor interface that manage the; // caching of lexed tokens.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:7,Testability,assert,assert,7,// The assert in EnterCachingLexMode should prevent this from happening.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:3,Performance,Cache,Cache,3,// Cache the lexed token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:7,Performance,cache,cached,7,// All cached tokens were consumed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:83,Performance,cache,cache,83,"// The caching layer sits on top of all the other lexers, so it's incorrect; // to cache tokens while inside a nested lex action. The cached tokens would; // be retained after returning to the enclosing lex action and, at best,; // would appear at the wrong position in the token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:134,Performance,cache,cached,134,"// The caching layer sits on top of all the other lexers, so it's incorrect; // to cache tokens while inside a nested lex action. The cached tokens would; // be retained after returning to the enclosing lex action and, at best,; // would appear at the wrong position in the token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:29,Performance,cache,cached,29,// Start from the end of the cached tokens list and look for the token; // that is the beginning of the annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:15,Performance,cache,cached,15,// Replace the cached tokens with the single annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:24,Performance,cache,cached,24,// There's currently no cached token...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:147,Security,secur,security-features-in-the-crt,147,// list from:; // * https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html; // * https://docs.microsoft.com/en-us/cpp/c-runtime-library/security-features-in-the-crt?view=msvc-160; // * man 7 feature_test_macros; // The list must be sorted for correct binary search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:31,Testability,test,test,31,// C++ defines various feature-test macros starting with __cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:274,Modifiability,portab,portability,274,"// Return true if we want to issue a diagnostic by default if we; // encounter this name in a #include with the wrong case. For now,; // this includes the standard C and C++ headers, Posix headers,; // and Boost headers. Improper case for these #includes is a; // potential portability issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:72,Availability,recover,recovery,72,// Allow #defining |and| and friends for Microsoft compatibility or; // recovery when legacy C headers are included in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:72,Safety,recover,recovery,72,// Allow #defining |and| and friends for Microsoft compatibility or; // recovery when legacy C headers are included in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error if defining ""defined"": C99 6.10.8/4, C++ [cpp.predefined]p4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Deployability,configurat,configuration,58,"// We do not want to warn on some patterns widely used in configuration; // scripts. This requires analyzing next tokens, so do not issue warnings; // now, only inform caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Modifiability,config,configuration,58,"// We do not want to warn on some patterns widely used in configuration; // scripts. This requires analyzing next tokens, so do not issue warnings; // now, only inform caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:12,Security,validat,validate,12,"/// Lex and validate a macro name, which occurs after a; /// \#define or \#undef.; ///; /// This sets the token kind to eod and discards the rest of the macro line if; /// the macro name is invalid.; ///; /// \param MacroNameTok Token that is expected to be a macro name.; /// \param isDefineUndef Context in which macro is used.; /// \param ShadowFlag Points to a flag that is set if macro shadows a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:34,Integrability,depend,depending,34,"// In SkippingRangeStateTy we are depending on SkipExcludedConditionalBlock(); // not getting called recursively by storing the RecordedSkippedRanges; // DenseMap lookup pointer (field SkipRangePtr). SkippingRangeStateTy expects; // that RecordedSkippedRanges won't get modified and SkipRangePtr won't be; // invalidated. If this changes and there is a need to call; // SkipExcludedConditionalBlock() recursively, SkippingRangeStateTy should; // change to do a second lookup in endLexPass function instead of reusing the; // lookup pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:20,Performance,cache,caches,20,/// Keeps track and caches skipped ranges and also retrieves a prior skipped; /// range if the same block is re-visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:48,Availability,error,error,48,"// If this is the end of the buffer, we have an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:17,Availability,error,errors,17,"// We don't emit errors for unterminated conditionals here,; // Lexer::LexEndOfFile can do that properly.; // Just return and let the caller lex after this #include.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:88,Safety,safe,safe,88,"// If the first letter isn't i or e, it isn't intesting to us. We know that; // this is safe in the face of spelling differences, because there is no way; // to spell an i/e in a strange way that is another letter. Skipping this; // allows us to avoid looking up the identifier info for #define/#undef and; // other common directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:246,Safety,avoid,avoid,246,"// If the first letter isn't i or e, it isn't intesting to us. We know that; // this is safe in the face of spelling differences, because there is no way; // to spell an i/e in a strange way that is another letter. Skipping this; // allows us to avoid looking up the identifier info for #define/#undef and; // other common directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:25,Testability,assert,asserts,25,// Silence warning in no-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #else with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,error,error,53,"// If the macro name token is tok::eod, there was an error that was; // already reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:85,Availability,error,error,85,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Safety,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:109,Usability,resume,resume,109,// The last skipped range isn't actually skipped yet if it's truncated; // by the end of the preamble; we'll resume parsing after the preamble.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:132,Performance,load,load,132,"// We want to find all possible modules that might contain this header, so; // search all enclosing directories for module maps and load them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:179,Usability,clear,clear,179,"// It's in a private header; we can't #include it.; // FIXME: If there's a public header in some module that re-exports it,; // then we could suggest including that, but it's not clear that's the; // expected way to make this entity visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:17,Security,access,accessible,17,"// If this is an accessible, non-textual header of M's top-level module; // that transitively includes the given location and makes the; // corresponding module visible, this is the thing to #include.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:88,Security,expose,expose,88,"// If the header is includable and has an include guard, assume the; // intended way to expose its contents is by #include, not by importing a; // module that transitively includes it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Performance,optimiz,optimization,58,"// We are about to read a token. For the multiple-include optimization FA to; // work, we have to remember if we had read any tokens *before* this; // pp-directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:70,Performance,optimiz,optimization,70,"// Ignore the null directive with regards to the multiple-include; // optimization, i.e. allow the null directive to appear outside of the; // include guard and still enable the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:195,Performance,optimiz,optimization,195,"// Ignore the null directive with regards to the multiple-include; // optimization, i.e. allow the null directive to appear outside of the; // include guard and still enable the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:16,Availability,Error,Error,16,// C99 6.10.5 - Error Directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Testability,assert,assert,43,//isExtension = true; // FIXME: implement #assert,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:122,Performance,perform,perform,122,"// If the second token is a hashhash token, then we need to translate it to; // unknown so the token lexer doesn't try to perform token pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:28,Security,hash,hashhash,28,"// If the second token is a hashhash token, then we need to translate it to; // unknown so the token lexer doesn't try to perform token pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:25,Usability,simpl,simple,25,"// Verify that we have a simple digit-sequence, and compute the value. This; // is always a simple digit string computed in decimal, so we do this manually; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:92,Usability,simpl,simple,92,"// Verify that we have a simple digit-sequence, and compute the value. This; // is always a simple digit string computed in decimal, so we do this manually; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Security,Validat,Validate,3,// Validate the number and convert it to an unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Security,validat,validate,13,"// Parse and validate the string, converting it into a unique ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:290,Modifiability,rewrite,rewrites,290,"// Take the file kind of the file containing the #line directive. #line; // directives are often used for generated sources from the same codebase, so; // the new file should generally be classified the same way as the current; // file. This is visible in GCC's pre-processed output, which rewrites #line; // to GNU line markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:36,Security,validat,validate,36,/// ReadLineMarkerFlags - Parse and validate any flags at the end of a GNU line; /// marker directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Security,Validat,Validate,3,// Validate the number and convert it to an unsigned. GNU does not have a; // line # limit other than it fit in 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Security,validat,validate,13,"// Parse and validate the string, converting it into a unique ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:37,Deployability,install,installed,37,"// If the preprocessor has callbacks installed, notify them of the #line; // change. This is used so that the line marker comes out in -E mode for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Availability,error,error,58,/// HandleUserDiagnosticDirective - Handle a #warning or #error directive.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Availability,error,error,43,"// If the macro is not defined, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Availability,error,error,43,"// If the macro is not defined, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:151,Safety,avoid,avoid,151,"// If these non-separator path components differ by more than just case,; // then we may be looking at symlinked paths. Bail on this diagnostic to; // avoid noisy false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:162,Integrability,rout,routine,162,"/// HandleIncludeDirective - The ""\#include"" tokens have just been read, read; /// the file to be included from the lexer, then include it! This is a common; /// routine with functionality shared between \#include, \#include_next and; /// \#import. LookupFrom is set when this is a \#include_next directive, it; /// specifies the file to start searching from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:117,Security,Hash,HashLoc,117,"/// Handle either a #include-like directive or an import declaration that names; /// a header file.; ///; /// \param HashLoc The location of the '#' token for an include, or; /// SourceLocation() for an import declaration.; /// \param IncludeTok The include / include_next / import token.; /// \param FilenameTok The header-name token.; /// \param EndLoc The location at which any imported macros become visible.; /// \param LookupFrom For #include_next, the starting directory for the; /// directory lookup.; /// \param LookupFromFile For #include_next, the starting file for the directory; /// lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:51,Security,audit,audit,51,// Complain about attempts to #include files in an audit pragma.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:812,Safety,avoid,avoids,812,"// Should we enter the source file? Set to Skip if either the source file is; // known to have no effect beyond its effect on module visibility -- that is,; // if it's got an include guard that is already defined, set to Import if it; // is a modular header we've already built and should import.; // For C++20 Modules; // [cpp.include]/7 If the header identified by the header-name denotes an; // importable header, it is implementation-defined whether the #include; // preprocessing directive is instead replaced by an import directive.; // For this implementation, the translation is permitted when we are parsing; // the Global Module Fragment, and not otherwise (the cases where it would be; // valid to replace an include with an import are highly constrained once in; // named module purview; this choice avoids considerable complexity in; // determining valid cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,Usability,usab,usable,11,// Maybe a usable Header Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,Usability,usab,usable,11,// Maybe a usable clang header module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:140,Performance,load,loadModule,140,"// If this include corresponds to a module but that module is; // unavailable, diagnose the situation and bail out.; // FIXME: Remove this; loadModule does the same check (but produces; // slightly worse diagnostics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:99,Performance,load,loadModule,99,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:124,Safety,avoid,avoid,124,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:22,Security,access,access,22,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Performance,Load,Load,3,// Load the module to import its macros. We'll make the declarations; // visible when the parser gets here.; // FIXME: Pass SuggestedModule in here rather than converting it to a path; // and making the module loader convert it back again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:210,Performance,load,loader,210,// Load the module to import its macros. We'll make the declarations; // visible when the parser gets here.; // FIXME: Pass SuggestedModule in here rather than converting it to a path; // and making the module loader convert it back again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:8,Deployability,configurat,configuration,8,"// On a configuration mismatch, enter the header textually. We still know; // that it's part of the corresponding module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:8,Modifiability,config,configuration,8,"// On a configuration mismatch, enter the header textually. We still know; // that it's part of the corresponding module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Availability,error,error,13,// We hit an error processing the import. Bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:310,Availability,error,errors,310,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:318,Safety,avoid,avoid,318,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:272,Integrability,depend,depending,272,"// -Wnonportable-include-path is designed to diagnose includes using; // case even on systems with a case-insensitive file system.; // On Windows, RealPathName always starts with an upper-case drive; // letter for absolute paths, but Name might start with either; // case depending on if `cd c:\foo` or `cd C:\foo` was used in the shell.; // (""foo"" will always have on-disk case, no matter which case was; // used in the cd command). To not emit this warning solely for; // the drive letter, whose case is dependent on if `cd` is used; // with upper- or lower-case drive letters, always consider the; // given drive letter case as correct for the purpose of this warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:506,Integrability,depend,dependent,506,"// -Wnonportable-include-path is designed to diagnose includes using; // case even on systems with a case-insensitive file system.; // On Windows, RealPathName always starts with an upper-case drive; // letter for absolute paths, but Name might start with either; // case depending on if `cd c:\foo` or `cd C:\foo` was used in the shell.; // (""foo"" will always have on-disk case, no matter which case was; // used in the cd command). To not emit this warning solely for; // the drive letter, whose case is dependent on if `cd` is used; // with upper- or lower-case drive letters, always consider the; // given drive letter case as correct for the purpose of this warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:185,Availability,error,error,185,"// The Microsoft #import directive takes a type library and generates header; // files from it, and includes those. This is beyond the scope of what clang; // does, so we ignore it and error out. However, #import can optionally have; // trailing attributes that span multiple lines. We're going to eat those; // so we can continue processing from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:82,Availability,error,error,82,"// This directive should only occur in the predefines buffer. If not, emit an; // error and reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:420,Availability,error,error,420,"//===----------------------------------------------------------------------===//; // Preprocessor Macro Directive Handling.; //===----------------------------------------------------------------------===//; /// ReadMacroParameterList - The ( starting a parameter list of a macro; /// definition has just been read. Lex the rest of the parameters and the; /// closing ), updating MI with what we learn. Return true if an error occurs; /// parsing the param list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:395,Usability,learn,learn,395,"//===----------------------------------------------------------------------===//; // Preprocessor Macro Directive Handling.; //===----------------------------------------------------------------------===//; /// ReadMacroParameterList - The ( starting a parameter list of a macro; /// definition has just been read. Lex the rest of the parameters and the; /// closing ), updating MI with what we learn. Return true if an error occurs; /// parsing the param list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:161,Performance,perform,performs,161,"// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the; // entire line) of the macro's tokens and adds them to MacroInfo, and while; // doing so performs certain validity checks including (but not limited to):; // - # (stringization) is followed by a macro parameter; //; // Returns a nullptr if an invalid sequence of tokens is encountered or returns; // a pointer to a MacroInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:51,Availability,error,errors,51,// Ensure we consume the rest of the macro body if errors occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:46,Usability,Clear,Clear,46,// This is a normal token with leading space. Clear the leading space; // marker on the first token to get proper expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:47,Availability,down,down,47,// Read the first token after the arg list for down below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:31,Usability,simpl,simple,31,"// Object-like macros are very simple, just read their body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:44,Availability,error,error,44,"// If we're already within a VAOPT, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:76,Testability,assert,assert,76,"// If we're in MS compatibility mode and the macro being defined is the; // assert macro, implicitly add a macro definition for static_assert to work; // around their broken assert.h header file in C. Only do so if there isn't; // already a static_assert macro defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:174,Testability,assert,assert,174,"// If we're in MS compatibility mode and the macro being defined is the; // assert macro, implicitly add a macro definition for static_assert to work; // around their broken assert.h header file in C. Only do so if there isn't; // already a static_assert macro defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:85,Availability,error,error,85,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Safety,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:129,Performance,optimiz,optimization,129,"// If this condition is equivalent to #ifndef X, and if this is the first; // directive seen, handle it for the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #else with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:649,Testability,test,testing,649,"//===--- PPExpressions.cpp - Preprocessor Expression Evaluation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor::EvaluateDirectiveExpression method,; // which parses and evaluates integer constant expressions for #if directives.; //; //===----------------------------------------------------------------------===//; //; // FIXME: implement testing for #assert's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:662,Testability,assert,assert,662,"//===--- PPExpressions.cpp - Preprocessor Expression Evaluation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor::EvaluateDirectiveExpression method,; // which parses and evaluates integer constant expressions for #if directives.; //; //===----------------------------------------------------------------------===//; //; // FIXME: implement testing for #assert's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:144,Usability,simpl,simple,144,"/// DefinedTracker - This struct is used while parsing expressions to keep track; /// of whether !defined(X) has been seen.; ///; /// With this simple scheme, we handle the basic forms:; /// !defined(X) and !defined X; /// but we also trivially handle (silly) stuff like:; /// !!!defined(X) and +!defined(X) and !+!+!defined(X) and !(defined(X)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:52,Availability,error,error,52,"// If we don't have a pp-identifier now, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:522,Security,threat,threat,522,"// [cpp.cond]p4:; // Prior to evaluation, macro invocations in the list of preprocessing; // tokens that will become the controlling constant expression are replaced; // (except for those macro names modified by the 'defined' unary operator),; // just as in normal text. If the token 'defined' is generated as a result; // of this replacement process or use of the 'defined' unary operator does; // not match one of the two specified forms prior to macro replacement, the; // behavior is undefined.; // This isn't an idle threat, consider this program:; // #define FOO; // #define BAR defined(FOO); // #if BAR; // ...; // #else; // ...; // #endif; // clang and gcc will pick the #if branch while Visual Studio will take the; // #else branch. Emit a warning about this undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:145,Availability,error,error,145,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:418,Safety,avoid,avoid,418,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:136,Usability,simpl,simple,136,"// If this identifier isn't 'defined' or one of the special; // preprocessor keywords and it wasn't macro expanded, it turns; // into a simple 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Safety,Detect,Detect,3,"// Detect overflow based on whether the value is signed. If signed; // and if the value is too large, emit a warning ""integer constant is so; // large that it is unsigned"" e.g. on 12345678901234567890 where intmax_t; // is 64-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:18,Testability,assert,assert,18,// FIXME: Handle #assert,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:284,Safety,avoid,avoid,284,"/// EvaluateDirectiveSubExpr - Evaluate the subexpression whose first token is; /// PeekTok, and whose precedence is PeekPrec. This returns the result in LHS.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation, such as division by zero warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:41,Availability,error,error,41,"// If this token isn't valid, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:41,Availability,error,error,41,"// If this token isn't valid, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:458,Testability,log,logical-OR-expression,458,"// Decide whether to include the next binop in this subexpression. For; // example, when parsing x+y*z and looking at '*', we want to recursively; // handle y*z as a single subexpression. We do this because the precedence; // of * is higher than that of +. The only strange case we have to handle; // here is for the ?: operator, where the precedence is actually lower than; // the LHS of the '?'. The grammar rule is:; //; // conditional-expression ::=; // logical-OR-expression ? expression : conditional-expression; // where 'expression' is actually comma-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Testability,Log,Logical,3,// Logical || does not do UACs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Testability,Log,Logical,3,// Logical && does not do UACs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:9,Availability,error,error,9,"// Parse error, skip the rest of the macro line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:81,Availability,error,error,81,// We cannot trust the source range from the value because there was a; // parse error. Track the range manually -- the end of the directive is the; // end of the condition range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:9,Availability,error,error,9,"// Parse error, skip the rest of the macro line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:431,Integrability,interface,interface,431,"//===--- PPLexerChange.cpp - Handle changing lexers in the preprocessor ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements pieces of the Preprocessor interface that manage the; // current lexer stack.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:584,Energy Efficiency,allocate,allocated,584,"/// EnterTokenStream - Add a ""macro"" context to the top of the include stack,; /// which will cause the lexer to start returning the specified tokens.; ///; /// If DisableMacroExpansion is true, tokens lexed from the token stream will; /// not be subject to further macro expansion. Otherwise, these tokens will; /// be re-macro-expanded when/if expansion is enabled.; ///; /// If OwnsTokens is false, this method assumes that the specified stream of; /// tokens has a permanent owner somewhere, so they do not need to be copied.; /// If it is true, it assumes the array of tokens is allocated with new[] and; /// must be freed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:48,Performance,cache,cached,48,"// We're entering tokens into the middle of our cached token stream. We; // can't represent that, so just insert the tokens into the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:36,Performance,cache,cached,36,// New tokens are at the end of the cached token sequnece; insert the; // token stream underneath the caching lexer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:37,Security,access,access,37,// Find the relative path that would access this header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Availability,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Safety,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:169,Performance,load,loaded,169,"// If we're at the end of generating a preamble, we should record the; // unterminated \#pragma clang assume_nonnull so we can restore it later; // when the preamble is loaded into the main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Availability,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Safety,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:13,Performance,cache,cache,13,// Delete or cache the now-dead macro expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:13,Performance,cache,cache,13,// Delete or cache the now-dead macro expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:82,Integrability,interface,interface,82,"// Otherwise, we only need module macros if we're actually compiling a module; // interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:17,Security,expose,exposed,17,// This macro is exposed to the rest of this compilation as a; // ModuleMacro; we don't need to track its MacroDirective any more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Safety,Avoid,Avoid,3,// Avoid assertion in appendMacroDirective.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:9,Testability,assert,assertion,9,// Avoid assertion in appendMacroDirective.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:149,Performance,load,loaded,149,"// shouldIgnoreMacro() in ASTWriter also stops at macros from the; // predefines buffer in module builds. However, in module builds, modules; // are loaded completely before predefines are processed, so StoredMD; // will be nullptr for them when they're loaded. StoredMD should only be; // non-nullptr for builtins read from a pch file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:254,Performance,load,loaded,254,"// shouldIgnoreMacro() in ASTWriter also stops at macros from the; // predefines buffer in module builds. However, in module builds, modules; // are loaded completely before predefines are processed, so StoredMD; // will be nullptr for them when they're loaded. StoredMD should only be; // non-nullptr for builtins read from a pch file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:60,Deployability,update,update,60,"// If the information about this identifier is out of date, update it from; // the external source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,Safety,safe,safe,53,"// If this is an object-like macro invocation, it is safe to trivially expand; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,Safety,safe,safe,53,"// If this is a function-like macro invocation, it's safe to trivially expand; // as long as the identifier is not a macro argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:17,Testability,test,tests,17,// Do some quick tests for rejection cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:174,Performance,optimiz,optimization,174,"// If this is a macro expansion in the ""#if !defined(x)"" line for the file,; // then the macro could expand to different things in other contexts, we need; // to disable the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:137,Modifiability,portab,portable,137,"// Remember that we are now parsing the arguments to a macro invocation.; // Preprocessor directives used inside macro arguments are not portable, and; // this enables the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:19,Availability,error,error,19,"// If there was an error parsing the arguments, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:197,Performance,queue,queue,197,"// We can have macro expansion inside a conditional directive while; // reading the function macro arguments. To ensure, in that case, that; // MacroExpands callbacks still happen in source order, queue this; // callback to have it happen after the function macro callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Deployability,Update,Update,3,// Update the tokens location to include both its expansion and physical; // locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:58,Usability,simpl,simple,58,"// Once it is known that the brackets are matched, only a simple count of the; // braces is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:163,Deployability,update,updated,163,"// Set to true when a macro separator token is found inside a braced list.; // If true, the fixed argument spans multiple old arguments and ParenHints; // will be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:242,Availability,error,error,242,"/// ReadFunctionLikeMacroArgs - After reading ""MACRO"" and knowing that the next; /// token is the '(' of the macro, this method is invoked to read all of the; /// actual arguments specified for the macro invocation. This returns null on; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:45,Safety,avoid,avoids,45,"// Read arguments as unexpanded tokens. This avoids issues, e.g., where; // an argument value in a macro could expand to ',' or '(' or ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:145,Safety,avoid,avoid,145,// ArgTokens - Build up a list of tokens that make up each argument. Each; // argument is separated by an EOF token. Use a SmallVector so we can avoid; // heap allocations in the common case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:45,Safety,avoid,avoids,45,"// Read arguments as unexpanded tokens. This avoids issues, e.g., where; // an argument value in a macro could expand to ',' or '(' or ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:135,Testability,test,test,135,"// In Microsoft-compatibility mode, single commas from nested macro; // expansions should not be considered as argument separators. We test; // for this with the IgnoredComma token flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:82,Availability,error,error,82,"// If this is not a variadic macro, and too many args were specified, emit; // an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:82,Availability,error,error,82,"// If this is not a variadic macro, and too many args were specified, emit; // an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Availability,Recover,Recover,3,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Safety,Recover,Recover,3,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:23,Availability,error,error,23,"// Otherwise, emit the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:155,Performance,cache,cache,155,/// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:230,Performance,cache,cache,230,/// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:86,Deployability,update,update,86,// Go through all the TokenLexers whose 'Tokens' pointer points in the; // buffer and update the pointers to the (potential) new buffer array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:11,Performance,cache,cached,11,// Pop the cached macro expanded tokens from the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:44,Availability,error,error,44,"// If the use of an extension results in an error diagnostic, extensions are; // effectively unavailable, so just return false here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:14,Modifiability,inherit,inherit,14,"// Because we inherit the feature list from HasFeature, this string switch; // must be less restrictive than HasFeature's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:46,Integrability,message,message,46,// Save '(' location for possible missing ')' message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:197,Availability,down,down,197,"// Passing this to LookupFile forces header search to check whether the found; // file belongs to a module. Skipping that check could incorrectly mark; // modular header as textual, causing issues down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:63,Availability,error,errors,63,// Provide a dummy '0' value on output stream to elide further errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:77,Usability,Simpl,Simply,77,// Don't provide even a dummy value if the eod or eof marker is; // reached. Simply provide a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:108,Availability,avail,available,108,/// Helper function to return the IdentifierInfo structure of a Token; /// or generate a diagnostic if none available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:232,Availability,down,down,232,"// One wrinkle here is that GCC expands __LINE__ to location of the *end* of; // a macro expansion. This doesn't matter for object-like macros, but; // can matter for a function-like macro that expands to contain __LINE__.; // Skip down through expansion points until we find a file loc for the; // end of the expansion history.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:25,Usability,simpl,simple,25,// __LINE__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:34,Usability,simpl,simple,34,// __INCLUDE_LEVEL__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:36,Usability,simpl,simple,36,// __FLT_EVAL_METHOD__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:28,Usability,simpl,simple,28,// __COUNTER__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:102,Safety,detect,detecting,102,// Likewise for some builtin preprocessor macros.; // FIXME: This is inconsistent; we usually suggest detecting; // builtin macros via #ifdef. Don't add more cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:72,Availability,avail,available,72,"// It is possible to receive a scope token. Read the ""::"", if it is; // available, and the subsequent identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:61,Availability,recover,recover,61,// We're expecting '__identifier' '(' identifier ')'. Try to recover; // if the parens are missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:61,Safety,recover,recover,61,// We're expecting '__identifier' '(' identifier ')'. Try to recover; // if the parens are missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,Availability,recover,recover,59,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,Safety,recover,recover,59,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:434,Integrability,interface,interfaces,434,"//===- Pragma.cpp - Pragma registration and handling ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PragmaHandler/PragmaTable interfaces and implements; // pragma related methods of the Preprocessor class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:464,Availability,failure,failure,464,"//===----------------------------------------------------------------------===//; // PragmaNamespace Implementation.; //===----------------------------------------------------------------------===//; /// FindHandler - Check to see if there is already a handler for the; /// specified name. If not, return the handler for the null identifier if it; /// exists, otherwise return null. If IgnoreNull is true (the default) then; /// the null handler isn't returned on failure to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Deployability,Release,Release,3,// Release ownership back to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:22,Availability,down,down,22,"// Otherwise, pass it down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:882,Energy Efficiency,consumption,consumption,882,"// C11 6.10.3.4/3:; // all pragma unary operator expressions within [a completely; // macro-replaced preprocessing token sequence] are [...] processed [after; // rescanning is complete]; //; // This means that we execute _Pragma operators in two cases:; //; // 1) on token sequences that would otherwise be produced as the output of; // phase 4 of preprocessing, and; // 2) on token sequences formed as the macro-replaced token sequence of a; // macro argument; //; // Case #2 appears to be a wording bug: only _Pragmas that would survive to; // the end of phase 4 should actually be executed. Discussion on the WG14; // mailing list suggests that a _Pragma operator is notionally checked early,; // but only pragmas that survive to the end of phase 4 should be executed.; //; // In Case #2, we check the syntax now, but then put the tokens back into the; // token stream for later consumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:112,Energy Efficiency,consumption,consumption,112,"// During macro pre-expansion, check the syntax now but put the tokens back; // into the token stream for later consumption. Same as Handle_Pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:141,Availability,error,errors,141,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:134,Safety,avoid,avoids,134,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:49,Integrability,depend,dependency,49,"/// HandlePragmaDependency - Handle \#pragma GCC dependency ""foo"" blah.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:56,Availability,error,error,56,"// If the next token wasn't a header-name, diagnose the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Integrability,depend,depends,42,"// If this file is older than the file it depends on, emit a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:32,Integrability,message,message,32,// Lex tokens at the end of the message and include them in the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:64,Integrability,message,message,64,// Lex tokens at the end of the message and include them in the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Performance,Load,Load,3,// Load the extracted text as a preprocessed module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:51,Availability,down,down,51,"// If this is specified to be in a namespace, step down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:95,Availability,error,error,95,"// If there is already a pragma handler with the name of this namespace,; // we either have an error (directive with the same name as a namespace) or; // we already have the namespace to insert into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:198,Availability,error,error,198,"/// RemovePragmaHandler - Remove the specific pragma handler from the; /// preprocessor. If \arg Namespace is non-null, then it should be the; /// namespace that \arg Handler was added to. It is an error to remove; /// a handler that has not been registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:51,Availability,down,down,51,"// If this is specified to be in a namespace, step down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:61,Usability,usab,usable,61,"/// PragmaPoisonHandler - ""\#pragma poison x"" marks x as not usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:172,Safety,avoid,avoid,172,"/// ""\#pragma warning(...)"". MSVC's diagnostics do not map cleanly to clang's; /// diagnostics, so we don't really implement this pragma. We parse it and; /// ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:90,Availability,error,error,90,"// Parse things like:; // warning(push, 1); // warning(pop); // warning(disable : 1 2 3 ; error : 4 5 6 ; suppress : 7 8 9)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:168,Safety,avoid,avoid,168,"/// ""\#pragma execution_character_set(...)"". MSVC supports this pragma only; /// for ""UTF-8"". We parse it and ignore it if UTF-8 is provided and warn; /// otherwise to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:446,Availability,error,error,446,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:65,Integrability,message,message,65,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:128,Integrability,message,message,128,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:204,Integrability,message,message,204,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:494,Integrability,message,message,494,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:31,Integrability,message,message,31,// We have a MSVC style pragma message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:30,Integrability,message,message,30,"// We have a GCC style pragma message, and we just read the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:14,Integrability,message,message,14,// Output the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Performance,load,load,39,"// If we have a non-empty module path, load the named module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:78,Performance,load,loaded,78,// Find the module we're entering. We require that a module map for it; // be loaded or implicitly loadable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:99,Performance,load,loadable,99,// Find the module we're entering. We require that a module map for it; // be loaded or implicitly loadable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:23,Availability,avail,available,23,"// If the module isn't available, it doesn't make sense to enter it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:37,Performance,load,load,37,/// Handle the clang \#pragma module load extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Performance,Load,Load,3,"// Load the module, don't make it visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:36,Security,audit,audit,36,// The start location of the active audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Security,audit,audit,42,// Complain about attempts to re-enter an audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Security,audit,audit,39,// Complain about attempts to leave an audit that doesn't exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:36,Security,audit,audit,36,// The start location of the active audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Security,audit,audit,42,// Complain about attempts to re-enter an audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Security,audit,audit,39,// Complain about attempts to leave an audit that doesn't exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:202,Safety,avoid,avoid,202,"/// ""\#pragma managed""; /// ""\#pragma managed(...)""; /// ""\#pragma unmanaged""; /// MSVC ignores this pragma when not compiling using /clr, which clang doesn't; /// support. We parse it and ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:69,Integrability,message,message,69,/// This handles parsing pragmas that take a macro name and optional message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:115,Integrability,Message,Message,115,"/// ""\#pragma clang deprecated(...)""; ///; /// The syntax is; /// \code; /// #pragma clang deprecate(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:132,Integrability,Message,Message,132,"/// ""\#pragma clang restrict_expansion(...)""; ///; /// The syntax is; /// \code; /// #pragma clang restrict_expansion(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:43,Deployability,Install,Install,43,// namespace; /// RegisterBuiltinPragmas - Install the standard preprocessor pragmas:; /// \#pragma GCC poison/system_header/dependency and \#pragma once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:125,Integrability,depend,dependency,125,// namespace; /// RegisterBuiltinPragmas - Install the standard preprocessor pragmas:; /// \#pragma GCC poison/system_header/dependency and \#pragma once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Safety,Safe,Safe,3,// Safe Buffers pragmas,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:20,Modifiability,plugin,plugins,20,// Pragmas added by plugins,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:142,Safety,avoid,avoid,142,/// Returns true if the preprocessed entity that \arg PPEI iterator; /// points to is coming from the file \arg FID.; ///; /// Can be used to avoid implicit deserializations of preallocated; /// preprocessed entities if we only care about entities of a specific file; /// and not from files \#included in the range given at; /// \see getPreprocessedEntitiesInRange.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:24,Performance,load,loaded,24,// Check if range spans loaded entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:16,Performance,load,loaded,16,// Range spands loaded and local entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:17,Performance,load,loaded,17,/// Retrieve the loaded preprocessed entity at the given index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:13,Performance,load,load,13,// Failed to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:421,Integrability,interface,interface,421,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:722,Integrability,depend,dependency-file,722,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:797,Integrability,Message,Messages,797,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:45,Performance,load,loaded,45,"// As the language options may have not been loaded yet (when; // deserializing an ASTUnit), adding keywords to the identifier table is; // deferred to Preprocessor::Initialize().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:12,Performance,cache,cached,12,"// Free any cached macro expanders.; // This populates MacroArgCache, so all TokenLexers need to be destroyed; // before the code below that frees up the MacroArgCache list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:12,Performance,cache,cached,12,// Free any cached MacroArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Performance,Load,Load,3,// Load the actual file's contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:186,Safety,avoid,avoided,186,/// getSpelling - This method is used to get the spelling of a token into a; /// SmallVector. Note that the returned StringRef may not point to the; /// supplied buffer if a copy can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:41,Testability,test,testing,41,// NOTE: this has to be checked *before* testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Performance,load,loaded,20,"// If MainFileID is loaded it means we loaded an AST file, no need to enter; // a main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:39,Performance,load,loaded,39,"// If MainFileID is loaded it means we loaded an AST file, no need to enter; // a main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:109,Availability,error,error,109,"// Lookup and save the FileID for the through header. If it isn't found; // in the search path, it's a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:327,Availability,error,error,327,"/// Skip tokens until after the #include of the through header or; /// until after a #pragma hdrstop is seen. Tokens in the predefines file; /// and the main file may be skipped. If the end of the predefines file; /// is reached, skipping continues into the main file. If the end of the; /// main file is reached, it's a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:310,Deployability,install,install,310,"//===----------------------------------------------------------------------===//; // Lexer Event Handling.; //===----------------------------------------------------------------------===//; /// LookUpIdentifierInfo - Given a tok::raw_identifier token, look up the; /// identifier information for the token and install it into the token,; /// updating the token kind accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Deployability,Update,Update,3,"// Update the token info (identifier info and appropriate token kind).; // FIXME: the raw_identifier may contain leading whitespace which is removed; // from the cleaned identifier token. The SourceLocation should be updated to; // refer to the non-whitespace character. For instance, the text ""\\\nB"" (a; // line continuation before 'B') is parsed as a single tok::raw_identifier and; // is cleaned to tok::identifier ""B"". After cleaning the token's length is; // still 3 and the SourceLocation refers to the location of the backslash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:217,Deployability,update,updated,217,"// Update the token info (identifier info and appropriate token kind).; // FIXME: the raw_identifier may contain leading whitespace which is removed; // from the cleaned identifier token. The SourceLocation should be updated to; // refer to the non-whitespace character. For instance, the text ""\\\nB"" (a; // line continuation before 'B') is parsed as a single tok::raw_identifier and; // is cleaned to tok::identifier ""B"". After cleaning the token's length is; // still 3 and the SourceLocation refers to the location of the backslash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:60,Deployability,update,update,60,"// If the information about this identifier is out of date, update it from; // the external source.; // We have to treat __VA_ARGS__ in a special way, since it gets; // serialized with isPoisoned = true, but our preprocessor may have; // unpoisoned it if we're defining a C99 macro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:99,Availability,error,error,99,"// If this identifier was poisoned, and if it was not produced from a macro; // expansion, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,Safety,avoid,avoid,59,"// If this is an extension token, diagnose its use.; // We avoid diagnosing tokens that originate from macro definitions.; // FIXME: This warning is disabled in cases where it shouldn't be,; // like ""#define TY typeof"", ""TY(1) x"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,Safety,avoid,avoids,59,// We loop here until a lex function returns a token; this avoids recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:33,Safety,avoid,avoid,33,// Set IdenfitierInfo to null to avoid confusing code that handles both; // identifiers and completion tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Deployability,Update,Update,3,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:158,Deployability,Update,Update,158,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:252,Deployability,update,updates,252,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:317,Integrability,depend,depends,317,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,Integrability,inject,injected,17,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,Security,inject,injected,17,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:238,Availability,failure,failure,238,"/// Lex a header-name token (including one formed from header-name-tokens if; /// \p AllowConcatenation is \c true).; ///; /// \param FilenameTok Filled in with the next token. On success, this will; /// be either a header_name token. On failure, it will be whatever other; /// token was found instead.; /// \param AllowMacroExpansion If \c true, allow the header name to be formed; /// by macro expansion (concatenating tokens as necessary if the first; /// token is a '<').; /// \return \c true if we reached EOD or EOF while looking for a > token in; /// a concatenated header name and diagnosed it. \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:139,Usability,clear,clear,139,// Consume tokens until we find a '>'.; // FIXME: A header-name could be formed starting or ending with an; // alternative token. It's not clear whether that's ill-formed in all; // cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:14,Availability,error,error,14,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Availability,recover,recovery,20,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Safety,recover,recovery,20,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a holding buffer for a sequence of tokens and introduce it into; // the token stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:102,Performance,cache,cache,102,// Enter the header-name token into the token stream; a Lex action cannot; // both return a token and cache tokens (doing so would corrupt the token; // cache if the call to Lex comes from CachingLex / PeekAhead).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:153,Performance,cache,cache,153,// Enter the header-name token into the token stream; a Lex action cannot; // both return a token and cache tokens (doing so would corrupt the token; // cache if the call to Lex comes from CachingLex / PeekAhead).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:2,Security,Hash,HashLoc,2,/*HashLoc*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:192,Performance,perform,performing,192,"// Under the standard C++ Modules, the dot is just part of the module name,; // and not a real hierarchy separator. Flatten such module names now.; //; // FIXME: Is this the right level to be performing this transformation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:22,Performance,load,load,22,// We don't/shouldn't load the standard c++20 modules when preprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:28,Safety,Safe,SafeBufferOptOutMap,28,// Try to find a region in `SafeBufferOptOutMap` where `Loc` is in:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:6,Testability,test,test,6,// To test if the start location of the found region precedes `Loc`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp:436,Integrability,interface,interfaces,436,"//===- PreprocessorLexer.cpp - C Language Family Lexer --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PreprocessorLexer and Token interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:422,Integrability,interface,interface,422,"//===--- ScratchBuffer.cpp - Scratch space for forming tokens -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScratchBuffer interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:108,Modifiability,extend,extended,108,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:29,Performance,cache,cache,29,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:3,Usability,Clear,Clear,3,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:107,Energy Efficiency,allocate,allocate,107,"// Only pay attention to the requested length if it is larger than our default; // page size. If it is, we allocate an entire chunk for it. This is to; // support gigantic tokens, which almost certainly won't happen. :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:54,Safety,Avoid,Avoidance,54,"//===--- TokenConcatenation.cpp - Token Concatenation Avoidance -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenConcatenation class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:36,Safety,Avoid,AvoidConcat,36,// These tokens have custom code in AvoidConcat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:71,Safety,avoid,avoiding,71,"/// GetFirstChar - Get the first character of the token \arg Tok,; /// avoiding calls to getSpelling where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:3,Safety,Avoid,Avoid,3,"// Avoid spelling identifiers, the most common form of token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:4,Safety,Avoid,AvoidConcat,4,"/// AvoidConcat - If printing PrevTok immediately followed by Tok would cause; /// the two individual tokens to be lexed as a single token, return true; /// (which causes a space to be printed between them). This allows the output; /// of -E mode to be lexed to the same token stream as lexing the input; /// directly would.; ///; /// This code must conservatively return true if it doesn't want to be 100%; /// accurate. This will cause the output to include extra space characters,; /// but the resulting output won't have incorrect concatenations going on.; /// Examples include "".."", which we print with a space between, because we; /// don't want to track enough to tell ""x.."" from ""..."".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:81,Safety,avoid,avoid,81,// Language keyword or named operator.; // Look up information on when we should avoid concatenation with prevtok.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:37,Safety,avoid,avoid,37,"// If the next token is '=' or '==', avoid concatenation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:112,Safety,avoid,avoid,112,"// Otherwise, this is a narrow character or string. If the *identifier*; // is a literal 'L', 'u8', 'u' or 'U', avoid pasting L ""foo"" -> L""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:419,Integrability,interface,interface,419,"//===- TokenLexer.cpp - Lex from a token stream ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenLexer interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:205,Safety,avoid,avoid,205,// Reserve a source location entry chunk for the length of the macro; // definition. Tokens that get lexed directly from the definition will; // have their locations pointing inside this chunk. This is to avoid; // creating separate source location entries for each token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:14,Availability,avail,available,14,// Is a comma available to be removed?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:103,Performance,perform,perform,103,// FIXME: Should we keep track within VCtx that we did or didnot; // encounter pasting - and only then perform this loop.; // Perform token pasting (concatenation) prior to stringization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:126,Performance,Perform,Perform,126,// FIXME: Should we keep track within VCtx that we did or didnot; // encounter pasting - and only then perform this loop.; // Perform token pasting (concatenation) prior to stringization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:148,Deployability,install,install,148,"// Loop through 'Tokens', expanding them into ResultToks. Keep; // track of whether we change anything. If not, no need to keep them. If so,; // we install the newly expanded sequence as the new 'Tokens' list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:191,Performance,perform,perform,191,"// If we are about to process a token that is either an argument to; // __VA_OPT__ or its closing rparen, then:; // 1) If the token is the closing rparen that exits us out of __VA_OPT__,; // perform any necessary stringification or placemarker processing,; // and/or skip to the next token.; // 2) else if macro was invoked without variadic arguments skip this; // token.; // 3) else (macro was invoked with variadic arguments) process the token; // normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:156,Security,hash,hashhash,156,"// Current token is the closing r_paren which marks the end of the; // __VA_OPT__ invocation, so handle any place-marker pasting (if; // empty) by removing hashhash either before (if exists) or after. And; // also stringify the entire contents if VAOPT was preceded by a hash,; // but do so only after any token concatenation that needs to occur; // within the contents of VAOPT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:271,Security,hash,hash,271,"// Current token is the closing r_paren which marks the end of the; // __VA_OPT__ invocation, so handle any place-marker pasting (if; // empty) by removing hashhash either before (if exists) or after. And; // also stringify the entire contents if VAOPT was preceded by a hash,; // but do so only after any token concatenation that needs to occur; // within the contents of VAOPT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:145,Security,hash,hashhash,145,"// Treat VAOPT as a placemarker token. Eat either the '##' before the; // RHS/VAOPT (if one exists, suggesting that the LHS (if any) to that; // hashhash was not a placemarker) or the '##'; // after VAOPT, but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:22,Security,hash,hashhash,22,// Skip the following hashhash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:156,Safety,avoid,avoid,156,"// If there's a ## before the __VA_OPT__, we might have discovered; // that the __VA_OPT__ begins with a placeholder. We delay action on; // that to now to avoid messing up our stashed count of tokens before; // __VA_OPT__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:19,Usability,simpl,simple,19,// Else handle the simple argument case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:70,Safety,avoid,avoids,70,// Only preexpand the argument if it could possibly need it. This; // avoids some work in common cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:208,Testability,test,test,208,"// In Microsoft-compatibility mode, we follow MSVC's preprocessing; // behavior by not considering single commas from nested macro; // expansions as argument separators. Set a flag on the token so we can; // test for this later when the macro expansion is processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:78,Safety,avoid,avoid,78,"// If the '##' came from expanding an argument, turn it into 'unknown'; // to avoid pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:137,Availability,error,error,137,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:121,Safety,avoid,avoid,121,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:64,Usability,learn,learned,64,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:78,Safety,avoid,avoid,78,"// If the '##' came from expanding an argument, turn it into 'unknown'; // to avoid pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:195,Energy Efficiency,reduce,reduces,195,// Do not remove the paste operator if it is the one before __VA_OPT__; // (and we are still processing tokens within VA_OPT). We handle the case; // of removing the paste operator if __VA_OPT__ reduces to the notional; // placemarker above when we encounter the closing paren of VA_OPT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:24,Deployability,install,install,24,"// If anything changed, install this as the new Tokens list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:46,Performance,cache,cache,46,// The tokens will be added to Preprocessor's cache and will be removed; // when this TokenLexer finishes lexing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:20,Performance,cache,cache,20,"// The preprocessor cache of macro expanded tokens owns these tokens,not us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:57,Modifiability,inherit,inherit,57,"// If this is the first token of the expanded result, we inherit spacing; // properties later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:61,Availability,error,error,61,"// If this identifier was poisoned and from a paste, emit an error. This; // won't be handled by Preprocessor::HandleIdentifier because this is coming; // from a macro expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,Availability,recover,recovery,54,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,Safety,recover,recovery,54,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for the result token. This is guaranteed to be enough for; // the two tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:58,Safety,Avoid,Avoid,58,// Common paste case: identifier+identifier = identifier. Avoid creating; // a lexer and other overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:74,Availability,error,error,74,"// If pasting the two tokens didn't form a full new token, this is an; // error. This occurs with ""x ## +"" and other stuff. Return with LHSTok; // unmodified and with RHS as the next token to lex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:76,Availability,error,error,76,// Test for the Microsoft extension of /##/ turning into // here on the; // error path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:3,Testability,Test,Test,3,// Test for the Microsoft extension of /##/ turning into // here on the; // error path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:19,Availability,error,error,19,// Do not emit the error when preprocessing assembler code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Availability,down,downgrade,42,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:73,Availability,error,error,73,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:115,Availability,error,error,115,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:6,Availability,error,error,6,// An error has occurred so exit loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:29,Safety,avoid,avoid,29,// Turn ## into 'unknown' to avoid # ## # from looking like a paste; // operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:392,Deployability,update,updated,392,"/// Finds the tokens that are consecutive (from the same FileID); /// creates a single SLocEntry, and assigns SourceLocations to each token that; /// point to that SLocEntry. e.g for; /// assert(foo == bar);; /// There will be a single SLocEntry for the ""foo == bar"" chunk and locations; /// for the 'foo', '==', 'bar' tokens will point inside that chunk.; ///; /// \arg begin_tokens will be updated to a position past all the found; /// consecutive tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:188,Testability,assert,assert,188,"/// Finds the tokens that are consecutive (from the same FileID); /// creates a single SLocEntry, and assigns SourceLocations to each token that; /// point to that SLocEntry. e.g for; /// assert(foo == bar);; /// There will be a single SLocEntry for the ""foo == bar"" chunk and locations; /// for the 'foo', '==', 'bar' tokens will point inside that chunk.; ///; /// \arg begin_tokens will be updated to a position past all the found; /// consecutive tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:105,Safety,avoid,avoid,105,// The maximum distance between two consecutive tokens in a partition.; // This is an important trick to avoid using too much SourceLocation address; // space!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:135,Performance,optimiz,optimized,135,"// Partition the tokens by their FileID.; // This is a hot function, and calling getFileID can be expensive, the; // implementation is optimized by reducing the number of getFileID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Availability,recover,recovery,42,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:276,Energy Efficiency,allocate,allocates,276,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Safety,recover,recovery,42,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:223,Safety,safe,safe,223,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:28,Deployability,update,updates,28,/// Creates SLocEntries and updates the locations of macro argument; /// tokens to their new expanded locations.; ///; /// \param ArgIdSpellLoc the location of the macro argument id inside the macro; /// definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,Availability,recover,recovers,147,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,Safety,recover,recovers,147,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:80,Energy Efficiency,allocate,allocate,80,// Do the equivalent of PP.getSpelling(Tok) except for the parts that would; // allocate memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:106,Integrability,interface,interface,106,"// namespace; //===----------------------------------------------------------------------===//; // Public interface to the file; //===----------------------------------------------------------------------===//; /// ParseAST - Parse the entire file specified, notifying the ASTConsumer as; /// the file is parsed. This inserts the parsed decls into the translation unit; /// held by Ctx.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:139,Availability,error,error,139,"// If we got a null return and something *was* parsed, ignore it. This; // is due to a top-level semicolon, an action override, or a parse error; // skipping something.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:154,Availability,reliab,reliable,154,"// Finalize the template instantiation observer chain.; // FIXME: This (and init.) should be done in the Sema class, but because; // Sema does not have a reliable ""Finalize"" function (it has a; // destructor, but it is not guaranteed to be called (""-disable-free"")).; // So, do the initialization above and do the finalization here:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:140,Availability,error,errors,140,"// If we gave up at the completion point, the initializer list was; // likely truncated, so don't eat more tokens. We'll hit some extra; // errors, but they should be ignored in code completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:25,Availability,error,error,25,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:62,Availability,recover,recover,62,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:62,Safety,recover,recover,62,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of default argument' token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the original token position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:3,Availability,Error,Error,3,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:9,Availability,recover,recovery,9,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:9,Safety,recover,recovery,9,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,Availability,recover,recover,22,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,Safety,recover,recover,22,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class which calls ParseLexedAttribute, after setting up the; /// scope appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:20,Availability,error,error,20,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:51,Performance,cache,cached,51,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:88,Performance,cache,cached,88,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:264,Availability,error,error,264,/// Consume tokens and store them in the passed token container until; /// we've passed the try keyword and constructor initializers and have consumed; /// the opening brace of the function body. The opening brace will be consumed; /// if and only if there was no error.; ///; /// \return True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:297,Availability,error,error,297,/// Consume tokens and store them in the passed token container until; /// we've passed the try keyword and constructor initializers and have consumed; /// the opening brace of the function body. The opening brace will be consumed; /// if and only if there was no error.; ///; /// \return True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:12,Availability,reliab,reliably,12,"// We can't reliably skip over a mem-initializer-id, because it could be; // a template-id involving not-yet-declared names. Given:; //; // S ( ) : a < b < c > ( e ); //; // 'e' might be an initializer or part of a template argument, depending; // on whether 'b' is a template.; // Track whether we might be inside a template argument. We can give; // significantly better diagnostics if we know that we're not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:234,Integrability,depend,depending,234,"// We can't reliably skip over a mem-initializer-id, because it could be; // a template-id involving not-yet-declared names. Given:; //; // S ( ) : a < b < c > ( e ); //; // 'e' might be an initializer or part of a template argument, depending; // on whether 'b' is a template.; // Track whether we might be inside a template argument. We can give; // significantly better diagnostics if we know that we're not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:270,Usability,clear,clear,270,"// We may be inside a template argument list. Grab up to the start of the; // next parenthesized initializer or braced-init-list. This *might* be the; // initializer, or it might be a subexpression in the template argument; // list.; // FIXME: Count angle brackets, and clear MightBeTemplateArgument; // if all angles are closed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,Availability,recover,recover,119,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,Safety,recover,recover,119,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:192,Safety,avoid,avoid,192,"// Number of possible unclosed <s we've seen so far. These might be templates,; // and might not, but if there were none of them (or we know for sure that; // we're within a template), we can avoid a tentative parse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:33,Performance,perform,perform,33,"// If we might be in a template, perform a tentative parse to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:57,Performance,perform,performed,57,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:157,Performance,perform,perform,157,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:33,Usability,undo,undo,33,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:390,Availability,down,downstream,390,"// Okay, we found a ']' or '}' or ')', which we think should be balanced.; // Since the user wasn't looking for this token (if they were, it would; // already be handled), this isn't balanced. If there is a LHS token at a; // higher level, we will assume that this matches the unbalanced token; // and return it. Otherwise, this is a spurious RHS token, which we; // consume and pass on to downstream code to diagnose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:443,Integrability,interface,interfaces,443,"//===--- ParseDecl.cpp - Declaration Parsing --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Declaration portions of the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:1386,Availability,error,error,1386,"/// ParseGNUAttributes - Parse a non-empty attributes list.; ///; /// [GNU] attributes:; /// attribute; /// attributes attribute; ///; /// [GNU] attribute:; /// '__attribute__' '(' '(' attribute-list ')' ')'; ///; /// [GNU] attribute-list:; /// attrib; /// attribute_list ',' attrib; ///; /// [GNU] attrib:; /// empty; /// attrib-name; /// attrib-name '(' identifier ')'; /// attrib-name '(' identifier ',' nonempty-expr-list ')'; /// attrib-name '(' argument-expression-list [C99 6.5.2] ')'; ///; /// [GNU] attrib-name:; /// identifier; /// typespec; /// typequal; /// storageclass; ///; /// Whether an attribute takes an 'identifier' is determined by the; /// attrib-name. GCC's behavior here is not worth imitating:; ///; /// * In C mode, if the attribute argument list starts with an identifier; /// followed by a ',' or an ')', and the identifier doesn't resolve to; /// a type, it is parsed as an identifier. If the attribute actually; /// wanted an expression, it's out of luck (but it turns out that no; /// attributes work that way, because C constant expressions are very; /// limited).; /// * In C++ mode, if the attribute argument list starts with an identifier,; /// and the attribute *wants* an identifier, it is parsed as an identifier.; /// At block scope, any additional tokens between the identifier and the; /// ',' or ')' are ignored, otherwise they produce a parse error.; ///; /// We follow the C++ model, but don't allow junk after the identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:11,Modifiability,parameteriz,parameterized,11,"// Handle ""parameterized"" attributes",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:105,Availability,error,error,105,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:222,Performance,perform,performed,222,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,Availability,error,errors,35,// Ensure typos get diagnosed when errors were encountered while parsing the; // expression list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,Availability,avail,available,27,// General case. Parse all available expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:29,Modifiability,parameteriz,parameterized,29,"/// Parse the arguments to a parameterized GNU attribute or; /// a C++11 attribute in ""gnu"" namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:16,Security,Access,AccessorNames,16,// indices into AccessorNames,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:13,Security,access,accessor,13,// Parse the accessor specifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:37,Security,access,accessor,37,// Stop if this doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:40,Security,access,accessor,40,// Handle the mistake of forgetting the accessor kind by skipping; // this accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Security,access,accessor,75,// Handle the mistake of forgetting the accessor kind by skipping; // this accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:41,Security,access,accessor,41,"// Otherwise, complain about the unknown accessor kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,Security,access,accessor,54,// Try to keep parsing unless it doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Security,access,accessors,21,// Just drop invalid accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:31,Security,access,accessor,31,"// Complain about the repeated accessor, ignore it, and keep parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Security,access,accessors,19,// Keep processing accessors until we run out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Modifiability,extend,extended-decl-modifier-seq,43,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:87,Modifiability,extend,extended-decl-modifier-seq,87,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:120,Modifiability,extend,extended-decl-modifier,120,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:153,Modifiability,extend,extended-decl-modifier,153,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:176,Modifiability,extend,extended-decl-modifier-seq,176,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:52,Usability,simpl,simple-integer,52,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:72,Usability,simpl,simple-integer,72,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:91,Usability,simpl,simple-integer,91,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Usability,simpl,simple-integer,111,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:130,Usability,simpl,simple-integer,130,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:150,Usability,simpl,simple-integer,150,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:169,Usability,simpl,simple-integer,169,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:188,Usability,simpl,simple-integer,188,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:208,Usability,simpl,simple-integer,208,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:227,Usability,simpl,simple-integer,227,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:246,Usability,simpl,simple-integer,246,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:31,Availability,avail,availability,31,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:66,Availability,avail,availability-attribute,66,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Availability,avail,availability,96,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:182,Integrability,message,message,182,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:544,Integrability,message,message,544,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:559,Integrability,message,message,559,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Availability,avail,availability,10,/*Source='availability attribute'*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Availability,avail,availability,21,// The 'unavailable' availability cannot be combined with any other; // availability changes. Make sure that hasn't happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:72,Availability,avail,availability,72,// The 'unavailable' availability cannot be combined with any other; // availability changes. Make sure that hasn't happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:17,Availability,avail,availability,17,// Clear out the availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Usability,Clear,Clear,3,// Clear out the availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:227,Modifiability,variab,variable,227,"// Usually, `__attribute__((attrib)) class Foo {} var` means that attribute; // applies to var, not the type Foo.; // As an exception to the rule, __declspec(align(...)) before the; // class-key affects the type instead of the variable.; // Also, Microsoft-style [attributes] seem to affect the type instead of the; // variable.; // This function moves attributes that should apply to the type off DS to Attrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:319,Modifiability,variab,variable,319,"// Usually, `__attribute__((attrib)) class Foo {} var` means that attribute; // applies to var, not the type Foo.; // As an exception to the rule, __declspec(align(...)) before the; // class-key affects the type instead of the variable.; // Also, Microsoft-style [attributes] seem to affect the type instead of the; // variable.; // This function moves attributes that should apply to the type off DS to Attrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:319,Usability,simpl,simple-declaration,319,"/// ParseDeclaration - Parse a full 'declaration', which consists of; /// declaration-specifiers, some number of declarators, and a semicolon.; /// 'Context' should be a DeclaratorContext value. This returns the; /// location of the semicolon in DeclEnd.; ///; /// declaration: [C99 6.7]; /// block-declaration ->; /// simple-declaration; /// others [FIXME]; /// [C++] template-declaration; /// [C++] namespace-definition; /// [C++] using-directive; /// [C++] using-declaration; /// [C++11/C11] static_assert-declaration; /// others... [FIXME]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,Integrability,rout,routine,8,"// This routine returns a DeclGroup, if the thing we parsed only contains a; // single decl, convert it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:306,Energy Efficiency,allocate,allocate-directive,306,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:4,Usability,simpl,simple-declaration,4,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:691,Usability,simpl,simple-declaration,691,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:137,Integrability,interface,interface,137,"// 'inline namespace' at the start of a line is almost certainly; // a good place to pick back up parsing, except in an Objective-C; // @interface context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:130,Integrability,interface,interface,130,"// 'namespace' at the start of a line is almost certainly a good; // place to pick back up parsing, except in an Objective-C; // @interface context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:93,Availability,error,error,93,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:220,Availability,recover,recover,220,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:220,Safety,recover,recover,220,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:182,Modifiability,extend,extended,182,// Look at the next token to make sure that this isn't a function; // declaration. We have to check this because __attribute__ might be the; // start of a function definition in GCC-extended K&R C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:211,Modifiability,variab,variable,211,"// C++0x [stmt.iter]p1: Check if we have a for-range-declarator. If so, we; // must parse and analyze the for-range-initializer before the declaration is; // analyzed.; //; // Handle the Objective-C for-in loop variable similarly, although we; // don't need to parse the container in advance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';') or an; // error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,Availability,recover,recover,196,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,Safety,recover,recover,196,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Availability,error,error,111,"/// Parse an optional simple-asm-expr and attributes, and attach them to a; /// declarator. Returns true on an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:22,Usability,simpl,simple-asm-expr,22,"/// Parse an optional simple-asm-expr and attributes, and attach them to a; /// declarator. Returns true on an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,Usability,simpl,simple-asm-expr,8,"// If a simple-asm-expr is present, parse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:342,Usability,simpl,simple-asm-expr,342,"/// Parse 'declaration' after parsing 'declaration-specifiers; /// declarator'. This method parses the remainder of the declaration; /// (including any attributes or initializer, among other things) and; /// finalizes the declaration.; ///; /// init-declarator: [C99 6.7]; /// declarator; /// declarator '=' initializer; /// [GNU] declarator simple-asm-expr[opt] attributes[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] '=' initializer; /// [C++] declarator initializer[opt]; ///; /// [C++] initializer:; /// [C++] '=' initializer-clause; /// [C++] '(' expression-list ')'; /// [C++0x] '=' 'default' [TODO]; /// [C++0x] '=' 'delete'; /// [C++0x] braced-init-list; ///; /// According to the standard grammar, =default and =delete are function; /// definitions, but that definitely doesn't fit with the parser here.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:401,Usability,simpl,simple-asm-expr,401,"/// Parse 'declaration' after parsing 'declaration-specifiers; /// declarator'. This method parses the remainder of the declaration; /// (including any attributes or initializer, among other things) and; /// finalizes the declaration.; ///; /// init-declarator: [C99 6.7]; /// declarator; /// declarator '=' initializer; /// [GNU] declarator simple-asm-expr[opt] attributes[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] '=' initializer; /// [C++] declarator initializer[opt]; ///; /// [C++] initializer:; /// [C++] '=' initializer-clause; /// [C++] '(' expression-list ')'; /// [C++0x] '=' 'default' [TODO]; /// [C++0x] '=' 'delete'; /// [C++0x] braced-init-list; ///; /// According to the standard grammar, =default and =delete are function; /// definitions, but that definitely doesn't fit with the parser here.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:37,Modifiability,variab,variable,37,// FIXME: This check should be for a variable template instantiation only.; // Check that this is a valid instantiation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:110,Availability,error,errors,110,"// We are trying to stop parser from looking for ';' in this for; // statement, therefore preventing spurious errors to be issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Availability,error,error,95,"// ParseExpressionList can sometimes succeed even when ThisDecl is not; // VarDecl. This is an error and it is reported in a call to; // Actions.ActOnInitializerError(). However, we call; // ProduceConstructorSignatureHelp only on VarDecls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Security,Validat,Validate,3,// Validate declspec for type-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:361,Usability,simpl,simple-declaration,361,"/// isValidAfterIdentifierInDeclaratorAfterDeclSpec - Return true if the; /// specified token is valid after the identifier in a declarator which; /// immediately follows the declspec. For example, these things are valid:; ///; /// int x [ 4]; // direct-declarator; /// int x ( int y); // direct-declarator; /// int(int x ) // direct-declarator; /// int x ; // simple-declaration; /// int x = 17; // init-declarator-list; /// int x , y; // init-declarator-list; /// int x __asm__ (""foo""); // init-declarator-list; /// int x : 4; // struct-declarator; /// int x { 5}; // C++'0x unified initializers; ///; /// This is not, because 'x' does not immediately follow the declspec (though; /// ')' happens to be valid anyway).; /// int (x); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,Availability,recover,recovers,408,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,Safety,recover,recovers,408,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:587,Availability,error,error,587,"// If we see an identifier that is not a type name, we normally would; // parse it as the identifier being declared. However, when a typename; // is typo'd or the definition is not included, this will incorrectly; // parse the typename as the identifier name and fall over misparsing; // later parts of the diagnostic.; //; // As such, we try to do some look-ahead in cases where this would; // otherwise be an ""implicit-int"" case to see if this is invalid. For; // example: ""static foo_t x = 4;"" In this case, if we parsed foo_t as; // an identifier with implicit int, we'd get a parse error because the; // next token is obviously invalid for a type. Parse these as a case; // with an invalid type specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,error,error,73,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:113,Availability,recover,recovery,113,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:113,Safety,recover,recovery,113,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:82,Safety,avoid,avoid,82,"// If this token is valid for implicit int, e.g. ""static x = 4"", then; // we just avoid eating the identifier, so it will be parsed as the; // identifier in the declarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Availability,recover,recover,103,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:140,Integrability,depend,dependent,140,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Safety,recover,recover,103,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:74,Availability,error,error,74,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Availability,recover,recover,95,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Safety,recover,recover,95,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:129,Availability,error,error,129,"// static x(4); // 'x' is not a type; // x(int n); // 'x' is not a type; // x (*p)[]; // 'x' is a type; //; // Since we're in an error case, we can afford to perform a tentative; // parse to determine which case we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:158,Performance,perform,perform,158,"// static x(4); // 'x' is not a type; // x(int n); // 'x' is not a type; // x (*p)[]; // 'x' is a type; //; // Since we're in an error case, we can afford to perform a tentative; // parse to determine which case we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Modifiability,variab,variable,21,// This looks like a variable or function declaration. The type is; // probably missing. We're done parsing decl-specifiers.; // But only if we are not in a function prototype scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Availability,recover,recover,96,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Safety,recover,recover,96,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:67,Availability,error,error,67,"// Otherwise, the action had no suggestion for us. Mark this as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:90,Availability,error,error,90,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Integrability,inject,inject,15,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Integrability,message,messages,96,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,avoid,avoid,75,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Security,inject,inject,15,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:273,Availability,error,error,273,"/// Determine whether we're looking at something that might be a declarator; /// in a simple-declaration. If it can't possibly be a declarator, maybe; /// diagnose a missing semicolon after a prior tag definition in the decl; /// specifier.; ///; /// \return \c true if an error occurred and this can't be any kind of; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:86,Usability,simpl,simple-declaration,86,"/// Determine whether we're looking at something that might be a declarator; /// in a simple-declaration. If it can't possibly be a declarator, maybe; /// diagnose a missing semicolon after a prior tag definition in the decl; /// specifier.; ///; /// \return \c true if an error occurred and this can't be any kind of; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:123,Usability,simpl,simple-declaration,123,"// If we have a type expressed as a template-id, this cannot be a; // declarator-id (such a type cannot be redeclared in a simple-declaration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:61,Usability,simpl,simple-declaration,61,"// These tokens cannot come after the declarator-id in a; // simple-declaration, and are likely to come after a type-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:159,Availability,error,error,159,"// If the declarator-id has a scope specifier, it must redeclare a; // previously-declared entity. If that's a type (and this is not a; // typedef), that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Availability,recover,recover,10,"// Try to recover from the typo, by dropping the tag definition and parsing; // the problematic tokens as a type.; //; // FIXME: Split the DeclSpec into pieces for the standalone; // declaration and pieces for the following declaration, instead; // of assuming that all the other pieces attach to new declaration,; // and call ParsedFreeStandingDeclSpec as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Safety,recover,recover,10,"// Try to recover from the typo, by dropping the tag definition and parsing; // the problematic tokens as a type.; //; // FIXME: Split the DeclSpec into pieces for the standalone; // declaration and pieces for the following declaration, instead; // of assuming that all the other pieces attach to new declaration,; // and call ParsedFreeStandingDeclSpec as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:97,Availability,error,error,97,"// If we are in a operator context, convert it back into a type specifier; // context for better error handling later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Security,access,access,18,// Turn off usual access checking for template specializations and; // instantiations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Availability,recover,recover,30,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Safety,recover,recover,30,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,error,error,73,"// ::foo::bar; // C++ scope specifier. Annotate and loop, or bail out on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,Integrability,inject,injected-class-name,209,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,Security,inject,injected-class-name,209,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - `return type`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:150,Availability,error,errors,150,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:242,Availability,recover,recover,242,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:242,Safety,recover,recover,242,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template; // explicit instantiation and explicit specialization:; // - `return type`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Availability,error,error,111,"// If this is not a typedef name, don't parse it as part of the declspec,; // it must be an implicit int or an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:119,Usability,guid,guide,119,"// Likewise, if this is a context where the identifier could be a template; // name, check whether this is a deduction guide declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:62,Integrability,protocol,protocol,62,// The identifier; // Objective-C supports type arguments and protocol references; // following an Objective-C object or object pointer; // type. Handle either one of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:173,Deployability,update,update,173,"// Any of the following tokens are likely the start of the user; // forgetting 'auto' or 'decltype(auto)', so diagnose.; // Note: if updating this list, please make sure we update; // isCXXDeclarationSpecifier's check for IsPlaceholderSpecifier to have; // a matching list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Safety,avoid,avoid,64,"// C++ for OpenCL does not allow virtual function qualifier, to avoid; // function pointers restricted in OpenCL v2.0 s6.9.a.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:14,Availability,error,error,14,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Availability,recover,recovery,20,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Safety,recover,recovery,20,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Availability,redundant,redundant,18,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Safety,redund,redundant,18,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Security,access,access,10,// OpenCL access qualifiers:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:12,Availability,error,error,12,// After an error the next token can be an annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';'); // or an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Deployability,Install,Install,3,// Install the declarator into the current TagDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:40,Safety,avoid,avoid,40,// Skip to end of block or statement to avoid ext-warning on extra ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:133,Modifiability,extend,extend,133,// C++11 [temp.explicit]p12:; // The usual access controls do not apply to names used to specify; // explicit instantiations.; // We extend this to also cover explicit specializations. Note that; // we don't suppress if this turns out to be an elaborated type; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Security,access,access,43,// C++11 [temp.explicit]p12:; // The usual access controls do not apply to names used to specify; // explicit instantiations.; // We extend this to also cover explicit specializations. Note that; // we don't suppress if this turns out to be an elaborated type; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:791,Usability,clear,clear,791,"// This might be an enum-base or part of some unrelated enclosing context.; //; // 'enum E : base' is permitted in two circumstances:; //; // 1) As a defining-type-specifier, when followed by '{'.; // 2) As the sole constituent of a complete declaration -- when DS is empty; // and the next token is ';'.; //; // The restriction to defining-type-specifiers is important to allow parsing; // a ? new enum E : int{}; // _Generic(a, enum E : int{}); // properly.; //; // One additional consideration applies:; //; // C++ [dcl.enum]p1:; // A ':' following ""enum nested-name-specifier[opt] identifier"" within; // the decl-specifier-seq of a member-declaration is parsed as part of; // an enum-base.; //; // Other language modes supporting enumerations with fixed underlying types; // do not have clear rules on this, so we disambiguate to determine whether; // the tokens form a bit-field width or an enum-base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:118,Availability,error,error,118,"// Outside C++11, do not interpret the tokens as an enum-base if they do; // not make sense as one. In C++11, it's an error if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Availability,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Safety,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Integrability,depend,dependent,19,// This enum has a dependent nested-name-specifier. Handle it as a; // dependent tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:71,Integrability,depend,dependent,71,// This enum has a dependent nested-name-specifier. Handle it as a; // dependent tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Deployability,Install,Install,3,// Install the enumerator constant into EnumDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,Availability,avail,availability,28,// Now handle enum constant availability diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,Availability,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,Safety,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Integrability,protocol,protocol,20,"// GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:192,Integrability,depend,dependent,192,/// isDeclarationSpecifier() - Return true if the current token is part of a; /// declaration specifier.; ///; /// \param AllowImplicitTypename whether this is a context where T::type [T; /// dependent] can appear.; /// \param DisambiguatingWithExpression True to indicate that the purpose of; /// this check is to disambiguate between an expression and a declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:202,Integrability,message,message,202,"// If we're in Objective-C and we have an Objective-C class type followed; // by an identifier and then either ':' or ']', in a place where an; // expression is permitted, then this is probably a class message send; // missing the initial '['. In this case, we won't consider this to be; // the start of a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Integrability,protocol,protocol,20,"// GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Usability,guid,guide,30,// C(X) -> ... is a deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,error,65,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Availability,recover,recovery,75,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,recover,recovery,75,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:56,Availability,error,errors,56,"// We parse rvalue refs in C++03, because otherwise the errors are scary.; // But we must not parse them in conversion-type-ids and new-type-ids, since; // those can be legitimately followed by a && operator.; // (The same thing can in theory happen after a trailing-return-type, but; // since those are a C++11 feature, there is no rejects-valid issue there.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:312,Modifiability,extend,extended,312,"/// ParseDeclaratorInternal - Parse a C or C++ declarator. The direct-declarator; /// is parsed by the function passed to it. Pass null, and the direct-declarator; /// isn't parsed at all, making this function effectively parse the C++; /// ptr-operator production.; ///; /// If the grammar of this construct is extended, matching changes must also be; /// made to TryParseDeclarator and MightBeDeclarator, and possibly to; /// isConstructorDeclarator.; ///; /// declarator: [C99 6.7.5] [C++ 8p4, dcl.decl]; /// [C] pointer[opt] direct-declarator; /// [C++] direct-declarator; /// [C++] ptr-operator declarator; ///; /// pointer: [C99 6.7.5]; /// '*' type-qualifier-list[opt]; /// '*' type-qualifier-list[opt] pointer; ///; /// ptr-operator:; /// '*' cv-qualifier-seq[opt]; /// '&'; /// [C++0x] '&&'; /// [GNU] '&' restrict[opt] attributes[opt]; /// [GNU?] '&&' restrict[opt] attributes[opt]; /// '::'[opt] nested-name-specifier '*' cv-qualifier-seq[opt]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:139,Integrability,message,messages,139,"// When correcting from misplaced brackets before the identifier, the location; // is saved inside the declarator so that other diagnostic messages can use; // them. This extracts and returns that location, or returns the provided; // location if a stored location does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:1588,Usability,simpl,simple-declaration,1588,"/// ParseDirectDeclarator; /// direct-declarator: [C99 6.7.5]; /// [C99] identifier; /// '(' declarator ')'; /// [GNU] '(' attributes declarator ')'; /// [C90] direct-declarator '[' constant-expression[opt] ']'; /// [C99] direct-declarator '[' type-qual-list[opt] assignment-expr[opt] ']'; /// [C99] direct-declarator '[' 'static' type-qual-list[opt] assign-expr ']'; /// [C99] direct-declarator '[' type-qual-list 'static' assignment-expr ']'; /// [C99] direct-declarator '[' type-qual-list[opt] '*' ']'; /// [C++11] direct-declarator '[' constant-expression[opt] ']'; /// attribute-specifier-seq[opt]; /// direct-declarator '(' parameter-type-list ')'; /// direct-declarator '(' identifier-list[opt] ')'; /// [GNU] direct-declarator '(' parameter-forward-declarations; /// parameter-type-list[opt] ')'; /// [C++] direct-declarator '(' parameter-declaration-clause ')'; /// cv-qualifier-seq[opt] exception-specification[opt]; /// [C++11] direct-declarator '(' parameter-declaration-clause ')'; /// attribute-specifier-seq[opt] cv-qualifier-seq[opt]; /// ref-qualifier[opt] exception-specification[opt]; /// [C++] declarator-id; /// [C++11] declarator-id attribute-specifier-seq[opt]; ///; /// declarator-id: [C++ 8]; /// '...'[opt] id-expression; /// '::'[opt] nested-name-specifier[opt] type-name; ///; /// id-expression: [C++ 5.1]; /// unqualified-id; /// qualified-id; ///; /// unqualified-id: [C++ 5.1]; /// identifier; /// operator-function-id; /// conversion-function-id; /// '~' class-name; /// template-id; ///; /// C++17 adds the following, which we also handle here:; ///; /// simple-declaration:; /// <decl-spec> '[' identifier-list ']' brace-or-equal-initializer ';'; ///; /// Note, any additional constructs added here may need corresponding changes; /// in isConstructorDeclarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Availability,Recover,Recover,44,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Safety,Recover,Recover,44,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,error,65,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Availability,recover,recovery,75,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,recover,recovery,75,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Deployability,update,update,30,// Parsed the unqualified-id; update range information and move along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,// The most likely error is that the ';' was forgotten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,"// If there was an error parsing parenthesized declarator, declarator; // scope may have been entered before. Don't do it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,Usability,simpl,simple,27,"// This could be something simple like ""int"" (in which case the declarator; // portion is empty), if an abstract-declarator is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,errors,65,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Safety,Detect,Detect,18,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:36,Usability,simpl,simple,36,"// Identifier lists follow a really simple grammar: the identifiers can; // be followed *only* by a "", identifier"" or "")"". However, K&R; // identifier lists are really rare in the brave new modern world, and; // it is very common for someone to typo a type in a non-K&R style; // list. If we are presented with something like: ""void foo(intptr x,; // float y)"", we don't want to start parsing the function declarator as; // though it is a K&R style declarator just because intptr is an; // invalid type.; //; // To handle this, we check to see if the token after the first; // identifier is a "","" or "")"". Only then do we parse it as an; // identifier list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Energy Efficiency,efficient,efficient,15,// Maintain an efficient lookup of params we have seen so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Availability,error,error,43,"// If this isn't an identifier, report the error and skip until ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Testability,test,test,30,"// Reject 'typedef int y; int test(x, y)', but continue parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the maximum function scope depth.; // See https://bugs.llvm.org/show_bug.cgi?id=19607; // Note Sema::ActOnParamDeclarator calls ParmVarDecl::setScopeInfo with; // getFunctionPrototypeDepth() - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,Availability,error,error,28,"// Completely missing, emit error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,Availability,recover,recover,157,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,Safety,recover,recover,157,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,Availability,recover,recovery,626,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,Safety,recover,recovery,626,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:39,Performance,cache,cache,39,"// If we're inside a class definition, cache the tokens; // corresponding to the default argument. We'll actually parse; // them when we see the end of the class definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:363,Integrability,depend,depending,363,"// Note, in C89, this production uses the constant-expr production instead; // of assignment-expr. The only difference is that assignment-expr allows; // things like '=' and '*='. Sema rejects these in C89 mode because they; // are not i-c-e's, so we don't need to distinguish between the two here.; // Parse the constant-expression or assignment-expression now (depending; // on dialect).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:60,Availability,recover,recover,60,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:60,Safety,recover,recover,60,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Availability,error,error,103,"// Something went wrong parsing the brackets, in which case,; // ParseBracketDeclarator has emitted an error, and we don't need to emit; // one here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:29,Availability,error,error,29,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,Integrability,message,message,35,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of directive' token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:447,Integrability,interface,interfaces,447,"//===--- ParseDeclCXX.cpp - C++ Declaration Parsing -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the C++ Declaration portions of the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,Availability,recover,recovery,62,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,Safety,recover,recovery,62,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:45,Usability,simpl,simply,45,// The caller is what called check -- we are simply calling; // the close for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:37,Availability,error,error,37,// Template parameters are always an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:148,Availability,error,errors,148,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:348,Usability,simpl,simple-template-id,348,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:49,Availability,recover,recovering,49,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:135,Integrability,depend,depends,135,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:49,Safety,recover,recovering,49,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,Availability,recover,recover,27,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,Safety,recover,recover,27,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:39,Testability,assert,assertion,39,// Save the token name used for static assertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:44,Usability,simpl,simple,44,// Parse the expression; // C++11 [dcl.type.simple]p4:; // The operand of the decltype specifier is an unevaluated operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:21,Availability,error,error,21,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:110,Performance,cache,cache,110,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:190,Usability,resume,resume,190,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:286,Integrability,depend,depending,286,"/// ParseBaseTypeSpecifier - Parse a C++ base-type-specifier which is either a; /// class name or decltype-specifier. Note that we only check that the result; /// names a type; semantic analysis will need to verify that the type names a; /// class. The result is either a type or null, depending on whether a type; /// name was found.; ///; /// base-type-specifier: [C++11 class.derived]; /// class-or-decltype; /// class-or-decltype: [C++11 class.derived]; /// nested-name-specifier[opt] class-name; /// decltype-specifier; /// class-name: [C++ class.name]; /// identifier; /// simple-template-id; ///; /// In C++98, instead of base-type-specifier, we have:; ///; /// ::[opt] nested-name-specifier[opt] class-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:579,Usability,simpl,simple-template-id,579,"/// ParseBaseTypeSpecifier - Parse a C++ base-type-specifier which is either a; /// class name or decltype-specifier. Note that we only check that the result; /// names a type; semantic analysis will need to verify that the type names a; /// class. The result is either a type or null, depending on whether a type; /// name was found.; ///; /// base-type-specifier: [C++11 class.derived]; /// class-or-decltype; /// class-or-decltype: [C++11 class.derived]; /// nested-name-specifier[opt] class-name; /// decltype-specifier; /// class-name: [C++ class.name]; /// identifier; /// simple-template-id; ///; /// In C++98, instead of base-type-specifier, we have:; ///; /// ::[opt] nested-name-specifier[opt] class-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:59,Availability,error,error,59,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:65,Availability,recover,recovery,65,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:65,Safety,recover,recovery,65,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:30,Availability,error,error,30,// Fall through to produce an error below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:523,Availability,error,error,523,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:556,Availability,error,error,556,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:826,Availability,error,error,826,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:566,Usability,simpl,simple-template-id,566,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:838,Usability,simpl,simple-template-id,838,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:1119,Usability,simpl,simple-template-id,1119,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:93,Integrability,depend,dependent,93,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:51,Security,access,access,51,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:253,Security,access,access,253,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:155,Usability,simpl,simple-template-id,155,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Modifiability,inherit,inheritance,9,// Parse inheritance specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:46,Modifiability,inherit,inheritance,46,// Allow attributes to precede or succeed the inheritance specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:269,Usability,undo,undo,269,"// HACK: MSVC doesn't consider _Atomic to be a keyword and its STL; // implementation for VS2013 uses _Atomic as an identifier for one of the; // classes in <atomic>. When we are parsing 'struct _Atomic', don't consider; // '_Atomic' to be a keyword. We are careful to undo this so that clang can; // use '_Atomic' in its own header files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Usability,simpl,simple-template-id,38,// Parse the (optional) class name or simple-template-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:60,Deployability,update,update,60,// Try to resolve the template name to a type template. May update Kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:123,Availability,error,error,123,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:129,Integrability,message,message,129,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:28,Usability,simpl,simple-template-id,28,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:583,Safety,detect,detect,583,"// There are four options here.; // - If we are in a trailing return type, this is always just a reference,; // and we must not try to parse a definition. For instance,; // [] () -> struct S { };; // does not define a type.; // - If we have 'struct foo {...', 'struct foo :...',; // 'struct foo final :' or 'struct foo final {', then this is a definition.; // - If we have 'struct foo;', then this is either a forward declaration; // or a friend declaration, which have to be treated differently.; // - Otherwise we have something like 'struct foo xyz', a reference.; //; // We also detect these erroneous cases to provide better diagnostic for; // C++11 attributes parsing.; // - attributes follow class name:; // struct foo [[]] {};; // - attributes appear before or after 'final':; // struct foo [[]] final [[]] {};; //; // However, in type-specifier-seq's, things look like declarations but are; // just references, e.g.; // new struct s;; // or; // &T::operator struct s;; // For these, DSC is DeclSpecContext::DSC_type_specifier or; // DeclSpecContext::DSC_alias_declaration.; // If there are attributes after class name, parse them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:64,Availability,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:64,Safety,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:177,Modifiability,variab,variable,177,"// If we are parsing a definition and stop at a base-clause, continue on; // until the semicolon. Continuing from the comma will just trick us into; // thinking we are seeing a variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:204,Availability,error,error,204,"// Friend template-ids are treated as references unless; // they have template headers, in which case they're ill-formed; // (FIXME: ""template <class T> friend class A<T>::B<int>;"").; // We diagnose this error in ActOnClassTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:14,Availability,down,down,14,"// Don't pass down template parameter lists if this is just a tag; // reference. For example, we don't need the template parameters here:; // template <class T> class A *makeA(T t);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:33,Integrability,depend,dependent,33,"// If ActOnTag said the type was dependent, try again with the; // less common call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:209,Availability,error,error,209,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:215,Availability,recover,recovery,215,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:344,Availability,recover,recover,344,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:215,Safety,recover,recovery,215,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:344,Safety,recover,recover,344,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:115,Availability,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:115,Safety,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:411,Security,access,access-specifier,411,"/// ParseBaseSpecifier - Parse a C++ base-specifier. A base-specifier is; /// one entry in the base class list of a class specifier, for example:; /// class foo : public bar, virtual private baz {; /// 'public bar' and 'virtual private baz' are each base-specifiers.; ///; /// base-specifier: [C++ class.derived]; /// attribute-specifier-seq[opt] base-type-specifier; /// attribute-specifier-seq[opt] 'virtual' access-specifier[opt]; /// base-type-specifier; /// attribute-specifier-seq[opt] access-specifier 'virtual'[opt]; /// base-type-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:492,Security,access,access-specifier,492,"/// ParseBaseSpecifier - Parse a C++ base-specifier. A base-specifier is; /// one entry in the base class list of a class specifier, for example:; /// class foo : public bar, virtual private baz {; /// 'public bar' and 'virtual private baz' are each base-specifiers.; ///; /// base-specifier: [C++ class.derived]; /// attribute-specifier-seq[opt] base-type-specifier; /// attribute-specifier-seq[opt] 'virtual' access-specifier[opt]; /// base-type-specifier; /// attribute-specifier-seq[opt] access-specifier 'virtual'[opt]; /// base-type-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:23,Security,access,access,23,// Parse an (optional) access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:71,Security,access,access,71,"// Parse the 'virtual' keyword (again!), in case it came after the; // access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:81,Security,access,access-specifier,81,/// getAccessSpecifierIfPresent - Determine whether the next token is; /// a C++ access-specifier.; ///; /// access-specifier: [C++ class.derived]; /// 'private'; /// 'protected'; /// 'public',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:109,Security,access,access-specifier,109,/// getAccessSpecifierIfPresent - Determine whether the next token is; /// a C++ access-specifier.; ///; /// access-specifier: [C++ class.derived]; /// 'private'; /// 'protected'; /// 'public',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:8,Usability,simpl,simple-asm-expr,8,"// If a simple-asm-expr is present, parse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:130,Availability,error,errors,130,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:140,Availability,error,error,140,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:146,Availability,recover,recovery,146,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:146,Safety,recover,recovery,146,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Security,Access,Access,3,// Access declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Availability,recover,recover,9,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Safety,recover,recover,9,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:18,Security,access,access,18,// Turn off usual access checking for templates explicit specialization; // and instantiation.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:147,Security,access,access,147,// Turn off usual access checking for templates explicit specialization; // and instantiation.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,Availability,error,error,16,// Diagnose the error and pretend there is no in-class initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Error,Error,3,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Availability,recover,recovery,9,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Safety,recover,recovery,9,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:46,Performance,cache,cache,46,// The initializer was deferred; parse it and cache the tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid later warnings about a class member of incomplete type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';'); // or an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:80,Safety,detect,detect,80,"/// ParseCXXMemberInitializer - Parse the brace-or-equal-initializer.; /// Also detect and reject any attempted defaulted/deleted function definition.; /// The location of the '=', if any, will be placed in EqualLoc.; ///; /// This does not check for a pure-specifier; that's handled elsewhere.; ///; /// brace-or-equal-initializer:; /// '=' initializer-expression; /// braced-init-list; ///; /// initializer-clause:; /// assignment-expression; /// braced-init-list; ///; /// defaulted/deleted function-definition:; /// '=' 'default'; /// '=' 'delete'; ///; /// Prior to C++0x, the assignment-expression in an initializer-clause must; /// be a constant-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:44,Security,access,access,44,// FIXME: We don't accept GNU attributes on access specifiers in OpenCL mode; // yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Security,access,access,26,// Current token is a C++ access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:70,Security,access,access,70,// The Microsoft extension __interface does not permit non-public; // access specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:149,Security,access,access-specifier,149,/// ParseCXXMemberSpecification - Parse the class definition.; ///; /// member-specification:; /// member-declaration member-specification[opt]; /// access-specifier ':' member-specification[opt]; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Availability,Error,ErrorType,2,/*ErrorType=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:24,Usability,simpl,simple-template-id,24,// base-clause can have simple-template-id; 'template' can't be there,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:7,Availability,recover,recovering,7,// Try recovering from missing { after base-clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:7,Safety,recover,recovering,7,// Try recovering from missing { after base-clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Availability,recover,recover,38,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Safety,recover,recover,38,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:15,Performance,cache,cache,15,// Consume and cache the starting token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Performance,Cache,Cache,3,// Cache the tokens for the exception-specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,Availability,recover,recovery,74,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,Safety,recover,recovery,74,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:99,Integrability,rout,routine,99,"/// Pop the top class of the stack of classes that are; /// currently being parsed.; ///; /// This routine should be called when we have finished parsing the; /// definition of a class, but have not yet popped the Scope; /// associated with the class's definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:57,Performance,perform,perform,57,"// The victim is a nested class, but we will not need to perform; // any processing after the definition of this class since it has; // no members whose handling was delayed. Therefore, we can just; // remove this nested class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,Availability,recover,recover,161,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,Safety,recover,recover,161,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:116,Performance,cache,cached,116,"// If the attribute is named `directive`, we can consume its argument list; // and push the tokens from it into the cached token stream for a new OpenMP; // pragma directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:133,Availability,error,error,133,"// The attribute was allowed to have arguments, but none were provided; // even though the attribute parsed successfully. This is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,Availability,error,error,16,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Availability,recover,recovered,26,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Safety,recover,recovered,26,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:371,Availability,error,errors,371,"// Since none of C++'s keywords match [a-f]+, accepting just tok::l_brace,; // tok::r_brace, tok::minus, tok::identifier (think C000) and; // tok::numeric_constant (0000) should be enough. But the spelling of the; // uuid argument is checked later anyways, so there's no harm in accepting; // almost anything here.; // cl is very strict about whitespace in this form and errors out if any; // is present, so check the space flags on the tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Security,access,access,26,// Current token is a C++ access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2382,Testability,log,logical-AND-expression,2382,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2453,Testability,log,logical-AND-expression,2453,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2515,Testability,log,logical-OR-expression,2515,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2556,Testability,log,logical-AND-expression,2556,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2584,Testability,log,logical-OR-expression,2584,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2611,Testability,log,logical-AND-expression,2611,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2686,Testability,log,logical-OR-expression,2686,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2713,Testability,log,logical-OR-expression,2713,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2788,Testability,log,logical-OR-expression,2788,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:4,Usability,Simpl,Simple,4,"/// Simple precedence-based parser for binary/ternary operators.; ///; /// Note: we diverge from the C99 grammar when parsing the assignment-expression; /// production. C99 specifies that the LHS of an assignment operator should be; /// parsed as a unary-expression, but consistency dictates that it be a; /// conditional-expession. In practice, the important thing here is that the; /// LHS of an assignment has to be an l-value, which productions between; /// unary-expression and conditional-expression don't produce. Because we want; /// consistency, we parse the LHS as a conditional-expression, then check for; /// l-value-ness in semantic analysis stages.; ///; /// \verbatim; /// pm-expression: [C++ 5.5]; /// cast-expression; /// pm-expression '.*' cast-expression; /// pm-expression '->*' cast-expression; ///; /// multiplicative-expression: [C99 6.5.5]; /// Note: in C++, apply pm-expression instead of cast-expression; /// cast-expression; /// multiplicative-expression '*' cast-expression; /// multiplicative-expression '/' cast-expression; /// multiplicative-expression '%' cast-expression; ///; /// additive-expression: [C99 6.5.6]; /// multiplicative-expression; /// additive-expression '+' multiplicative-expression; /// additive-expression '-' multiplicative-expression; ///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relationa",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:9,Integrability,rout,routine,9,"/// This routine is called when the '@' is seen and consumed.; /// Current token is an Identifier and is not a 'try'. This; /// routine is necessary to disambiguate \@try-statement from,; /// for example, \@encode-expression.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:128,Integrability,rout,routine,128,"/// This routine is called when the '@' is seen and consumed.; /// Current token is an Identifier and is not a 'try'. This; /// routine is necessary to disambiguate \@try-statement from,; /// for example, \@encode-expression.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:9,Integrability,rout,routine,9,/// This routine is called when a leading '__extension__' is seen and; /// consumed. This is necessary because the token gets consumed in the; /// process of disambiguating between an expression and a declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:64,Integrability,message,message,64,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:183,Integrability,message,message,183,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:296,Integrability,message,message,296,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:114,Testability,log,logical-or-expression,114,/// Parse a constraint-expression.; ///; /// \verbatim; /// constraint-expression: C++2a[temp.constr.decl]p1; /// logical-or-expression; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Testability,log,logical-and-expression,30,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:121,Testability,log,logical-and-expression,121,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:185,Testability,log,logical-and-expression,185,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:94,Testability,log,logical,94,"// Use InclusiveOr, the precedence just after '&&' to not parse the; // next arguments to the logical and.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Testability,log,logical-or-expression,30,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:120,Testability,log,logical-or-expression,120,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Testability,log,logical-and-expression,159,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:198,Testability,log,logical-or-expression,198,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:241,Testability,log,logical-and-expression,241,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:55,Availability,error,error,55,"// Consume the operator, saving the operator token for error reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:84,Integrability,message,message,84,"// In Objective-C++, alternative operator tokens can be used as keyword args; // in message expressions. Unconsume the token so that it can reinterpreted; // as an identifier in ParseObjCMessageExpressionBody. i.e., we support:; // [foo meth:0 and:0];; // [foo not_eq];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:37,Availability,error,error,37,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:43,Availability,recover,recovery,43,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:43,Safety,recover,recovery,43,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:41,Testability,log,logical-OR-expression,41,"// Handle this production specially:; // logical-OR-expression '?' expression ':' conditional-expression; // In particular, the RHS of the '?' is 'expression', not; // 'logical-OR-expression' as we might expect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:169,Testability,log,logical-OR-expression,169,"// Handle this production specially:; // logical-OR-expression '?' expression ':' conditional-expression; // In particular, the RHS of the '?' is 'expression', not; // 'logical-OR-expression' as we might expect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:62,Testability,log,logical-OR-expression,62,"// Special case handling of ""X ? Y : Z"" where Y is empty:; // logical-OR-expression '?' ':' conditional-expression [GNU]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,Error,Errors,10,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from parsing the RHS, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:87,Availability,error,errors,87,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from parsing the RHS, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,Error,Errors,10,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from ParseRHSOfBinaryExpression, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:87,Availability,error,errors,87,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from ParseRHSOfBinaryExpression, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:50,Performance,perform,performed,50,"// In this case, ActOnBinOp or ActOnConditionalOp performed the; // CorrectDelayedTyposInExpr check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2419,Integrability,message,message-expr,2419,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2502,Integrability,protocol,protocol,2502,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2615,Usability,simpl,simple-type-specifier,2615,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2691,Usability,simpl,simple-type-specifier,2691," /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'typeid' '(' expression ')' [C++ 5.2p1]; /// [C++] 'typeid' '(' type-id ')' [C++ 5.2p1]; /// [C++] 'this' [C++ 9.3.2]; /// [G++] unary-type-trait '(' type-id ')'; /// [G++] binary-type-trait '(' type-id ',' type-id ')' [TODO]; /// [EMBT] array-type-trait '(' type-id ',' integer ')'; /// [clang] '^' block-literal; ///; /// constant: [C99 6.4.4]; /// integer-constant; /// floating-constant; /// enumeration-constant -> identifier; /// character-constant; ///; /// id-expression: [C++ 5.1]; /// unqualified-id; /// qu",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:166,Usability,simpl,simplify,166,"// This handles all of cast-expression, unary-expression, postfix-expression,; // and primary-expression. We handle them together like this for efficiency; // and to simplify handling of an expression starting with a '(' token: which; // may be one of a parenthesized expression, cast-expression, compound literal; // expression, or statement expression.; //; // If the parsed tokens consist of a primary-expression, the cases below; // break out of the switch; at the end we call ParsePostfixExpressionSuffix; // to handle the postfix expression suffixes. Cases that cannot be followed; // by postfix exprs should set AllowSuffix to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid the unnecessary parse-time lookup in the common case; // where the syntax forbids a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:65,Deployability,update,update,65,"// If we find that this is in fact the name of a type trait,; // update the token kind in place and parse again to treat it as; // the appropriate kind of type trait.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:192,Integrability,message,message,192,"// In an Objective-C method, if we have ""super"" followed by an identifier,; // the token sequence is ill-formed. However, if there's a ':' or ']' after; // that identifier, this is probably a message send with a missing open; // bracket. Treat it as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Availability,Recover,Recovery,171,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:122,Integrability,message,message,122,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:228,Performance,perform,performing,228,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Safety,Recover,Recovery,171,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,Availability,down,down,21,// Make sure to pass down the right value for isAddressOfOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:91,Availability,error,error,91,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:97,Availability,recover,recovery,97,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:97,Safety,recover,recovery,97,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:28,Usability,simpl,simple-type-specifier,28,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:23,Usability,simpl,simple-type-specifier,23,// postfix-expression: simple-type-specifier '(' expression-list[opt] ')'; // simple-type-specifier braced-init-list; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:78,Usability,simpl,simple-type-specifier,78,// postfix-expression: simple-type-specifier '(' expression-list[opt] ')'; // simple-type-specifier braced-init-list; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:44,Integrability,message,message,44,"// C++11 lambda expressions and Objective-C message sends both start with a; // square bracket. There are three possibilities here:; // we have a valid lambda expression, we have an invalid lambda; // expression, or we have something that doesn't appear to be a lambda.; // If we're in the last case, we fall back to ParseObjCMessageExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:27,Integrability,message,message,27,// We assume Objective-C++ message expressions are not; // primary-expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:126,Availability,error,error,126,"// Check to see whether Res is a function designator only. If it is and we; // are compiling for OpenCL, we need to return an error as this implies; // that the address of the function is being taken, which is illegal in CL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:80,Availability,error,error,80,// FIXME: Don't parse a primary-expression suffix if we encountered a parse; // error already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:77,Integrability,message,message,77,"// If we see identifier: after an expression, and we're not already in a; // message send, then this is probably a message send with a missing; // opening bracket '['.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:115,Integrability,message,message,115,"// If we see identifier: after an expression, and we're not already in a; // message send, then this is probably a message send with a missing; // opening bracket '['.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Integrability,message,message,30,// Fall through; this isn't a message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:427,Availability,recover,recover,427,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:285,Integrability,message,message,285,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:427,Safety,recover,recover,427,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:140,Performance,cache,cache,140,"// Handle OpenACC first, since 'AllowOpenACCArraySections' is only enabled; // when actively parsing a 'var' in a 'var-list' during clause/'cache'; // parsing, so it is the most specific, and best allows us to handle; // OpenACC and OpenMP at the same time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,Availability,error,error,16,// There was an error closing the brackets,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,Availability,error,error,16,"// If we got an error when parsing expression list, we don't call; // the CodeCompleteCall handler inside the parser. So call it here; // to make sure we get overload suggestions even when we are in the; // middle of a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:106,Safety,avoid,avoid,106,"// If there were delayed typos in the LHS or ArgExprs, call SkipUntil; // instead of PT.consumeClose() to avoid emitting extra diagnostics for; // the unmatched l_paren.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,Performance,perform,perform,21,"// Clang will try to perform expression based completion as a; // fallback, which is confusing in case of member references. So we; // stop here without any completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:32,Security,access,access,32,// Code completion for a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:311,Integrability,message,message,311,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:46,Security,access,access,46,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:158,Security,access,access,158,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:51,Availability,error,error,51,// FIXME: This loop leaks the index expressions on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:636,Integrability,bridg,bridged-cast-expression,636,"/// ParseParenExpression - This parses the unit that starts with a '(' token,; /// based on what is allowed by ExprType. The actual thing parsed is returned; /// in ExprType. If stopIfCastExpr is true, it will only return the parsed type,; /// not the parsed cast-expression.; ///; /// \verbatim; /// primary-expression: [C99 6.5.1]; /// '(' expression ')'; /// [GNU] '(' compound-statement ')' (if !ParenExprOnly); /// postfix-expression: [C99 6.5.2]; /// '(' type-name ')' '{' initializer-list '}'; /// '(' type-name ')' '{' initializer-list ',' '}'; /// cast-expression: [C99 6.5.4]; /// '(' type-name ')' cast-expression; /// [ARC] bridged-cast-expression; /// [ARC] bridged-cast-expression:; /// (__bridge type-name) cast-expression; /// (__bridge_transfer type-name) cast-expression; /// (__bridge_retained type-name) cast-expression; /// fold-expression: [C++1z]; /// '(' cast-expression fold-operator '...' ')'; /// '(' '...' fold-operator cast-expression ')'; /// '(' cast-expression fold-operator '...'; /// fold-operator cast-expression ')'; /// [OPENMP] Array shaping operation; /// '(' '[' expression ']' { '[' expression ']' } cast-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:671,Integrability,bridg,bridged-cast-expression,671,"/// ParseParenExpression - This parses the unit that starts with a '(' token,; /// based on what is allowed by ExprType. The actual thing parsed is returned; /// in ExprType. If stopIfCastExpr is true, it will only return the parsed type,; /// not the parsed cast-expression.; ///; /// \verbatim; /// primary-expression: [C99 6.5.1]; /// '(' expression ')'; /// [GNU] '(' compound-statement ')' (if !ParenExprOnly); /// postfix-expression: [C99 6.5.2]; /// '(' type-name ')' '{' initializer-list '}'; /// '(' type-name ')' '{' initializer-list ',' '}'; /// cast-expression: [C99 6.5.4]; /// '(' type-name ')' cast-expression; /// [ARC] bridged-cast-expression; /// [ARC] bridged-cast-expression:; /// (__bridge type-name) cast-expression; /// (__bridge_transfer type-name) cast-expression; /// (__bridge_retained type-name) cast-expression; /// fold-expression: [C++1z]; /// '(' cast-expression fold-operator '...' ')'; /// '(' '...' fold-operator cast-expression ')'; /// '(' cast-expression fold-operator '...'; /// fold-operator cast-expression ')'; /// [OPENMP] Array shaping operation; /// '(' '[' expression ']' { '[' expression ']' } cast-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:19,Integrability,bridg,bridge,19,// Diagnose use of bridge casts in non-arc mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:105,Availability,error,error,105,// None of these cases should fall through with an invalid Result; // unless they've already reported an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:45,Modifiability,Variab,Variables,45,"// Find the nearest non-record decl context. Variables declared in a; // statement expression behave as if they were declared in the enclosing; // function, block, or other code construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Availability,Recover,Recover,159,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:108,Integrability,message,message,108,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Safety,Recover,Recover,159,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:12,Performance,perform,performed,12,// After we performed the cast we can check for postfix-expr pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:105,Availability,error,error,105,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:222,Performance,perform,performed,222,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:35,Availability,error,errors,35,// Ensure typos get diagnosed when errors were encountered while parsing the; // expression list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:34,Usability,simpl,simple,34,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:143,Usability,simpl,simple-expression-list,143,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:199,Usability,simpl,simple-expression-list,199,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:178,Modifiability,variab,variable,178,"// Enter a scope to hold everything within the block. This includes the; // argument decls, decls within the compound expression, etc. This also; // allows determining whether a variable reference inside the block is; // within or outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:19,Availability,error,error,19,"// If there was an error parsing the arguments, they may have; // tried to use ^(x+y) which requires an argument list. Just; // skip the whole block literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:13,Availability,avail,availability,13,"/// Validate availability spec list, emitting diagnostics if necessary. Returns; /// true if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:4,Security,Validat,Validate,4,"/// Validate availability spec list, emitting diagnostics if necessary. Returns; /// true if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:95,Availability,error,error,95,"// Rule out multiple version specs referring to the same platform.; // For example, we emit an error for:; // @available(macos 10.10, macos 10.11, *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:111,Availability,avail,available,111,"// Rule out multiple version specs referring to the same platform.; // For example, we emit an error for:; // @available(macos 10.10, macos 10.11, *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,avail,availability,10,/// Parse availability query specification.; ///; /// availability-spec:; /// '*'; /// identifier version-tuple,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:54,Availability,avail,availability-spec,54,/// Parse availability query specification.; ///; /// availability-spec:; /// '*'; /// identifier version-tuple,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:11,Availability,avail,available,11,// Eat the available or __builtin_available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Deployability,Update,Update,3,// Update token information to reflect their change in token type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1016,Availability,error,errors,1016,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1823,Availability,error,error,1823,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1829,Availability,recover,recovery,1829,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:2150,Availability,error,error,2150,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:191,Integrability,rout,routine,191,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1829,Safety,recover,recovery,1829,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:754,Security,access,access,754,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:849,Security,access,accessed,849,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:938,Security,access,access,938,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:499,Usability,simpl,simple-template-id,499,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:166,Testability,assert,assertion,166,// Include code completion token into the range of the scope otherwise; // when we try to annotate the scope tokens the dangling code completion; // token will cause assertion in; // Preprocessor::AnnotatePreviousCachedTokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:254,Usability,clear,clear,254,"// C++ [basic.lookup.classref]p5:; // If the qualified-id has the form; //; // ::class-name-or-namespace-name::...; //; // the class-name-or-namespace-name is looked up in global scope as a; // class-name or namespace-name.; //; // To implement this, we clear out the object type as soon as we've; // seen a leading '::' or part of a nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Usability,simpl,simple-template-id,68,"// nested-name-specifier:; // nested-name-specifier 'template'[opt] simple-template-id '::'; // Parse the optional 'template' keyword, then make sure we have; // 'identifier <' after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:82,Usability,simpl,simple-template-id,82,"// We don't need to actually parse the unqualified-id in this case,; // because a simple-template-id cannot start with 'operator', but; // go ahead and parse it anyway for consistency with the case where; // we already annotated the template-id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:163,Integrability,depend,dependent,163,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:93,Usability,simpl,simple-template-id,93,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Availability,Recover,Recover,68,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Safety,Recover,Recover,68,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,Availability,error,error,71,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:138,Availability,recover,recover,138,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:138,Safety,recover,recover,138,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:149,Availability,error,error,149,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Availability,recover,recovery,155,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Safety,recover,recovery,155,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Availability,error,errors,13,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Integrability,depend,dependent,46,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:229,Integrability,depend,dependent,229,"// We have something like t::getAs<T>, where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:592,Availability,error,error,592,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:677,Availability,error,error,677,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:944,Availability,error,errors,944,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:724,Usability,simpl,simplify,724,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:569,Usability,simpl,simple-capture,569,"/// ParseLambdaExpression - Parse a C++11 lambda expression.; ///; /// lambda-expression:; /// lambda-introducer lambda-declarator compound-statement; /// lambda-introducer '<' template-parameter-list '>'; /// requires-clause[opt] lambda-declarator compound-statement; ///; /// lambda-introducer:; /// '[' lambda-capture[opt] ']'; ///; /// lambda-capture:; /// capture-default; /// capture-list; /// capture-default ',' capture-list; ///; /// capture-default:; /// '&'; /// '='; ///; /// capture-list:; /// capture; /// capture-list ',' capture; ///; /// capture:; /// simple-capture; /// init-capture [C++1y]; ///; /// simple-capture:; /// identifier; /// '&' identifier; /// 'this'; ///; /// init-capture: [C++1y]; /// identifier initializer; /// '&' identifier initializer; ///; /// lambda-declarator:; /// lambda-specifiers [C++23]; /// '(' parameter-declaration-clause ')' lambda-specifiers; /// requires-clause[opt]; ///; /// lambda-specifiers:; /// decl-specifier-seq[opt] noexcept-specifier[opt]; /// attribute-specifier-seq[opt] trailing-return-type[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:620,Usability,simpl,simple-capture,620,"/// ParseLambdaExpression - Parse a C++11 lambda expression.; ///; /// lambda-expression:; /// lambda-introducer lambda-declarator compound-statement; /// lambda-introducer '<' template-parameter-list '>'; /// requires-clause[opt] lambda-declarator compound-statement; ///; /// lambda-introducer:; /// '[' lambda-capture[opt] ']'; ///; /// lambda-capture:; /// capture-default; /// capture-list; /// capture-default ',' capture-list; ///; /// capture-default:; /// '&'; /// '='; ///; /// capture-list:; /// capture; /// capture-list ',' capture; ///; /// capture:; /// simple-capture; /// init-capture [C++1y]; ///; /// simple-capture:; /// identifier; /// '&' identifier; /// 'this'; ///; /// init-capture: [C++1y]; /// identifier initializer; /// '&' identifier initializer; ///; /// lambda-declarator:; /// lambda-specifiers [C++23]; /// '(' parameter-declaration-clause ')' lambda-specifiers; /// requires-clause[opt]; ///; /// lambda-specifiers:; /// decl-specifier-seq[opt] noexcept-specifier[opt]; /// attribute-specifier-seq[opt] trailing-return-type[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:34,Integrability,message,message,34,// If lookahead indicates an ObjC message send...; // [identifier identifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:57,Integrability,message,message,57,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:200,Integrability,message,message,200,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:241,Integrability,rout,routines,241,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:39,Integrability,message,message,39,"// Not a lambda-introducer, might be a message send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,Availability,recover,recover,524,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,Safety,recover,recover,524,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform some irreversible action if this is a non-tentative parse;; // otherwise note that our actions were incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:123,Integrability,message,message,123,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:182,Integrability,message,message,182,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:212,Performance,perform,perform,212,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:90,Integrability,message,message,90,"// If we're in Objective-C++ and we have a bare '[', then this is more; // likely to be a message receiver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:175,Availability,error,error,175,"// We have a lone ""&"" or ""="" which is either a misplaced capture-default; // or the start of a capture (in the ""&"" case) with the rest of the; // capture missing. Both are an error but a misplaced capture-default; // is more likely if we don't already have a capture default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:65,Usability,clear,clears,65,"// Each lambda init-capture forms its own full expression, which clears; // Actions.MaybeODRUseExprs. So create an expression evaluation context; // to save the necessary state, and restore it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:164,Integrability,message,message,164,"// We're disambiguating this:; //; // [..., x = expr; //; // We need to find the end of the following expression in order to; // determine whether this is an Obj-C message send's receiver, a; // C99 designator, or a lambda init-capture.; //; // Parse the expression to find where it ends, and annotate it back; // onto the tokens. We would have parsed this expression the same way; // in either case: both the RHS of an init-capture and the RHS of an; // assignment expression are parsed as an initializer-clause, and in; // neither case can anything be added to the scope between the '[' and; // here.; //; // FIXME: This is horrible. Adding a mechanism to skip an expression; // would be much cleaner.; // FIXME: If there is a ',' before the next ']' or ':', we can skip to; // that instead. (And if we see a ':' with no matching '?', we can; // classify this as an Obj-C message send.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:874,Integrability,message,message,874,"// We're disambiguating this:; //; // [..., x = expr; //; // We need to find the end of the following expression in order to; // determine whether this is an Obj-C message send's receiver, a; // C99 designator, or a lambda init-capture.; //; // Parse the expression to find where it ends, and annotate it back; // onto the tokens. We would have parsed this expression the same way; // in either case: both the RHS of an init-capture and the RHS of an; // assignment expression are parsed as an initializer-clause, and in; // neither case can anything be added to the scope between the '[' and; // here.; //; // FIXME: This is horrible. Adding a mechanism to skip an expression; // would be much cleaner.; // FIXME: If there is a ',' before the next ']' or ':', we can skip to; // that instead. (And if we see a ':' with no matching '?', we can; // classify this as an Obj-C message send.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Integrability,message,message,22,// Check if this is a message send before we act on a possible init-capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Integrability,message,message,22,// This can only be a message send. We're done with disambiguation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:8,Performance,perform,performs,8,"// This performs any lvalue-to-rvalue conversions if necessary, which; // can affect what gets captured in the containing decl-context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:122,Availability,error,error,122,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:181,Availability,recover,recover,181,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:181,Safety,recover,recover,181,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:64,Deployability,update,update,64,"// Parse mutable-opt and/or constexpr-opt or consteval-opt, and update; // the DeclEndLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:7,Availability,error,error,7,// For error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Integrability,message,messages,13,// For error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:85,Availability,error,error,85,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:109,Availability,recover,recover,109,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:109,Safety,recover,recover,109,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:2,Security,Access,AccessSpecifier,2,/*AccessSpecifier=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:100,Modifiability,polymorphi,polymorphic,100,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:263,Modifiability,polymorphi,polymorphic,263,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:541,Testability,log,logic,541,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:991,Integrability,depend,dependent,991,"/// Parse a C++ pseudo-destructor expression after the base,; /// . or -> operator, and nested-name-specifier have already been; /// parsed. We're handling this fragment of the grammar:; ///; /// postfix-expression: [C++2a expr.post]; /// postfix-expression . template[opt] id-expression; /// postfix-expression -> template[opt] id-expression; ///; /// id-expression:; /// qualified-id; /// unqualified-id; ///; /// qualified-id:; /// nested-name-specifier template[opt] unqualified-id; ///; /// nested-name-specifier:; /// type-name ::; /// decltype-specifier :: FIXME: not implemented, but probably only; /// allowed in C++ grammar by accident; /// nested-name-specifier identifier ::; /// nested-name-specifier template[opt] simple-template-id ::; /// [...]; ///; /// unqualified-id:; /// ~ type-name; /// ~ decltype-specifier; /// [...]; ///; /// ... where the all but the last component of the nested-name-specifier; /// has already been parsed, and the base expression is not of a non-dependent; /// class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:728,Usability,simpl,simple-template-id,728,"/// Parse a C++ pseudo-destructor expression after the base,; /// . or -> operator, and nested-name-specifier have already been; /// parsed. We're handling this fragment of the grammar:; ///; /// postfix-expression: [C++2a expr.post]; /// postfix-expression . template[opt] id-expression; /// postfix-expression -> template[opt] id-expression; ///; /// id-expression:; /// qualified-id; /// unqualified-id; ///; /// qualified-id:; /// nested-name-specifier template[opt] unqualified-id; ///; /// nested-name-specifier:; /// type-name ::; /// decltype-specifier :: FIXME: not implemented, but probably only; /// allowed in C++ grammar by accident; /// nested-name-specifier identifier ::; /// nested-name-specifier template[opt] simple-template-id ::; /// [...]; ///; /// unqualified-id:; /// ~ type-name; /// ~ decltype-specifier; /// [...]; ///; /// ... where the all but the last component of the nested-name-specifier; /// has already been parsed, and the base expression is not of a non-dependent; /// class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:86,Usability,simpl,simple-template-id,86,"// If the last component of the (optional) nested-name-specifier is; // template[opt] simple-template-id, it has already been annotated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:324,Usability,simpl,simple-type-specifier,324,"/// ParseCXXTypeConstructExpression - Parse construction of a specified type.; /// Can be interpreted either as function-style casting (""int(x)""); /// or class type construction (""ClassType(x,y,z)""); /// or creation of a value-initialized type (""int()"").; /// See [C++ 5.2.3].; ///; /// postfix-expression: [C++ 5.2p1]; /// simple-type-specifier '(' expression-list[opt] ')'; /// [C++0x] simple-type-specifier braced-init-list; /// typename-specifier '(' expression-list[opt] ')'; /// [C++0x] typename-specifier braced-init-list; ///; /// In C++1z onwards, the type specifier can also be a template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:388,Usability,simpl,simple-type-specifier,388,"/// ParseCXXTypeConstructExpression - Parse construction of a specified type.; /// Can be interpreted either as function-style casting (""int(x)""); /// or class type construction (""ClassType(x,y,z)""); /// or creation of a value-initialized type (""int()"").; /// See [C++ 5.2.3].; ///; /// postfix-expression: [C++ 5.2p1]; /// simple-type-specifier '(' expression-list[opt] ')'; /// [C++0x] simple-type-specifier braced-init-list; /// typename-specifier '(' expression-list[opt] ')'; /// [C++0x] typename-specifier braced-init-list; ///; /// In C++1z onwards, the type specifier can also be a template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1000,Availability,error,error,1000,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1012,Availability,recover,recovered,1012,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1012,Safety,recover,recovered,1012,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:434,Usability,simpl,simple-asm-expr,434,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Usability,simpl,simple-asm-expr,3,// simple-asm-expr[opt],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:50,Modifiability,variab,variable,50,// This was probably an attempt to initialize the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:48,Usability,Simpl,Simple,48,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Usability,simpl,simple-type-specifier,155,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:188,Usability,simpl,simple-type-specifier,188,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:311,Usability,simpl,simple-template-id,311,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:860,Availability,error,errors,860,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1574,Availability,error,error,1574,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1357,Deployability,update,updated,1357,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:96,Integrability,rout,routine,96,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:304,Integrability,rout,routine,304,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1437,Integrability,rout,routine,1437,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1505,Performance,perform,performing,1505,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:622,Security,access,access,622,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:696,Security,access,accessed,696,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:782,Security,access,access,782,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,Integrability,inject,injected-class-name,16,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,Security,inject,injected-class-name,16,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Availability,error,errors,13,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Integrability,depend,dependent,46,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:231,Integrability,depend,dependent,231,"// We have something like t->getAs<T>(), where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:113,Integrability,rout,routine,113,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1116,Security,access,access,1116,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1190,Security,access,accessed,1190,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:38,Performance,perform,perform,38,"// We're past translation phase 6, so perform string literal concatenation; // before checking for """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:794,Availability,error,errors,794,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:553,Security,access,access,553,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:627,Security,access,accessed,627,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:716,Security,access,access,716,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1223,Usability,guid,guide,1223,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:53,Usability,guid,guide,53,// We have parsed a template-name naming a deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,Availability,recover,recover,87,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,Safety,recover,recover,87,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,Availability,recover,recover,378,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,Safety,recover,recover,378,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,Availability,recover,recovery,148,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,Safety,recover,recovery,148,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:157,Testability,log,logic,157,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:47,Usability,simpl,simple-template-id,47,// Parse the class-name (or template-name in a simple-template-id).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,Energy Efficiency,allocate,allocate,71,"/// ParseCXXNewExpression - Parse a C++ new-expression. New is used to allocate; /// memory in a typesafe manner and call constructors.; ///; /// This method is called to parse the new expression after the optional :: has; /// been already parsed. If the :: was present, ""UseGlobal"" is true and ""Start""; /// is its location. Otherwise, ""Start"" is the location of the 'new' token.; ///; /// new-expression:; /// '::'[opt] 'new' new-placement[opt] new-type-id; /// new-initializer[opt]; /// '::'[opt] 'new' new-placement[opt] '(' type-id ')'; /// new-initializer[opt]; ///; /// new-placement:; /// '(' expression-list ')'; ///; /// new-type-id:; /// type-specifier-seq new-declarator[opt]; /// [GNU] attributes type-specifier-seq new-declarator[opt]; ///; /// new-declarator:; /// ptr-operator new-declarator[opt]; /// direct-new-declarator; ///; /// new-initializer:; /// '(' expression-list[opt] ')'; /// [C++0x] braced-init-list; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:65,Integrability,wrap,wrapping,65,// Consume 'new'; // A '(' now can be a new-placement or the '(' wrapping the type-id in the; // second form of new-expression. It can't be a new-type-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Usability,simpl,simplified,22,"// A new-type-id is a simplified type-id, where essentially the; // direct-declarator is replaced by a direct-new-declarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:97,Energy Efficiency,allocate,allocated,97,"/// ParseCXXDeleteExpression - Parse a C++ delete-expression. Delete is used; /// to free memory allocated by new.; ///; /// This method is called to parse the 'delete' expression after the optional; /// '::' has been already parsed. If the '::' was present, ""UseGlobal"" is true; /// and ""Start"" is its location. Otherwise, ""Start"" is the location of the; /// 'delete' token.; ///; /// delete-expression:; /// '::'[opt] 'delete' cast-expression; /// '::'[opt] 'delete' '[' ']' cast-expression",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:658,Usability,simpl,simple-requirement,658,/// ParseRequiresExpression - Parse a C++2a requires-expression.; /// C++2a [expr.prim.req]p1; /// A requires-expression provides a concise way to express requirements on; /// template arguments. A requirement is one that can be checked by name; /// lookup (6.4) or by checking properties of types and expressions.; ///; /// requires-expression:; /// 'requires' requirement-parameter-list[opt] requirement-body; ///; /// requirement-parameter-list:; /// '(' parameter-declaration-clause[opt] ')'; ///; /// requirement-body:; /// '{' requirement-seq '}'; ///; /// requirement-seq:; /// requirement; /// requirement-seq requirement; ///; /// requirement:; /// simple-requirement; /// type-requirement; /// compound-requirement; /// nested-requirement,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:67,Integrability,Depend,Dependent,67,// Create a separate diagnostic pool for RequiresExprBodyDecl.; // Dependent diagnostics are attached to this Decl and non-depenedent; // diagnostics are surfaced after this parse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:59,Usability,simpl,simple-requirement,59,// requires (...) {; // ^ - a requires expression as a; // simple-requirement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:102,Usability,simpl,simple,102,// This might be 'typename T::value_type;' (a type requirement) or; // 'typename T::value_type{};' (a simple requirement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Usability,Simpl,Simple,3,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:45,Usability,simpl,simple,45,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:57,Usability,simpl,simple-requirement,57,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:45,Safety,avoid,avoid,45,// Don't emit an empty requires expr here to avoid confusing the user with; // other diagnostics quoting an empty requires expression they never; // wrote.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:603,Performance,cache,cached,603,"// We need to disambiguate a very ugly part of the C++ syntax:; //; // (T())x; - type-id; // (T())*x; - type-id; // (T())/x; - expression; // (T()); - expression; //; // The bad news is that we cannot use the specialized tentative parser, since; // it can only verify that the thing inside the parens can be parsed as; // type-id, it is not useful for determining the context past the parens.; //; // The good news is that the parser can disambiguate this part without; // making any unnecessary Action calls.; //; // It uses a scheme similar to parsing inline methods. The parenthesized; // tokens are cached, the context that follows is determined (possibly by; // parsing a cast-expression), and then we re-introduce the cached tokens; // into the token stream and parse them appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:724,Performance,cache,cached,724,"// We need to disambiguate a very ugly part of the C++ syntax:; //; // (T())x; - type-id; // (T())*x; - type-id; // (T())/x; - expression; // (T()); - expression; //; // The bad news is that we cannot use the specialized tentative parser, since; // it can only verify that the thing inside the parens can be parsed as; // type-id, it is not useful for determining the context past the parens.; //; // The good news is that the parser can disambiguate this part without; // making any unnecessary Action calls.; //; // It uses a scheme similar to parsing inline methods. The parenthesized; // tokens are cached, the context that follows is determined (possibly by; // parsing a cast-expression), and then we re-introduce the cached tokens; // into the token stream and parse them appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:41,Performance,cache,cached,41,// The current token should go after the cached tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Performance,cache,cached,46,// Drop the current token and bring the first cached one. It's the same token; // as when we entered this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:416,Testability,log,logic,416,"//===--- ParseHLSL.cpp - HLSL-specific parsing support --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the parsing logic for HLSL language features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:24,Modifiability,variab,variable,24,"// Only allow function, variable, record decls inside HLSLBuffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:113,Safety,avoid,avoid,113,// FIXME: HLSLSemantic is shared for Semantic and resource binding which is; // confusing. Need a better name to avoid misunderstanding. Issue; // https://github.com/llvm/llvm-project/issues/57882,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:24,Availability,error,error,24,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:96,Availability,recover,recover,96,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:96,Safety,recover,recover,96,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:103,Integrability,message,message-send,103,// Can't be a lambda-expression. Treat it as a designator.; // FIXME: Should we disambiguate against a message-send?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:1024,Integrability,message,message-args,1024,"/// ParseInitializerWithPotentialDesignator - Parse the 'initializer' production; /// checking to see if the token stream starts with a designator.; ///; /// C99:; ///; /// designation:; /// designator-list '='; /// [GNU] array-designator; /// [GNU] identifier ':'; ///; /// designator-list:; /// designator; /// designator-list designator; ///; /// designator:; /// array-designator; /// '.' identifier; ///; /// array-designator:; /// '[' constant-expression ']'; /// [GNU] '[' constant-expression '...' constant-expression ']'; ///; /// C++20:; ///; /// designated-initializer-list:; /// designated-initializer-clause; /// designated-initializer-list ',' designated-initializer-clause; ///; /// designated-initializer-clause:; /// designator brace-or-equal-initializer; ///; /// designator:; /// '.' identifier; ///; /// We allow the C99 syntax extensions in C++20, but do not allow the C++20; /// extension (a braced-init-list after the designator with no '=') in C99.; ///; /// NOTE: [OBC] allows '[ objc-receiver objc-message-args ]' as an; /// initializer (because it is an expression). We need to consider this case; /// when parsing array designators.; ///; /// \p CodeCompleteCB is called with Designation parsed so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:89,Integrability,message,message,89,"// Desig - This is initialized when we see our first designator. We may have; // an objc message send with no designator, so we don't want to create this; // eagerly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:58,Integrability,message,message,58,// We must have either an array designator now or an objc message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:269,Integrability,message,message,269,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:292,Integrability,message,message-expr,292,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:359,Integrability,message,message,359,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:495,Integrability,message,message,495,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:616,Integrability,message,message,616,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:59,Integrability,message,message,59,"// If Objective-C is enabled and this is a typename (class message; // send) or send to 'super', parse this as a message send; // expression. We handle C++ and C separately, since C++ requires; // much more complicated parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:113,Integrability,message,message,113,"// If Objective-C is enabled and this is a typename (class message; // send) or send to 'super', parse this as a message send; // expression. We handle C++ and C separately, since C++ requires; // much more complicated parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:47,Integrability,message,message,47,"// If the receiver was a type, we have a class message; parse; // the rest of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:80,Integrability,message,message,80,"// If the receiver was an expression, we still don't know; // whether we have a message send or an array designator; just; // adopt the expression for further analysis below.; // FIXME: potentially-potentially evaluated expression above?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:26,Integrability,message,message,26,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:75,Integrability,message,message,75,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:124,Integrability,message,message,124,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:28,Integrability,protocol,protocol,28,// Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:99,Integrability,message,message,99,// Fall through; we'll just parse the expression and; // (possibly) treat this like an Objective-C message send; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:268,Security,validat,validate,268,"// Parse the index expression, if we haven't already gotten one; // above (which can only happen in Objective-C++).; // Note that we parse this as an assignment expression, not a constant; // expression (allowing *=, =, etc) to handle the objc case. Sema needs; // to validate that the expression is a constant.; // FIXME: We also need to tell Sema that we're in a; // potentially-potentially evaluated context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:110,Integrability,message,message,110,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:147,Integrability,message,message,147,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:184,Integrability,message,message,184,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:205,Integrability,message,message,205,"// Okay, we're done with the designator sequence. We know that there must be; // at least one designator, because the only case we can get into this method; // without a designator is when we have an objc message send. That case is; // handled and returned from above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:230,Availability,error,error,230,"// We read some number of designators and found something that isn't an = or; // an initializer. If we have exactly one array designator, this; // is the GNU 'designation: array-designator' extension. Otherwise, it is a; // parse error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:30,Availability,recover,recover,30,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:48,Availability,error,error,48,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:309,Availability,error,error,309,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:333,Availability,recover,recover,333,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:441,Availability,error,error,441,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:30,Safety,recover,recover,30,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:333,Safety,recover,recover,333,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:6,Availability,error,error,6,// an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:443,Integrability,interface,interface,443,"//===--- ParseObjC.cpp - Objective C Parsing ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Objective-C portions of the Parser interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:239,Integrability,protocol,protocol-definition,239,/// ParseObjCAtDirectives - Handle parts of the external-declaration production:; /// external-declaration: [C99 6.9]; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] '@' 'end',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:14,Integrability,interface,interface,14,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,interface,interface-attributes,41,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,interface,interface,78,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:107,Integrability,interface,interface,107,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:138,Integrability,interface,interface,138,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:159,Integrability,interface,interface,159,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:242,Integrability,protocol,protocol-refs,242,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:311,Integrability,interface,interface-decl-list,311,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:365,Integrability,interface,interface,365,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:386,Integrability,interface,interface,386,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:472,Integrability,protocol,protocol-refs,472,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:501,Integrability,interface,interface-decl-list,501,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:624,Integrability,interface,interface-attributes,624,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:286,Modifiability,variab,variables,286,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,Integrability,interface,interface,8,"// the ""interface"" identifier; // Code completion after '@interface'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Integrability,interface,interface,58,"// the ""interface"" identifier; // Code completion after '@interface'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,Integrability,protocol,protocol-refs,46,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:114,Integrability,Protocol,ProtocolIdents,114,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:150,Integrability,protocol,protocol,150,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:52,Availability,error,error,52,"// For ObjC2, the category name is optional (not an error).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:34,Integrability,protocol,protocol,34,"// Next, we need to check for any protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Integrability,interface,interface,17,// Parse a class interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,protocol,protocol,40,// Type arguments for the superclass or protocol conformances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:34,Integrability,protocol,protocol,34,"// Next, we need to check for any protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,Integrability,protocol,protocols,25,// We already parsed the protocols named when we thought we had a; // type parameter list. Translate them into actual protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:118,Integrability,protocol,protocol,118,// We already parsed the protocols named when we thought we had a; // type parameter list. Translate them into actual protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:95,Integrability,protocol,protocol,95,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:130,Integrability,protocol,protocol,130,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:576,Integrability,protocol,protocolIdents,576,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:674,Integrability,protocol,protocol,674,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:33,Integrability,protocol,protocol,33,"// Local function to ""flush"" the protocol identifiers, turning them into; // type parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:75,Integrability,protocol,protocol,75,"// Once we've seen a variance specific , we know this is not a; // list of protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,protocol,protocol,78,"// Up until now, we have been queuing up parameters because they; // might be protocol references. Turn them into parameters now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:26,Integrability,protocol,protocol,26,"// FIXME: If these aren't protocol references, we'll need different; // completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Availability,recover,recovery,17,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Safety,recover,recovery,17,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Integrability,protocol,protocol,58,"// Once we've seen a bound, we know this is not a list of protocol; // references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,protocol,protocol,78,"// Up until now, we have been queuing up parameters because they; // might be protocol references. Turn them into parameters now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:28,Integrability,protocol,protocol,28,"// If this could still be a protocol list, just capture the identifier.; // We don't want to turn it into a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:238,Integrability,protocol,protocol-refs,238,// A type parameter list must be followed by either a ':' (indicating the; // presence of a superclass) or a '(' (indicating that this is a category; // or extension). This disambiguates between an objc-type-parameter-list; // and a objc-protocol-refs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:117,Integrability,protocol,protocol,117,// Returning null indicates that we don't have a type parameter list.; // The results the caller needs to handle the protocol references are; // captured in the reference parameters already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:59,Integrability,protocol,protocol,59,// We have a type parameter list that looks like a list of protocol; // references. Turn that parameter list into type parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:99,Integrability,protocol,protocol,99,// Clear out the angle locations; they're used by the caller to indicate; // whether there are any protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Usability,Clear,Clear,3,// Clear out the angle locations; they're used by the caller to indicate; // whether there are any protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,interface,interface-decl-list,9,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,interface,interface-decl-list,51,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:108,Integrability,interface,interface-decl-list,108,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:170,Integrability,interface,interface-decl-list,170,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:222,Integrability,interface,interface-decl-list,222,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:264,Integrability,interface,interface-decl-list,264,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:32,Availability,error,error,32,// We didn't find a semi and we error'ed out. Skip until a ';' or '@'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,interface,interface,41,// Code completion within an Objective-C interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:144,Integrability,interface,interfaces,144,"// Since we call ParseDeclarationOrFunctionDefinition() instead of; // ParseExternalDeclaration() below (so that this doesn't parse nested; // @interfaces), this needs to duplicate some code from the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Integrability,interface,interface,30,"// If we see something like '@interface' that's only allowed at the top; // level, bail out as if we saw an '@end'. We'll diagnose this below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:130,Availability,error,errors,130,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,protocol,protocol,42,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:206,Integrability,interface,interface,206,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,Integrability,protocol,protocols,25,// This is only valid on protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Deployability,Install,Install,3,// Install the property declarator into interfaceDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,interface,interfaceDecl,40,// Install the property declarator into interfaceDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:177,Availability,error,error,177,"// We break out of the big loop in 3 cases: when we see @end or when we see; // top-level ObjC keyword or EOF. In the former case, eat the @end. In the; // later cases, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,interface,interface,51,// Insert collected methods declarations into the @interface object.; // This passes in an invalid SourceLocation for AtEndLoc when EOF is hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,Availability,redundant,redundant,13,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,Safety,redund,redundant,13,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:38,Integrability,rout,routine,38,/// ParseObjCTypeQualifierList - This routine parses the objective-c's type; /// qualifier list and builds their bitmask representation in the input; /// argument.; ///; /// objc-type-qualifiers:; /// objc-type-qualifier; /// objc-type-qualifiers objc-type-qualifier; ///; /// objc-type-qualifier:; /// 'in'; /// 'out'; /// 'inout'; /// 'oneway'; /// 'bycopy'; /// 'byref'; /// 'nonnull'; /// 'nullable'; /// 'null_unspecified'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Availability,redundant,redundant,19,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Safety,redund,redundant,19,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,Availability,error,error,89,"// Otherwise, we found *something*, but didn't get a ')' in the right; // place. Emit an error then return what we have as the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-refs,9,/// objc-protocol-refs:; /// '<' identifier-list '>'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:23,Integrability,protocol,protocols,23,// Convert the list of protocols identifiers into a list of protocol decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:60,Integrability,protocol,protocol,60,// Convert the list of protocols identifiers into a list of protocol decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,protocol,protocol,40,"/// Parse Objective-C type arguments or protocol qualifiers.; ///; /// objc-type-arguments:; /// '<' type-name '...'[opt] (',' type-name '...'[opt])* '>'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:114,Integrability,protocol,protocols,114,"// Whether all of the elements we've parsed thus far are single; // identifiers, which might be types or might be protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,Integrability,protocol,protocols,89,"// If we parsed an identifier list, semantic analysis sorts out; // whether it refers to protocols or to type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:168,Integrability,protocol,protocol,168,"// We parsed an identifier list but stumbled into non single identifiers, this; // means we might (a) check that what we already parsed is a legitimate type; // (not a protocol or unknown type) and (b) parse the remaining ones, which; // must all be type args.; // Convert the identifiers into type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,protocol,protocols,42,// Diagnose the mix between type args and protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Integrability,protocol,protocol,103,"// An Objective-C object pointer followed by type arguments; // can then be followed again by a set of protocol references, e.g.,; // \c NSArray<NSView><NSTextDelegate>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:115,Integrability,protocol,protocol,115,"// If we aren't consuming the last token, the prior '>' is still hanging; // there. Consume it before we parse the protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:28,Integrability,protocol,protocol,28,// Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:24,Modifiability,variab,variables,24,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Modifiability,variab,variable-decl-list,58,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:110,Modifiability,variab,variable-decl-list,110,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:175,Modifiability,variab,variable-decl,175,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:221,Modifiability,variab,variable-decl-list,221,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:280,Modifiability,variab,variable-decl-list,280,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:313,Modifiability,variab,variable-decl,313,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:350,Modifiability,variab,variable-decl-list,350,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:414,Modifiability,variab,variable-decl-list,414,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:558,Modifiability,variab,variable-decl,558,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:60,Modifiability,variab,variables,60,"// While we still have something to read, read the instance variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:55,Modifiability,variab,variable-decl,55,// Each iteration of this loop reads one objc-instance-variable-decl.; // Check for extraneous top-level semicolon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:165,Modifiability,variab,variables,165,// This needs to duplicate a small amount of code from; // ParseStructUnionBody() for things that should work in both; // C struct and in Objective-C class instance variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Deployability,Install,Install,3,// Install the declarator into the interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:35,Integrability,interface,interface,35,// Install the declarator into the interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-declaration,9,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,protocol,protocol-definition,41,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:71,Integrability,protocol,protocol-forward-reference,71,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:113,Integrability,protocol,protocol-definition,113,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:141,Integrability,protocol,protocol,141,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:171,Integrability,protocol,protocol-refs,171,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:200,Integrability,interface,interface-decl-list,200,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:246,Integrability,protocol,protocol-forward-reference,246,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:281,Integrability,protocol,protocol,281,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:323,Integrability,protocol,protocol,323,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:371,Integrability,protocol,protocol,371,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:410,Integrability,interface,interface-decl-list,410,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:499,Integrability,protocol,protocol-refs,499,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,Integrability,protocol,protocol,8,"// the ""protocol"" identifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,Integrability,protocol,protocol,11,"// missing protocol name.; // Save the protocol name, then consume it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:39,Integrability,protocol,protocol,39,"// missing protocol name.; // Save the protocol name, then consume it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Integrability,protocol,protocol,30,// forward declaration of one protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:43,Integrability,protocol,protocol,43,"// Last, and definitely not least, parse a protocol declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:232,Modifiability,variab,variables,232,/// objc-implementation:; /// objc-class-implementation-prologue; /// objc-category-implementation-prologue; ///; /// objc-class-implementation-prologue:; /// @implementation identifier objc-superclass[opt]; /// objc-class-instance-variables[opt]; ///; /// objc-category-implementation-prologue:; /// @implementation identifier ( identifier ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:47,Integrability,protocol,protocol,47,// Neither a type parameter list nor a list of protocol references is; // permitted here. Parse and diagnose them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Availability,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Safety,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Availability,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Safety,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:23,Performance,cache,cached,23,/// Clear and free the cached objc methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:4,Usability,Clear,Clear,4,/// Clear and free the cached objc methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,synchroniz,synchronized-statement,9,/// objc-synchronized-statement:; /// @synchronized '(' expression ')' compound-statement; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:39,Integrability,synchroniz,synchronized,39,/// objc-synchronized-statement:; /// @synchronized '(' expression ')' compound-statement; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,Integrability,synchroniz,synchronized,11,// consume synchronized,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:14,Integrability,synchroniz,synchronized,14,// Check the @synchronized operand now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:36,Availability,error,error,36,"// If there was a semantic or parse error earlier with the; // operand, fail now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:609,Availability,error,error,609,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:43,Integrability,message,message,43,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:72,Integrability,rout,routine,72,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:105,Integrability,message,message,105,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:198,Integrability,rout,routine,198,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:857,Usability,simpl,simple-type-specifier,857,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:120,Availability,recover,recovery,120,"// objc-receiver:; // expression; // Make sure any typos in the receiver are corrected or diagnosed, so that; // proper recovery can happen. FIXME: Perhaps filter the corrected expr to; // only the things that are valid ObjC receivers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:120,Safety,recover,recovery,120,"// objc-receiver:; // expression; // Make sure any typos in the receiver are corrected or diagnosed, so that; // proper recovery can happen. FIXME: Perhaps filter the corrected expr to; // only the things that are valid ObjC receivers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:45,Usability,simpl,simple-type-specifier,45,// objc-receiver:; // typename-specifier; // simple-type-specifier; // expression (that starts with one of the above),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:175,Usability,simpl,simple-type-specifier,175,"// If we see an opening parentheses at this point, we are; // actually parsing an expression that starts with a; // function-style cast, e.g.,; //; // postfix-expression:; // simple-type-specifier ( expression-list [opt] ); // typename-specifier ( expression-list [opt] ); //; // Parse the remainder of this case, then the (optional); // postfix-expression suffix, followed by the (optional); // right-hand side of the binary expression. We have an; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Integrability,message,message,19,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:148,Integrability,message,message,148,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:37,Usability,simpl,simple-type-specifier,37,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:81,Integrability,message,message,81,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:158,Integrability,rout,routine,158,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:210,Integrability,message,message-send,210,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:127,Safety,avoid,avoid,127,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Usability,simpl,simplified,103,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,message,message-expr,9,/// objc-message-expr:; /// '[' objc-receiver objc-message-args ']'; ///; /// objc-receiver: [C]; /// 'super'; /// expression; /// class-name; /// type-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,message,message-args,51,/// objc-message-expr:; /// '[' objc-receiver objc-message-args ']'; ///; /// objc-receiver: [C]; /// 'super'; /// expression; /// class-name; /// type-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,Integrability,protocol,protocol,46,// the type name; // Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,message,message,42,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Integrability,rout,routine,103,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:141,Integrability,message,messages,141,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:192,Integrability,message,messages,192,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:633,Integrability,message,message,633,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:686,Integrability,message,message,686,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:751,Integrability,message,message,751,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:832,Integrability,message,message-args,832,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap the sub-expression in a parenthesized expression, to distinguish; // a boxed expression from a literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-expression,9,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:36,Integrability,protocol,protocol,36,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:47,Integrability,protocol,protocol-name,47,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:31,Availability,error,error,31,"// MCDecl might be null due to error in method or c-function prototype, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:18,Availability,error,error,18,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:49,Performance,cache,cached,49,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:86,Performance,cache,cached,86,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:215,Safety,avoid,avoided,215,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:416,Testability,log,logic,416,"//===--- ParseOpenACC.cpp - OpenACC-specific parsing support --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the parsing logic for OpenACC language features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:29,Modifiability,extend,extended,29,"// An enum that contains the extended 'partial' parsed variants. This type; // should never escape the initial parse functionality, but is useful for; // simplifying the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:154,Usability,simpl,simplifying,154,"// An enum that contains the extended 'partial' parsed variants. This type; // should never escape the initial parse functionality, but is useful for; // simplifying the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:130,Availability,error,error,130,"/// Used for cases where we have a token we want to check against an; /// 'identifier-like' token, but don't want to give awkward error messages in; /// cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:136,Integrability,message,messages,136,"/// Used for cases where we have a token we want to check against an; /// 'identifier-like' token, but don't want to give awkward error messages in; /// cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Availability,recover,recover,103,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Safety,recover,recover,103,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:97,Availability,error,error,97,"/// Used for cases where we expect an identifier-like token, but don't want to; /// give awkward error messages in cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Integrability,message,messages,103,"/// Used for cases where we expect an identifier-like token, but don't want to; /// give awkward error messages in cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:39,Deployability,update,update,39,// #pragma acc atomic is equivilent to update:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:44,Modifiability,extend,extended,44,"// OpenACCDirectiveKindEx is meant to be an extended list; // over OpenACCDirectiveKind, so any value below Invalid is one of the; // OpenACCDirectiveKind values. This switch takes care of all of the extra; // parsing required for the Extended values. At the end of this block,; // ExDirKind can be assumed to be a valid OpenACCDirectiveKind, so we can; // immediately cast it and use it as that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:235,Modifiability,Extend,Extended,235,"// OpenACCDirectiveKindEx is meant to be an extended list; // over OpenACCDirectiveKind, so any value below Invalid is one of the; // OpenACCDirectiveKind values. This switch takes care of all of the extra; // parsing required for the Extended values. At the end of this block,; // ExDirKind can be assumed to be a valid OpenACCDirectiveKind, so we can; // immediately cast it and use it as that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:19,Usability,clear,clear,19,"// FIXME: It isn't clear if the spec saying 'condition' means the same as; // it does in an if/while/etc (See ParseCXXCondition), however as it was; // written with Fortran/C in mind, we're going to assume it just means an; // 'expression evaluating to boolean'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:50,Usability,simpl,simplify,50,"// namespace; // OpenACC 3.3, section 1.7:; // To simplify the specification and convey appropriate constraint information,; // a pqr-list is a comma-separated list of pdr items. The one exception is a; // clause-list, which is a list of one or more clauses optionally separated by; // commas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Availability,Recover,Recovering,3,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:79,Availability,error,error,79,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Safety,Recover,Recovering,3,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:59,Integrability,depend,dependent,59,"// FIXME: this is required to be an integer expression (or dependent), so we; // should ensure that is the case by passing this to SEMA here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:84,Deployability,update,update,84,"// The 'self' clause is a var-list instead of a 'condition' in the case of; // the 'update' clause, so we have to handle it here. U se an assert to; // make sure we get the right differentiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:138,Testability,assert,assert,138,"// The 'self' clause is a var-list instead of a 'condition' in the case of; // the 'update' clause, so we have to handle it here. U se an assert to; // make sure we get the right differentiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:152,Performance,queue,queues,152,"/// OpenACC 3.3, section 2.16:; /// In this section and throughout the specification, the term wait-argument; /// means:; /// [ devnum : int-expr : ] [ queues : ] async-argument-list",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:5,Performance,queue,queues,5,// [ queues : ],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:11,Performance,queue,queues,11,// Consume queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:318,Safety,avoid,avoid,318,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:273,Usability,simpl,simply,273,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:104,Modifiability,variab,variable,104,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:149,Modifiability,variab,variable,149,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:273,Modifiability,variab,variable,273,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:68,Performance,cache,cache,68,"/// OpenACC 3.3, section 2.10:; /// In C and C++, the syntax of the cache directive is:; ///; /// #pragma acc cache ([readonly:]var-list) new-line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:110,Performance,cache,cache,110,"/// OpenACC 3.3, section 2.10:; /// In C and C++, the syntax of the cache directive is:; ///; /// #pragma acc cache ([readonly:]var-list) new-line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:66,Modifiability,variab,variable,66,"// The VarList is an optional `readonly:` followed by a list of a variable; // specifications. Consume something that looks like a 'tag', and diagnose if; // it isn't 'readonly'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:188,Modifiability,extend,extended,188,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:47,Performance,cache,cache,47,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:99,Usability,simpl,simple,99,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:136,Usability,simpl,simple,136,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Integrability,Rout,Routine,3,"// Routine has an optional paren-wrapped name of a function in the local; // scope. We parse the name, emitting any diagnostics",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:33,Integrability,wrap,wrapped,33,"// Routine has an optional paren-wrapped name of a function in the local; // scope. We parse the name, emitting any diagnostics",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,Availability,recover,recover,76,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:10,Integrability,rout,routine,10,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,Safety,recover,recover,76,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,Availability,recover,recover,52,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:65,Availability,failure,failures,65,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,Safety,recover,recover,52,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:33,Integrability,wrap,wrapped,33,// OpenACC has an optional paren-wrapped 'wait-argument'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:42,Availability,error,error,42,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Performance,Cache,Cache,3,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:37,Modifiability,extend,extended,37,// namespace; // Map token string to extended OMP token kind that are; // OpenMPDirectiveKind + OpenMPDirectiveKindEx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:18,Modifiability,variab,variable,18,// Add the mapper variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,Availability,error,error,38,"// If anything went wrong we issue an error or warning and then skip the rest; // of the selector. However, commas are ambiguous so we look for the nesting; // of parentheses here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,Availability,error,error,38,"// If anything went wrong we issue an error or warning and then skip the rest; // of the set. However, commas are ambiguous so we look for the nesting; // of braces here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:179,Performance,Perform,Perform,179,// Merge the parent/outer trait info into the one we just parsed and diagnose; // problems.; // TODO: Keep some source location in the TI to provide better diagnostics.; // TODO: Perform some kind of equivalence check on the condition and score; // expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:63,Availability,error,error,63,"/// <clause> [clause[ [,] clause] ... ]; ///; /// clauses: for error directive; /// 'at' '(' compilation | execution ')'; /// 'severity' '(' fatal | warning ')'; /// 'message' '(' msg-string ')'; /// ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:167,Integrability,message,message,167,"/// <clause> [clause[ [,] clause] ... ]; ///; /// clauses: for error directive; /// 'at' '(' compilation | execution ')'; /// 'severity' '(' fatal | warning ')'; /// 'message' '(' msg-string ')'; /// ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:15,Usability,simpl,simple,15,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' '); ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' '); ///; /// device_type-clause:; /// 'device_type' '(' 'host' | 'nohost' | 'any' )',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:182,Energy Efficiency,allocate,allocate-directive,182,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:228,Energy Efficiency,allocate,allocate,228,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:129,Modifiability,variab,variable-list,129,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:245,Modifiability,variab,variable-list,245,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:122,Usability,simpl,simple-variable-list,122,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:238,Usability,simpl,simple-variable-list,238,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:54,Security,access,accessible,54,// TODO Track the selector locations in a way that is accessible here; // to improve the diagnostic location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1062,Availability,error,error,1062,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1898,Availability,mask,masked,1898,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1923,Availability,mask,masked,1923,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1447,Deployability,update,update,1447,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:196,Energy Efficiency,allocate,allocate-directive,196,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:242,Energy Efficiency,allocate,allocate,242,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:143,Modifiability,variab,variable-list,143,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:259,Modifiability,variab,variable-list,259,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:136,Usability,simpl,simple-variable-list,136,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:252,Usability,simpl,simple-variable-list,252,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:54,Security,access,accessible,54,// TODO Track the selector locations in a way that is accessible here; // to improve the diagnostic location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Integrability,depend,depend,10,"// If the depend or doacross clause is specified, the ordered construct; // is a stand-alone directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:34,Modifiability,variab,variable-list,34,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Usability,simpl,simple,10,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:27,Usability,simpl,simple-variable-list,27,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:479,Deployability,update,update-clause,479,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:917,Deployability,release,release-clause,917,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:335,Energy Efficiency,schedul,schedule-clause,335,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:860,Energy Efficiency,allocate,allocate-clause,860,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:102,Safety,safe,safelen-clause,102,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1437,Availability,error,error,1437,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1017,Energy Efficiency,allocate,allocate,1017,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1484,Integrability,message,message,1484,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:156,Safety,safe,safelen,156,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:390,Availability,error,error,390,"// OpenMP [2.14.3.1, Restrictions]; // Only a single default clause may be specified on a parallel, task or; // teams directive.; // OpenMP [2.5, parallel Construct, Restrictions]; // At most one proc_bind clause can appear on the directive.; // OpenMP [5.0, Requires directive, Restrictions]; // At most one atomic_default_mem_order clause can appear; // on the directive; // OpenMP [5.1, error directive, Restrictions]; // At most one at clause can appear on the directive; // At most one severity clause can appear on the directive; // OpenMP 5.1, 2.11.7 loop Construct, Restrictions.; // At most one bind clause can appear on a loop directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:51,Energy Efficiency,schedul,schedule,51,"// OpenMP [2.7.1, Restrictions, p. 3]; // Only one schedule clause can appear on a loop directive.; // OpenMP 4.5 [2.10.4, Restrictions, p. 106]; // At most one defaultmap clause can appear on the directive.; // OpenMP 5.0 [2.12.5, target construct, Restrictions]; // At most one device clause can appear on the directive.; // OpenMP 5.1 [2.11.3, order clause, Restrictions]; // At most one order clause may appear on a construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:11,Usability,simpl,simple,11,/// Parses simple expression in parens for single-expression clauses of OpenMP; /// constructs.; /// \param RLoc Returned location of right paren.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:86,Safety,safe,safelen,86,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:364,Safety,safe,safelen-clause,364,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:386,Safety,safe,safelen,386,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:13,Modifiability,variab,variable,13,// Parse the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:332,Deployability,update,update-clause,332,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:353,Deployability,update,update,353,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:15,Usability,simpl,simple,15,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:94,Energy Efficiency,schedul,schedule,94,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:134,Energy Efficiency,schedul,schedule-clause,134,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:157,Energy Efficiency,schedul,schedule,157,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:45,Modifiability,extend,extended,45,// Only target executable directives support extended device construct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:167,Deployability,release,release,167,"/// Parse map-type in map clause.; /// map([ [map-type-modifier[,] [map-type-modifier[,] ...] map-type : ] list); /// where, map-type ::= to | from | tofrom | alloc | release | delete",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:11,Usability,simpl,simple,11,/// Parses simple expression in parens for single-expression clauses of OpenMP; /// constructs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:90,Integrability,depend,depend,90,// Currently the only reserved locator is 'omp_all_memory' which is only; // allowed on a depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:19,Integrability,depend,dependence,19,"// Handle optional dependence modifier.; // iterator(iterators-definition); // where iterators-definition is iterator-specifier [,; // iterators-definition ]; // where iterator-specifier is [ iterator-type ] identifier =; // range-specification",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Integrability,depend,dependency,10,// Handle dependency type for depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:30,Integrability,depend,depend,30,// Handle dependency type for depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:26,Integrability,depend,depend,26,// Special processing for depend(source) clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:39,Modifiability,variab,variables,39,"// Colon not found, parse only list of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:9,Modifiability,variab,variable,9,// Parse variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:48,Integrability,depend,depend,48,// Exit from scope when the iterator is used in depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1160,Deployability,release,release,1160,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1616,Energy Efficiency,allocate,allocate-clause,1616,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1639,Energy Efficiency,allocate,allocate,1639,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:947,Integrability,depend,depend-clause,947,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:968,Integrability,depend,depend,968,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:44,Performance,optimiz,optimize,44,"/// PragmaOptimizeHandler - ""\#pragma clang optimize on/off"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:33,Deployability,install,installed,33,// Remove the pragma handlers we installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:127,Availability,error,errors,127,"// Pragma handling failed, and has been diagnosed. Slurp up the tokens; // until eof (really end of line) to prevent follow-on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:49,Usability,undo,undocumented,49,"// ,; // Ignore ""long"" and ""short"".; // They are undocumented, but widely used, section attributes which appear; // to do nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:3,Security,Validat,Validate,3,// Validate the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:34,Performance,scalab,scalable,34,// Look for vectorize_width(fixed|scalable),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:23,Availability,error,error,23,// Tokens following an error in an ill-formed constant expression will; // remain in the token stream and must be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:23,Availability,error,error,23,// Tokens following an error in an ill-formed constant expression will; // remain in the token stream and must be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:53,Energy Efficiency,power,power,53,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:132,Energy Efficiency,power,power,132,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:202,Energy Efficiency,power,power,202,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:147,Performance,cache,cache,147,"// For each identifier token, insert into the token stream a; // annot_pragma_unused token followed by the identifier token.; // This allows us to cache a ""#pragma unused"" that occurs inside an inline; // C++ member function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:97,Modifiability,inherit,inheritance,97,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:286,Modifiability,inherit,inheritance-model,286,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:345,Modifiability,inherit,inheritance-model,345,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:27,Usability,Simpl,Simply,27,/// Handle all MS pragmas. Simply forwards the tokens after inserting; /// an annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Energy Efficiency,allocate,allocate,11,// We must allocate this array with new because EnterTokenStream is going to; // delete it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:383,Availability,error,error,383,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:301,Safety,detect,detects,301,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:17,Performance,optimiz,optimize,17,// #pragma clang optimize off; // #pragma clang optimize on,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:48,Performance,optimiz,optimize,48,// #pragma clang optimize off; // #pragma clang optimize on,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:484,Deployability,pipeline,pipeline,484,"/// Handle the \#pragma clang loop directive.; /// #pragma clang 'loop' loop-hints; ///; /// loop-hints:; /// loop-hint loop-hints[opt]; ///; /// loop-hint:; /// 'vectorize' '(' loop-hint-keyword ')'; /// 'interleave' '(' loop-hint-keyword ')'; /// 'unroll' '(' unroll-hint-keyword ')'; /// 'vectorize_predicate' '(' loop-hint-keyword ')'; /// 'vectorize_width' '(' loop-hint-value ')'; /// 'interleave_count' '(' loop-hint-value ')'; /// 'unroll_count' '(' loop-hint-value ')'; /// 'pipeline' '(' disable ')'; /// 'pipeline_initiation_interval' '(' loop-hint-value ')'; ///; /// loop-hint-keyword:; /// 'enable'; /// 'disable'; /// 'assume_safety'; ///; /// unroll-hint-keyword:; /// 'enable'; /// 'disable'; /// 'full'; ///; /// loop-hint-value:; /// constant-expression; ///; /// Specifying vectorize(enable) or vectorize_width(_value_) instructs llvm to; /// try vectorizing the instructions of the loop it precedes. Specifying; /// interleave(enable) or interleave_count(_value_) instructs llvm to try; /// interleaving multiple iterations of the loop it precedes. The width of the; /// vector instructions is specified by vectorize_width() and the number of; /// interleaved loop iterations is specified by interleave_count(). Specifying a; /// value of 1 effectively disables vectorization/interleaving, even if it is; /// possible and profitable, and 0 is invalid. The loop vectorizer currently; /// only works on inner loops.; ///; /// The unroll and unroll_count directives control the concatenation; /// unroller. Specifying unroll(enable) instructs llvm to unroll the loop; /// completely if the trip count is known at compile time and unroll partially; /// if the trip count is not known. Specifying unroll(full) is similar to; /// unroll(enable) but will unroll the loop only if the trip count is known at; /// compile time. Specifying unroll(disable) disables unrolling for the; /// loop. Specifying unroll_count(_value_) instructs llvm to try to unroll the; /// loop the number of time",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Performance,optimiz,optimization,11,// Lex the optimization option and verify it is an identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:27,Performance,optimiz,optimization,27,"/// Handle the loop unroll optimization pragmas.; /// #pragma unroll; /// #pragma unroll unroll-hint-value; /// #pragma unroll '(' unroll-hint-value ')'; /// #pragma nounroll; /// #pragma unroll_and_jam; /// #pragma unroll_and_jam unroll-hint-value; /// #pragma unroll_and_jam '(' unroll-hint-value ')'; /// #pragma nounroll_and_jam; ///; /// unroll-hint-value:; /// constant-expression; ///; /// Loop unrolling hints can be specified with '#pragma unroll' or; /// '#pragma nounroll'. '#pragma unroll' can take a numeric argument optionally; /// contained in parentheses. With no argument the directive instructs llvm to; /// try to unroll the loop completely. A positive integer argument can be; /// specified to indicate the number of times the loop should be unrolled. To; /// maximize compatibility with other compilers the unroll count argument can be; /// specified with or without parentheses. Specifying, '#pragma nounroll'; /// disables unrolling of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Performance,optimiz,optimize,11,"// #pragma optimize(""gsty"", on|off)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:415,Integrability,interface,interfaces,415,"//===--- Parser.cpp - C Language Family Parser ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:65,Availability,error,error,65,"// We can't display the parentheses, so just dig the; // warning/error and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Detect,Detect,3,// Detect common single-character typos and resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:44,Usability,resume,resume,44,// Detect common single-character typos and resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Availability,Recover,Recover,18,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Safety,Recover,Recover,18,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Availability,Error,Error,85,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:91,Availability,recover,recovery,91,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:91,Safety,recover,recovery,91,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:185,Safety,detect,detected,185,"// Important special case: The caller has given up and just wants us to; // skip the rest of the file. Do this without recursing, since we can; // get here precisely because the caller detected too much recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Performance,cache,cache,18,// Free the scope cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:38,Deployability,Install,Install,38,// Create the translation unit scope. Install it as the current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:372,Availability,error,error,372,"/// Parse the first top-level declaration in a translation unit.; ///; /// translation-unit:; /// [C] external-declaration; /// [C] translation-unit external-declaration; /// [C++] top-level-declaration-seq[opt]; /// [C++20] global-module-fragment[opt] module-declaration; /// top-level-declaration-seq[opt] private-module-fragment[opt]; ///; /// Note that in C, it is an error if there is no first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:62,Availability,error,error,62,"// An empty Result might mean a line with ';' or some parsing error, ignore; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:436,Integrability,protocol,protocol-definition,436,"/// ParseExternalDeclaration:; ///; /// The `Attrs` that are passed in are C++11 attributes and appertain to the; /// declaration.; ///; /// external-declaration: [C99 6.9], declaration: [C++ dcl.dcl]; /// function-definition; /// declaration; /// [GNU] asm-definition; /// [GNU] __extension__ external-declaration; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] @end; /// [C++] linkage-specification; /// [GNU] asm-definition:; /// simple-asm-expr ';'; /// [C++11] empty-declaration; /// [C++11] attribute-declaration; ///; /// [C++11] empty-declaration:; /// ';'; ///; /// [C++0x/GNU] 'extern' 'template' declaration; ///; /// [C++20] module-import-declaration; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:573,Usability,simpl,simple-asm-expr,573,"/// ParseExternalDeclaration:; ///; /// The `Attrs` that are passed in are C++11 attributes and appertain to the; /// declaration.; ///; /// external-declaration: [C99 6.9], declaration: [C++ dcl.dcl]; /// function-definition; /// declaration; /// [GNU] asm-definition; /// [GNU] __extension__ external-declaration; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] @end; /// [C++] linkage-specification; /// [GNU] asm-definition:; /// simple-asm-expr ';'; /// [C++11] empty-declaration; /// [C++11] attribute-declaration; ///; /// [C++11] empty-declaration:; /// ';'; ///; /// [C++0x/GNU] 'extern' 'template' declaration; ///; /// [C++20] module-import-declaration; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Integrability,rout,routine,8,"// This routine returns a DeclGroup, if the thing we parsed only contains a; // single decl, convert it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:731,Energy Efficiency,allocate,allocate-directive,731,"/// Parse either a function-definition or a declaration. We can't tell which; /// we have until we read up to the compound-statement in function-definition.; /// TemplateParams, if non-NULL, provides the template parameters when we're; /// parsing a C++ template-declaration.; ///; /// function-definition: [C99 6.9.1]; /// decl-specs declarator declaration-list[opt] compound-statement; /// [C90] function-definition: [C99 6.7.1] - implicit int result; /// [C90] decl-specs[opt] declarator declaration-list[opt] compound-statement; ///; /// declaration: [C99 6.7]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [!C99] init-declarator-list ';' [TODO: warn in c99 mode]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:72,Usability,simpl,simply,72,"// Because we assume that the DeclSpec has not yet been initialised, we simply; // overwrite the source range and attribute the provided leading declspec; // attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:43,Integrability,interface,interfaces,43,"// ObjC2 allows prefix attributes on class interfaces and protocols.; // FIXME: This still needs better diagnostics. We should only accept; // attributes here, no types, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:58,Integrability,protocol,protocols,58,"// ObjC2 allows prefix attributes on class interfaces and protocols.; // FIXME: This still needs better diagnostics. We should only accept; // attributes here, no types, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:73,Safety,safe,safe,73,"// Break out of the ParsingDeclSpec context, too. This const_cast is; // safe because we're always the sole owner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:16,Availability,error,error,16,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:151,Usability,clear,clear,151,"// C99 6.9.1p6: 'each declaration in the declaration list shall have at; // least one declarator'.; // NOTE: GCC just makes this an ext-warn. It's not clear what it does with; // the declarations though. It's trivial to ignore them, really hard to do; // anything else with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';') or; // an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,Availability,recover,recover,13,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,Safety,recover,recover,13,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:35,Usability,simpl,simple-asm-expr,35,/// ParseSimpleAsm; ///; /// [GNU] simple-asm-expr:; /// 'asm' '(' asm-string-literal ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:80,Performance,cache,cached,80,// Push the current token back into the token stream (or revert it if it is; // cached) and use an annotation scope token for current token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace them; // with the annotation token. We don't need to do this if we've; // just reverted back to a prior state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:496,Integrability,depend,dependent,496,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:335,Performance,perform,perform,335,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:415,Performance,perform,performed,415,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:41,Testability,log,logic,41,// FIXME: Move the tentative declaration logic into ClassifyName so we can; // typo-correct to tentatively-declared identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,Availability,recover,recover,134,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:49,Performance,perform,perform,49,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,Safety,recover,recover,134,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:250,Availability,error,error,250,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:256,Availability,recover,recovery,256,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:256,Safety,recover,recovery,256,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:107,Integrability,protocol,protocol-qualified,107,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:77,Modifiability,parameteriz,parameterized,77,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1107,Availability,error,error,1107,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1165,Availability,error,error,1165,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:391,Energy Efficiency,efficient,efficient,391,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1148,Integrability,rout,routine,1148,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:336,Usability,simpl,simplifies,336,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:215,Usability,simpl,simple-template-id,215,"// Parse a C++ typename-specifier, e.g., ""typename T::type"".; //; // typename-specifier:; // 'typename' '::' [opt] nested-name-specifier identifier; // 'typename' '::' [opt] nested-name-specifier template [opt]; // simple-template-id",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:14,Availability,recover,recover,14,// Attempt to recover by skipping the invalid 'typename',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:14,Safety,recover,recover,14,// Attempt to recover by skipping the invalid 'typename',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:107,Integrability,protocol,protocol-qualified,107,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:77,Modifiability,parameteriz,parameterized,77,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace; // them with the annotation token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:23,Availability,error,error,23,"// If an unrecoverable error occurred, we need to return true here,; // because the token stream is in a damaged state. We may not; // return a valid identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:162,Deployability,Update,Update,162,// A template-id that refers to a type was parsed into a; // template-id annotation in a context where we weren't allowed; // to produce a type annotation token. Update the template-id; // annotation token to a type annotation token now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:163,Availability,error,error,163,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:187,Availability,recover,recovered,187,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:245,Availability,error,error,245,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:228,Integrability,rout,routine,228,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:187,Safety,recover,recovered,187,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Availability,recover,recover,8,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:114,Availability,recover,recover,114,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Safety,recover,recover,8,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:114,Safety,recover,recover,114,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,Availability,recover,recovered,9,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,Safety,recover,recovered,9,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,Availability,recover,recovery,22,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:43,Availability,error,error,43,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,Safety,recover,recovery,22,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Availability,Recover,Recover,85,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Safety,Recover,Recover,85,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:455,Integrability,interface,interface,455,"//===--- ParseStmt.cpp - Statement and Block Parser -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Statement and Block portions of the Parser; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:456,Integrability,synchroniz,synchronized-statement,456,/// ParseStatementOrDeclaration - Read 'statement' or 'declaration'.; /// StatementOrDeclaration:; /// statement; /// declaration; ///; /// statement:; /// labeled-statement; /// compound-statement; /// expression-statement; /// selection-statement; /// iteration-statement; /// jump-statement; /// [C++] declaration-statement; /// [C++] try-block; /// [MS] seh-try-block; /// [OBC] objc-throw-statement; /// [OBC] objc-try-catch-statement; /// [OBC] objc-synchronized-statement; /// [GNU] asm-statement; /// [OMP] openmp-construct [TODO]; ///; /// labeled-statement:; /// identifier ':' statement; /// 'case' constant-expression ':' statement; /// 'default' ':' statement; ///; /// selection-statement:; /// if-statement; /// switch-statement; ///; /// iteration-statement:; /// while-statement; /// do-statement; /// for-statement; ///; /// expression-statement:; /// expression[opt] ';'; ///; /// jump-statement:; /// 'goto' identifier ';'; /// 'continue' ';'; /// 'break' ';'; /// 'return' expression[opt] ';'; /// [GNU] 'goto' '*' expression ';'; ///; /// [OBC] objc-throw-statement:; /// [OBC] '@' 'throw' expression ';'; /// [OBC] '@' 'throw' ';'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Availability,error,errors,10,"// Handle errors here by skipping up to the next semicolon or '}', and; // eat the semicolon if that's what stopped us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Availability,Recover,Recover,3,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Safety,Recover,Recover,3,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:88,Deployability,update,updated,88,"// DeepestParsedCaseStmt - This is the deepest statement we have parsed, which; // gets updated each time a new case is parsed, and whose body is unset so; // far. When parsing 'case 4', this is the 'case 3' node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:103,Availability,error,error,103,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:109,Availability,recover,recovery,109,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:109,Safety,recover,recovery,109,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,Availability,recover,recover,52,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,Safety,recover,recover,52,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:20,Availability,error,error,20,"// If we had a sema error parsing this case, then just ignore it and; // continue parsing the sub-stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Deployability,Install,Install,3,// Install the body into the most deeply-nested case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Availability,Recover,Recover,3,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Safety,Recover,Recover,3,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:184,Availability,error,error,184,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:190,Availability,recover,recovery,190,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:334,Availability,recover,recover,334,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:391,Availability,error,error,391,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:485,Availability,recover,recover,485,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:622,Availability,error,errors,622,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:246,Integrability,depend,depending,246,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:175,Performance,perform,performs,175,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:190,Safety,recover,recovery,190,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:334,Safety,recover,recover,334,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:485,Safety,recover,recover,485,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,Availability,recover,recover,83,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,Safety,recover,recover,83,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:622,Safety,detect,detect,622,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:879,Usability,simpl,simpler,879,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do; // this if the body isn't a compound statement to avoid push/pop in common; // cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:185,Availability,error,error,185,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:122,Safety,avoid,avoid,122,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:68,Availability,error,error,68,"// Both invalid, or one is invalid and other is non-present: return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,Availability,recover,recovery,56,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,Safety,recover,recovery,56,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:202,Safety,avoid,avoid,202,"// C99 6.8.4p3 - In C99, the body of the switch statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:201,Safety,avoid,avoid,201,"// C99 6.8.5p5 - In C99, the body of the while statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.5p5 - In C99, the body of the do statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:607,Usability,simpl,simple-declaration,607,/// ParseForStatement; /// for-statement: [C99 6.8.5.3]; /// 'for' '(' expr[opt] ';' expr[opt] ';' expr[opt] ')' statement; /// 'for' '(' declaration expr[opt] ';' expr[opt] ')' statement; /// [C++] 'for' '(' for-init-statement condition[opt] ';' expression[opt] ')'; /// [C++] statement; /// [C++0x] 'for'; /// 'co_await'[opt] [Coroutines]; /// '(' for-range-declaration ':' for-range-initializer ')'; /// statement; /// [OBJC2] 'for' '(' declaration 'in' expr ')' statement; /// [OBJC2] 'for' '(' expr 'in' expr ')' statement; ///; /// [C++] for-init-statement:; /// [C++] expression-statement; /// [C++] simple-declaration; /// [C++23] alias-declaration; ///; /// [C++0x] for-range-declaration:; /// [C++0x] attribute-specifier-seq[opt] type-specifier-seq declarator; /// [C++0x] for-range-initializer:; /// [C++0x] expression; /// [C++0x] braced-init-list [TODO],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:302,Availability,error,error,302,"// We already know this is not an init-statement within a for loop, so; // if we are parsing a C++11 range-based for loop, we should treat this; // expression statement as being a discarded value expression because; // we will err below. This way we do not warn on an unused expression; // that was an error in the first place, like with: for (expr : expr);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Availability,recover,recovery,10,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Safety,recover,recovery,10,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:104,Usability,clear,clearly,104,"// FIXME: The C++11 standard doesn't actually say that this is a; // discarded-value expression, but it clearly should be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:178,Modifiability,variab,variable,178,"// We need to perform most of the semantic analysis for a C++0x for-range; // statememt before parsing the body, in order to be able to deduce the type; // of an auto-typed loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:14,Performance,perform,perform,14,"// We need to perform most of the semantic analysis for a C++0x for-range; // statememt before parsing the body, in order to be able to deduce the type; // of an auto-typed loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:38,Modifiability,variab,variable,38,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:84,Performance,Perform,Perform,84,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,Safety,avoid,avoid,199,"// C99 6.8.5p5 - In C99, the body of the for statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for; // for-init-statement/condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,Safety,safe,safe,199,"// Do not enter a scope for the brace, as the arguments are in the same scope; // (the function body) as the body itself. Instead, just read the statement; // list and put it into a CompoundStmt for safe keeping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:65,Usability,usab,usable,65,// Don't bother creating the full statement if we don't have any usable; // handlers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Integrability,depend,dependent,10,"// Handle dependent statements by parsing the braces as a compound statement.; // This is not the same behavior as Visual C++, which don't treat this as a; // compound statement, but for Clang's type checking we can't have anything; // inside these braces escaping to the surrounding code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:111,Availability,failure,failure,111,"// If we consumed the entire line, tell MC that.; // Also do this if we consumed nothing as a way of reporting failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:12,Testability,assert,assert,12,"// For now, assert that the string we're working with is a substring; // of what we gave to MC. This lets us use the original tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:12,Testability,assert,assert,12,"// For now, assert that the start of the string exactly; // corresponds to the start of a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:117,Testability,Assert,Assert,117,"// If we come up with an answer which seems sane, use it; otherwise,; // just point at the __asm keyword.; // FIXME: Assert the answer is sane once we handle .macro correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:3,Usability,Clear,Clear,3,// Clear the current token and advance to the first token in LineToks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:3,Performance,Perform,Perform,3,// Perform the lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:110,Safety,avoid,avoid,110,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:91,Security,access,access,91,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:85,Availability,error,error,85,"// If we've run into the poison token we inserted before, or there; // was a parsing error, then claim the entire line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:88,Integrability,rout,routine,88,"/// ParseMicrosoftAsmStatement. When -fms-extensions/-fasm-blocks is enabled,; /// this routine is called to collect the tokens for an MS asm statement.; ///; /// [MS] ms-asm-statement:; /// ms-asm-block; /// ms-asm-block ms-asm-statement; ///; /// [MS] ms-asm-block:; /// '__asm' ms-asm-line '\n'; /// '__asm' '{' ms-asm-instruction-block[opt] '}' ';'[opt]; ///; /// [MS] ms-asm-instruction-block; /// ms-asm-line; /// ms-asm-line '\n' ms-asm-instruction-block; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:30,Security,sanitiz,sanitizer,30,// FIXME: init MCOptions from sanitizer flags here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:19,Modifiability,variab,variable,19,// Need address of variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:46,Modifiability,extend,extended,46,/// parseGNUAsmQualifierListOpt - Parse a GNU extended asm qualifier list.; /// asm-qualifier:; /// volatile; /// inline; /// goto; ///; /// asm-qualifier-list:; /// asm-qualifier; /// asm-qualifier-list asm-qualifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:36,Modifiability,extend,extended,36,"/// ParseAsmStatement - Parse a GNU extended asm statement.; /// asm-statement:; /// gnu-asm-statement; /// ms-asm-statement; ///; /// [GNU] gnu-asm-statement:; /// 'asm' asm-qualifier-list[opt] '(' asm-argument ')' ';'; ///; /// [GNU] asm-argument:; /// asm-string-literal; /// asm-string-literal ':' asm-operands[opt]; /// asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]; /// asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]; /// ':' asm-clobbers; ///; /// [GNU] asm-clobbers:; /// asm-string-literal; /// asm-clobbers ',' asm-string-literal; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:49,Availability,Error,Error,49,// Check if GNU-style InlineAsm is disabled.; // Error on anything other than empty string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:13,Usability,simpl,simple,13,"// We have a simple asm expression like 'asm(""foo"")'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:365,Safety,Avoid,Avoid,365,"/// ParseAsmOperands - Parse the asm-operands production as used by; /// asm-statement, assuming the leading ':' token was eaten.; ///; /// [GNU] asm-operands:; /// asm-operand; /// asm-operands ',' asm-operand; ///; /// [GNU] asm-operand:; /// asm-string-literal '(' expression ')'; /// '[' identifier ']' asm-string-literal '(' expression ')'; ///; //; // FIXME: Avoid unnecessary std::string trashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:258,Security,access,access,258,"/// Parse a single declaration that declares a template,; /// template specialization, or explicit instantiation of a template.; ///; /// \param DeclEnd will receive the source location of the last token; /// within this declaration.; ///; /// \param AS the access specifier associated with this; /// declaration. Will be AS_none for namespace-scope declarations.; ///; /// \returns the new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:50,Availability,error,error,50,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Availability,recover,recovery,56,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Safety,recover,recovery,56,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Security,access,access,18,"// Turn off usual access checking for template specializations and; // instantiations.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - parameter-list;; // - template-argument-list;; // - noexcept-specifier;; // - dynamic-exception-specifications (deprecated in C++11, removed since; // C++17).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:139,Security,access,access,139,"// Turn off usual access checking for template specializations and; // instantiations.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - parameter-list;; // - template-argument-list;; // - noexcept-specifier;; // - dynamic-exception-specifications (deprecated in C++11, removed since; // C++17).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Error,Error,3,// Error parsing the declarator?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:546,Availability,error,error,546,"/// ParseTemplateParameters - Parses a template-parameter-list enclosed in; /// angle brackets. Depth is the depth of this template-parameter-list, which; /// is the number of template headers directly enclosing this template header.; /// TemplateParams is the current list of template parameters we're building.; /// The template parameter we parse will be added to this list. LAngleLoc and; /// RAngleLoc will receive the positions of the '<' and '>', respectively,; /// that enclose this template parameter list.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:109,Availability,error,error,109,// Somebody probably forgot to close the template. Skip ahead and; // try to get out of the expression. This error is currently; // subsumed by whatever goes on in ParseTemplateParameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:258,Availability,error,error,258,"// We return an invalid parameter as opposed to null to avoid having bogus; // diagnostics about an empty template parameter list.; // FIXME: Fix ParseTemplateParameterList to better handle nullptr results; // from here.; // Return a NTTP as if there was an error in a scope specifier, the user; // probably meant to write the type of a NTTP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Safety,avoid,avoid,56,"// We return an invalid parameter as opposed to null to avoid having bogus; // diagnostics about an empty template parameter list.; // FIXME: Fix ParseTemplateParameterList to better handle nullptr results; // from here.; // Return a NTTP as if there was an error in a scope specifier, the user; // probably meant to write the type of a NTTP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:99,Availability,error,errors,99,"// If it's none of the above, then it must be a parameter declaration.; // NOTE: This will pick up errors in the closure of the template parameter; // list (e.g., template < ; Check here to implement >> style closures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:252,Availability,error,error,252,"/// Try parsing a type-constraint at the current location.; ///; /// type-constraint:; /// nested-name-specifier[opt] concept-name; /// nested-name-specifier[opt] concept-name; /// '<' template-argument-list[opt] '>'[opt]; ///; /// \returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,Availability,avail,available,31,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the type parameter into the local scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:103,Availability,error,error,103,"// Provide an ExtWarn if the C++1z feature of using 'typename' here is used.; // Generate a meaningful error if the user forgot to put class before the; // identifier, comma, or greater. Provide a fixit if the identifier, comma,; // or greater appear immediately or after 'struct'. In the latter case,; // replace the keyword with 'class'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,Availability,avail,available,31,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the template parameter into the local scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:116,Availability,error,error,116,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:122,Availability,recover,recovery,122,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:215,Modifiability,extend,extend,215,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:122,Safety,recover,recovery,122,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:77,Usability,clear,clear,77,"// A hint to put a space between the '>>'s. In order to make the hint as; // clear as possible, we include the characters either side of the space in; // the replacement, rather than just inserting a space at SecondCharLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Deployability,Update,Update,3,// Update the token cache to match what we just did if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:20,Performance,cache,cache,20,// Update the token cache to match what we just did if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:19,Performance,cache,cached,19,"// If the previous cached token is being merged, delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:99,Integrability,rout,routine,99,"/// Parses a template-id that after the template name has; /// already been parsed.; ///; /// This routine takes care of parsing the enclosed template argument; /// list ('<' template-parameter-list [opt] '>') and placing the; /// results into a form that can be transferred to semantic analysis.; ///; /// \param ConsumeLastToken if true, then we will consume the last; /// token that forms the template-id. Otherwise, we will leave the; /// last token in the stream (e.g., so that it can be replaced with an; /// annotation token).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1910,Availability,error,error,1910,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:229,Integrability,rout,routine,229,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:35,Usability,simpl,simple-template-id,35,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:266,Usability,simpl,simple-template-id,266,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1400,Usability,simpl,simple-template-id,1400,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1597,Usability,simpl,simple-template-id,1597,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,recover,recover,18,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Safety,recover,recover,18,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace them with the; // annotation token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:104,Availability,failure,failure,104,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:261,Availability,error,error,261,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:444,Integrability,depend,dependent,444,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:23,Integrability,depend,dependent,23,// We appear to have a dependent template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:90,Integrability,depend,dependent,90,"// If the next token signals the end of a template argument, then we have; // a (possibly-dependent) template name that could be a template template; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:22,Integrability,depend,dependent,22,// We may have a (non-dependent) template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:121,Availability,error,error,121,"/// ParseTemplateArgumentList - Parse a C++ template-argument-list; /// (C++ [temp.names]). Returns true if there was an error.; ///; /// template-argument-list: [C++ 14.2]; /// template-argument; /// template-argument-list ',' template-argument; ///; /// \param Template is only used for code completion, and may be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,error,error,18,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Availability,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Safety,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid the tentative parse when NextToken() can't begin a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,error,error,18,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Availability,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Safety,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:453,Integrability,interface,interfaces,453,"//===--- ParseTentative.cpp - Ambiguity Resolution Parsing ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the tentative parsing portions of the Parser; // interfaces, for ambiguity resolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:308,Usability,simpl,simple-declaration,308,"/// isCXXDeclarationStatement - C++-specialized function that disambiguates; /// between a declaration or an expression statement, when parsing function; /// bodies. Returns true for declaration, false for expression.; ///; /// declaration-statement:; /// block-declaration; ///; /// block-declaration:; /// simple-declaration; /// asm-definition; /// namespace-alias-definition; /// using-declaration; /// using-directive; /// [C++0x] static_assert-declaration; ///; /// asm-definition:; /// 'asm' '(' string-literal ')' ';'; ///; /// namespace-alias-definition:; /// 'namespace' identifier = qualified-namespace-specifier ';'; ///; /// using-declaration:; /// 'using' typename[opt] '::'[opt] nested-name-specifier; /// unqualified-id ';'; /// 'using' '::' unqualified-id ;; ///; /// using-directive:; /// 'using' 'namespace' '::'[opt] nested-name-specifier[opt]; /// namespace-name ';'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:312,Modifiability,variab,variable,312,"// If the scope is not empty, it could alternatively be something like; // a typedef or using declaration. That declaration might be private; // in the global context, which would be diagnosed by calling into; // isCXXSimpleDeclaration, but may actually be fine in the context of; // member functions and static variable definitions. Check if the next; // token is also an identifier and assume a declaration.; // We cannot check if the scopes match because the declarations could; // involve namespaces and friend declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,Usability,simpl,simple-declaration,3,// simple-declaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:187,Availability,error,error,187,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:88,Usability,simpl,simple-declaration,88,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:365,Usability,simpl,simple-declaration,365,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1093,Usability,simpl,simple-type-specifier,1093,"// C++ 6.8p1:; // There is an ambiguity in the grammar involving expression-statements and; // declarations: An expression-statement with a function-style explicit type; // conversion (5.2.3) as its leftmost subexpression can be indistinguishable; // from a declaration where the first declarator starts with a '('. In those; // cases the statement is a declaration. [Note: To disambiguate, the whole; // statement might have to be examined to determine if it is an; // expression-statement or a declaration].; // C++ 6.8p3:; // The disambiguation is purely syntactic; that is, the meaning of the names; // occurring in such a statement, beyond whether they are type-names or not,; // is not generally used in or changed by the disambiguation. Class; // templates are instantiated as necessary to determine if a qualified name; // is a type-name. Disambiguation precedes parsing, and a statement; // disambiguated as a declaration may be an ill-formed declaration.; // We don't have to parse all of the decl-specifier-seq part. There's only; // an ambiguity if the first decl-specifier is; // simple-type-specifier/typename-specifier followed by a '(', which may; // indicate a function-style cast expression.; // isCXXDeclarationSpecifier will return TPResult::Ambiguous only in such; // a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Availability,Error,Error,52,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: TryParseSimpleDeclaration doesn't look past the first initializer,; // and so gets some cases wrong. We can't carry on if we've already seen; // something which makes this statement invalid as a declaration in this case,; // since it can cause us to misparse valid code. Revisit this once; // TryParseInitDeclaratorList is fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:175,Usability,simpl,simple-type-specifier,175,"// FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '(',; // or an identifier which doesn't resolve as anything. We need tentative; // parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,Usability,simpl,simple-template-id,170,// elaborated-type-specifier:; // class-key attribute-specifier-seq[opt]; // nested-name-specifier[opt] identifier; // class-key nested-name-specifier[opt] template[opt] simple-template-id; // enum nested-name-specifier[opt] identifier; //; // FIXME: We don't support class-specifiers nor enum-specifiers here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:4,Usability,simpl,simple-declaration,4,/// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; /// for-range-declaration:; /// attribute-specifier-seqopt type-specifier-seq declarator; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:78,Usability,simpl,simple-declaration,78,// Two decl-specifiers in a row conclusively disambiguate this as being a; // simple-declaration. Don't bother calling isCXXDeclarationSpecifier in the; // overwhelmingly common case that the next token is a '('.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:280,Usability,simpl,simple-asm-expr,280,"/// Tentatively parse an init-declarator-list in order to disambiguate it from; /// an expression.; ///; /// init-declarator-list:; /// init-declarator; /// init-declarator-list ',' init-declarator; ///; /// init-declarator:; /// declarator initializer[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] initializer[opt]; ///; /// initializer:; /// brace-or-equal-initializer; /// '(' expression-list ')'; ///; /// brace-or-equal-initializer:; /// '=' initializer-clause; /// [C++11] braced-init-list; ///; /// initializer-clause:; /// assignment-expression; /// braced-init-list; ///; /// braced-init-list:; /// '{' initializer-list ','[opt] '}'; /// '{' '}'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:9,Usability,simpl,simple-asm-expr,9,// [GNU] simple-asm-expr[opt] attributes[opt],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:728,Availability,error,error,728,"// MSVC and g++ won't examine the rest of declarators if '=' is; // encountered; they just conclude that we have a declaration.; // EDG parses the initializer completely, which is the proper behavior; // for this case.; //; // At present, Clang follows MSVC and g++, since the parser does not have; // the ability to parse an expression fully without recording the; // results of that parse.; // FIXME: Handle this case correctly.; //; // Also allow 'in' after an Objective-C declaration as in:; // for (int (^b)(void) in array). Ideally this should be done in the; // context of parsing for-init-statement of a foreach statement only. But,; // in any other context 'in' is invalid after a declaration and parser; // issues the error regardless of outcome of this decision.; // FIXME: Change if above assumption does not hold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Modifiability,variab,variables,52,// FIXME: Unify the parsing codepaths for condition variables and; // simple-declarations so that we don't need to eagerly figure out which; // kind we have here. (Just parse init-declarators until we reach a; // semicolon or right paren.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:70,Usability,simpl,simple-declarations,70,// FIXME: Unify the parsing codepaths for condition variables and; // simple-declarations so that we don't need to eagerly figure out which; // kind we have here. (Just parse init-declarators until we reach a; // semicolon or right paren.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:63,Usability,simpl,simple-declaration,63,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:434,Usability,simpl,simple-asm-expr,434,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:507,Usability,simpl,simple-declaration,507,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:758,Usability,simpl,simple-declaration,758,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:71,Usability,simpl,simple-declaration,71,// A parenthesized initializer could be part of an expression or a; // simple-declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:727,Availability,error,error,727,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,Integrability,rout,routine,170,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Availability,Error,Error,52,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:235,Usability,simpl,simple-type-specifier,235,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:246,Integrability,message,message-send,246,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:516,Integrability,message,message,516,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:604,Integrability,message,message,604,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:234,Integrability,Message,Message,234,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:298,Integrability,Message,Message,298,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:314,Integrability,message,message,314,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:380,Integrability,message,message,380,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,// We hit a hard error after deciding this was not an attribute.; // FIXME: Don't parse and annotate expressions when disambiguating; // against an attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:47,Integrability,message,message,47,"// Case 3: The inner construct is definitely a message send, so the; // outer construct is definitely not an attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:21,Integrability,message,message,21,// Case 4: Lambda in message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:117,Integrability,message,message,117,// No idea what this is; we couldn't parse it as a lambda-introducer.; // Might still be an attribute-specifier or a message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:76,Integrability,message,message-send,76,"// If we don't have a lambda-introducer, then we have an attribute or a; // message-send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:11,Integrability,Message,Message,11,// Case 3: Message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:113,Integrability,message,message,113,// Note that explicitly checking for `[[` and `]]` allows to fail as; // expected in the case of the Objective-C message send syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:228,Availability,Error,Error,228,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration; /// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could; /// be either a decl-specifier or a function-style cast, and TPResult::Error; /// if a parsing error was found and reported.; ///; /// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as; /// declaration specifiers but possibly valid as some other kind of construct; /// return TPResult::Ambiguous instead of TPResult::False. When this happens,; /// the intent is to keep trying to disambiguate, on the basis that we might; /// find a better reason to treat this construct as a declaration later on.; /// When this happens and the name could possibly be valid in some other; /// syntactic context, *InvalidAsDeclSpec is set to 'true'. The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:252,Availability,error,error,252,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration; /// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could; /// be either a decl-specifier or a function-style cast, and TPResult::Error; /// if a parsing error was found and reported.; ///; /// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as; /// declaration specifiers but possibly valid as some other kind of construct; /// return TPResult::Ambiguous instead of TPResult::False. When this happens,; /// the intent is to keep trying to disambiguate, on the basis that we might; /// find a better reason to treat this construct as a declaration later on.; /// When this happens and the name could possibly be valid in some other; /// syntactic context, *InvalidAsDeclSpec is set to 'true'. The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:921,Integrability,depend,dependent,921, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1535,Usability,simpl,simple-type-specifier,1535, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1681,Usability,simpl,simple-type-specifier,1681, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1809,Usability,simpl,simple-template-id,1809,"urrent cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:2391,Usability,simpl,simple-template-id,2391,"// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; ///; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// cv-qualifier:; /// 'const'; /// 'volatile'; /// [GNU] restrict; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:2900,Usability,simpl,simple-template-id,2900,"// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; ///; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// cv-qualifier:; /// 'const'; /// 'volatile'; /// [GNU] restrict; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:81,Availability,error,error,81,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:263,Availability,recover,recover,263,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:276,Availability,error,errors,276,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:263,Safety,recover,recover,263,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:176,Usability,undo,undo,176,"// In C++17, this could be a type template for class template argument; // deduction. Try to form a type annotation for it. If we're in a; // template template argument, we'll undo this when checking the; // validity of the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:83,Availability,error,error,83,"// A bare type template-name which can't be a template template; // argument is an error, and was probably intended to be a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:40,Integrability,depend,dependent,40,"// This might possibly be a type with a dependent scope specifier and; // a missing 'typename' keyword. Don't use TryAnnotateName in this case,; // since it will annotate as a primary expression, and we want to use the; // ""missing 'typename'"" logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:244,Testability,log,logic,244,"// This might possibly be a type with a dependent scope specifier and; // a missing 'typename' keyword. Don't use TryAnnotateName in this case,; // since it will annotate as a primary expression, and we want to use the; // ""missing 'typename'"" logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:23,Usability,simpl,simple-type-specifier,23,// type-specifier:; // simple-type-specifier; // class-specifier; // enum-specifier; // elaborated-type-specifier; // typename-specifier; // cv-qualifier; // class-specifier; // elaborated-type-specifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:10,Security,access,access,10,// OpenCL access qualifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:208,Availability,error,error,208,"// 'template-id(' can be a valid expression but not a valid decl spec if; // the template-name is not declared, but we don't consider this to be a; // definitive disambiguation. In any other context, it's an error either; // way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:156,Testability,test,test,156,// If we annotated then the current token should not still be ::; // FIXME we may want to also check for tok::annot_typename but; // currently don't have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:83,Availability,error,error,83,"// A bare type template-name which can't be a template template; // argument is an error, and was probably intended to be a type.; // In C++17, this could be class template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:51,Usability,simpl,simple-type-id,51,"// If that succeeded, fallthrough into the generic simple-type-id case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:30,Usability,simpl,simple-type-specifier,30,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:407,Usability,simpl,simple-type-specifier,407,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:466,Usability,simpl,simple-type-specifier,466,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:35,Integrability,protocol,protocol-qualified,35,"// In Objective-C, we might have a protocol-qualified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:25,Integrability,protocol,protocol,25,// Tentatively parse the protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,Usability,simpl,simple-type-specifier,3,// simple-type-specifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:11,Integrability,protocol,protocol-qualifiers,11,/// [ObjC] protocol-qualifiers:; //// '<' identifier-list '>',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:296,Availability,error,error,296,"/// isCXXFunctionDeclarator - Disambiguates between a function declarator or; /// a constructor-style initializer, when parsing declaration statements.; /// Returns true for function declarator and false for constructor-style; /// initializer.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,Availability,redundant,redundant,254,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,Safety,redund,redundant,254,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:373,Modifiability,inherit,inherit,373,"// If we're disambiguating a template argument in a default argument in; // a class definition versus a parameter declaration, an '=' here; // disambiguates the parse one way or the other.; // If this is a parameter, it must have a default argument because; // (a) the previous parameter did, and; // (b) this must be the first declaration of the function, so we can't; // inherit any default arguments from elsewhere.; // FIXME: If we reach a ')' without consuming any '>'s, then this must; // also be a function parameter (that's missing its default argument).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:281,Availability,Error,Error,281,"/// TryParseFunctionDeclarator - We parsed a '(' and we want to try to continue; /// parsing as a function declarator.; /// If TryParseFunctionDeclarator fully parsed the function declarator, it will; /// return TPResult::Ambiguous, otherwise it will return either False() or; /// Error().; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///; /// exception-specification:; /// 'throw' '(' type-id-list[opt] ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:105,Usability,simpl,simple-template-id,105,"/// Determine whether we might be looking at the '<' template-argument-list '>'; /// of a template-id or simple-template-id, rather than a less-than comparison.; /// This will often fail and produce an ambiguity, but should never be wrong; /// if it returns True or False.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:87,Usability,guid,guide,87,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:124,Usability,guid,guide,124,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:193,Usability,guid,guide,193,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:34,Modifiability,Rewrite,Rewrite,34,"//===- DeltaTree.cpp - B-Tree for Rewrite Delta tracking ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DeltaTree and related classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:143,Energy Efficiency,efficient,efficient,143,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:408,Energy Efficiency,efficient,efficiently,408,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:137,Performance,cache,cache,137,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:57,Availability,down,down,57,"// Otherwise, this is an interior node. Send the request down the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:133,Availability,down,down,133,"// Now that we have two nodes and a new element, insert the perclated value; // into ourself by moving all the later values/children down, then inserting; // the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:156,Safety,avoid,avoid,156,"// Finally, if this interior node was full and a node is percolated up, split; // ourself and return that up the chain. Start by saving all our info to; // avoid having the split clobber it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:32,Performance,perform,performing,32,/// VerifyTree - Walk the btree performing assertions on various properties to; /// verify consistency. This is useful for debugging new changes to the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:43,Testability,assert,assertions,43,/// VerifyTree - Walk the btree performing assertions on various properties to; /// verify consistency. This is useful for debugging new changes to the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:8,Availability,down,down,8,// Walk down the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:23,Availability,down,down,23,"// Otherwise, traverse down the tree. The selected subtree may be; // partially included in the range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:625,Energy Efficiency,green,green,625,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:2538,Integrability,wrap,wrap,2538,"position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:2573,Integrability,wrap,wrap,2573,"position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:762,Modifiability,variab,variables,762,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:858,Modifiability,Variab,Variable,858,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:896,Modifiability,variab,variable,896,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:1031,Modifiability,variab,variable,1031," color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:1598,Modifiability,variab,variable,1598,"ont-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { backgro",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:3438,Usability,simpl,simpletable,3438," { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;; }; td.rowname {; text-align: right;; vertical-align: top;; font-weight: bold;; color:#444444;; padding-right:2ex;; }. /* Hidden text. */; input.spoilerhider + label {; cursor: pointer;; text-decoration: underline;; display: block;; }; input.spoilerhider {; display: none;; }; input.spoilerhider ~ .spoiler {; overflow: hidden;; margin: 10px auto 0;; height: 0;; opacity: 0;; }; input.spoilerhider:checked + label + .spoiler{; height: auto;; opacity: 1;; }; </style>; </head>; <body>)<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:38,Safety,avoid,avoid,38,"// Lex all the tokens in raw mode, to avoid entering #includes or expanding; // macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:37,Deployability,update,update,37,"// Fill in Result.IdentifierInfo and update the token kind,; // looking up the identifier in the identifier table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:38,Safety,avoid,avoid,38,"// Lex all the tokens in raw mode, to avoid entering #includes or expanding; // macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:104,Availability,error,error,104,"// If this is a ## token, change its kind to unknown so that repreprocessing; // it will not produce an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:69,Safety,avoid,avoid,69,"// If the tokens were already space separated, or if they must be to avoid; // them being implicitly pasted, add a space between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:37,Integrability,interface,interface,37,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:7,Modifiability,Rewrite,Rewriter,7,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:405,Modifiability,Rewrite,Rewriter,405,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:27,Energy Efficiency,efficient,efficiently,27,// Walk RewriteRope chunks efficiently using MoveToNextPiece() instead of the; // character iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:8,Modifiability,Rewrite,RewriteRope,8,// Walk RewriteRope chunks efficiently using MoveToNextPiece() instead of the; // character iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:173,Availability,reliab,reliably,173,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:130,Modifiability,rewrite,rewrite,130,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:548,Modifiability,Rewrite,Rewriter,548,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:558,Modifiability,Rewrite,RewriteOptions,558,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:692,Modifiability,Rewrite,Rewrite,692,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:700,Modifiability,Rewrite,RewriteBufferTest,700,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:646,Testability,test,test,646,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:85,Modifiability,Rewrite,Rewriter,85,"//===----------------------------------------------------------------------===//; // Rewriter class; //===----------------------------------------------------------------------===//; /// getRangeSize - Return the size in bytes of the specified range if they; /// are in the same file. If not, this returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:264,Energy Efficiency,efficient,efficient,264,"/// getRewrittenText - Return the rewritten form of the text in the specified; /// range. If the start or end of the range was unrewritable or if they are; /// in different buffers, this returns an empty string.; ///; /// Note that this method is not particularly efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:36,Modifiability,Rewrite,RewriteBuffer,36,/// getEditBuffer - Get or create a RewriteBuffer for the specified FileID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:438,Energy Efficiency,power,powerful,438,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:7,Modifiability,Rewrite,RewriteRope,7,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:46,Modifiability,rewrite,rewriter,46,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:408,Modifiability,Rewrite,RewriteRope,408,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:376,Energy Efficiency,allocate,allocated,376,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1006,Energy Efficiency,adapt,adapted,1006,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1214,Energy Efficiency,efficient,efficient,1214,"// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our us",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1412,Energy Efficiency,efficient,efficiently,1412,"plitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. T",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1894,Energy Efficiency,reduce,reduce,1894,"rted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated.; /// RopePieceBTreeInterior - An interior node in the B+ Tree, which manages; /// up to '2*WidthFactor' other nodes in the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:2002,Energy Efficiency,reduce,reduced,2002,"rted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated.; /// RopePieceBTreeInterior - An interior node in the B+ Tree, which manages; /// up to '2*WidthFactor' other nodes in the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:4,Modifiability,Rewrite,RewriteRope,4,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1006,Modifiability,adapt,adapted,1006,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1243,Modifiability,Rewrite,RewriteRope,1243,"// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our us",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:165,Testability,log,log,165,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:523,Energy Efficiency,efficient,efficient,523,"//===----------------------------------------------------------------------===//; // RopePieceBTreeNode Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeNode - Common base class of RopePieceBTreeLeaf and; /// RopePieceBTreeInterior. This provides some 'virtual' dispatching methods; /// and a flag that determines which subclass the instance is. Also; /// important, this node knows the full extend of the node, including any; /// children that it has. This allows efficient skipping over entire subtrees; /// when looking for an offset in the BTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:450,Modifiability,extend,extend,450,"//===----------------------------------------------------------------------===//; // RopePieceBTreeNode Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeNode - Common base class of RopePieceBTreeLeaf and; /// RopePieceBTreeInterior. This provides some 'virtual' dispatching methods; /// and a flag that determines which subclass the instance is. Also; /// important, this node knows the full extend of the node, including any; /// children that it has. This allows efficient skipping over entire subtrees; /// when looking for an offset in the BTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:516,Energy Efficiency,efficient,efficient,516,"//===----------------------------------------------------------------------===//; // RopePieceBTreeLeaf Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated. Since this is a B+Tree, all values (in this case; /// instances of RopePiece) are stored in leaves like this. To make iteration; /// over the leaves efficient, they maintain a singly linked list through the; /// NextLeaf field. This allows the B+Tree forward iterator to be constant; /// time for all increments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:77,Energy Efficiency,efficient,efficient,77,"/// NextLeaf - This is a pointer to the next leaf in the tree, allowing; /// efficient in-order forward iteration of the tree without traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:4,Usability,clear,clear,4,/// clear - Remove all rope pieces from this leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:3,Deployability,Update,Update,3,// Update the list of leaves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:89,Energy Efficiency,allocate,allocated,89,"// Okay, this node is full. Split it in half, moving WidthFactor children to; // a newly allocated interior node.; // Create the new node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:88,Availability,down,down,88,"// If the deletion request completely covers the child, delete it and move; // the rest down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:8,Availability,down,down,8,// Walk down the left side of the tree until we get to a leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:85,Modifiability,Rewrite,RewriteRope,85,"//===----------------------------------------------------------------------===//; // RewriteRope Implementation; //===----------------------------------------------------------------------===//; /// MakeRopeString - This copies the specified byte range into some instance of; /// RopeRefCountString, and return a RopePiece that represents it. This uses; /// the AllocBuffer object to aggregate requests for small strings into one; /// allocation instead of doing tons of tiny allocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:83,Energy Efficiency,allocate,allocate,83,"// If we don't have enough room because this specific allocation is huge,; // just allocate a new rope piece for it alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:54,Integrability,interface,interface,54,"//===- TokenRewriter.cpp - Token-based code rewriting interface -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenRewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:71,Safety,avoid,avoid,71,"// FIXME: This is horrible, we should use our own list or something to avoid; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:48,Modifiability,Rewrite,Rewriter,48,/// AddToken - Add the specified token into the Rewriter before the other; /// position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:154,Safety,avoid,avoid,154,"// If the diagnosed code is `[[fallthrough]];` and; // `-Wunreachable-code-fallthrough` is enabled, suppress `code will never; // be executed` warning to avoid generating diagnostic twice",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Safety,Avoid,Avoid,3,// Avoid reporting multiple unreachable code diagnostics that are; // triggered by the same conditional value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:165,Deployability,configurat,configuration,165,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:165,Modifiability,config,configuration,165,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:260,Performance,perform,performance,260,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:272,Performance,optimiz,optimization,272,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:29,Availability,error,errors,29,/// Warn on logical operator errors in CFGBuilder,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:12,Testability,log,logical,12,/// Warn on logical operator errors in CFGBuilder,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:51,Safety,detect,detected,51,// Emit diagnostic if a recursive function call is detected for all paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:83,Safety,Avoid,Avoid,83,"// When not adding EH edges from calls, catch clauses; // can otherwise seem dead. Avoid noting them as dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:96,Modifiability,variab,variable,96,/// DiagUninitUse -- Helper function to produce a diagnostic for an; /// uninitialized use of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:93,Modifiability,variab,variable,93,"/// DiagnoseUninitializedUse -- Helper function for diagnosing uses of an; /// uninitialized variable. This manages the different forms of diagnostic; /// emitted for particular types of uses. Returns true if the use was diagnosed; /// as a warning. If a particular use is one we omit warnings for, returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:34,Modifiability,variab,variable,34,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:199,Safety,avoid,avoid,199,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:396,Security,access,access,396,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:20,Modifiability,variab,variable,20,// Report where the variable was declared when the use wasn't within; // the initializer of that declaration & we didn't already suggest; // an initialization fixit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:37,Safety,avoid,avoid,37,"// Mark all case blocks reachable to avoid problems with switching on; // constants, covered enums, etc.; // These blocks can contain fall-through annotations, and we don't want to; // issue a warn_fallthrough_attr_unreachable for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:17,Safety,detect,detect,17,// Workaround to detect a statement thrown out by CFGBuilder:; // case X: {} case Y:; // case X: ; case Y:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:185,Modifiability,variab,variable,185,"// If there was only one read, followed by any number of writes, and the; // read is not within a loop, don't warn. Additionally, don't warn in a; // loop if the base object is a local variable -- local variables are often; // changed in loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:203,Modifiability,variab,variables,203,"// If there was only one read, followed by any number of writes, and the; // read is not within a loop, don't warn. Additionally, don't warn in a; // loop if the base object is a local variable -- local variables are often; // changed in loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:34,Security,access,accessed,34,// Classify the weak object being accessed for better warning text.; // This enum should stay in sync with the cases in; // warn_arc_repeated_use_of_weak and warn_arc_possible_repeated_use_of_weak.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:23,Security,access,accesses,23,// Print all the other accesses as notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:72,Modifiability,variab,variable,72,"// Specially handle the case where we have uses of an uninitialized; // variable, but the root cause is an idiomatic self-init. We want; // to report the diagnostic at the self-init since that is the root cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:25,Availability,down,downgrade,25,"// If we have self-init, downgrade all uses to 'may be uninitialized'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:37,Modifiability,variab,variable,37,// Skip further diagnostics for this variable. We try to warn only; // on the first point at which a variable is used uninitialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:101,Modifiability,variab,variable,101,// Skip further diagnostics for this variable. We try to warn only; // on the first point at which a variable is used uninitialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Release,Release,3,// Release the uses vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Release,Release,3,// Release the uses vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:118,Safety,safe,safety,118,// anonymous namespace; //===----------------------------------------------------------------------===//; // -Wthread-safety; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:105,Safety,Unsafe,Unsafe,105,// namespace clang; //===----------------------------------------------------------------------===//; // Unsafe buffer usage analysis.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:81,Modifiability,variab,variables,81,// Recommend -fsafe-buffer-usage-suggestions?; // Lists as a string the names of variables in `VarGroupForVD` except for `VD`; // itself:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:61,Integrability,message,message,61,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:10,Modifiability,variab,variable,10,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:98,Modifiability,variab,variables,98,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:242,Availability,avail,available,242,"/// InterProceduralData aims to be a storage of whatever data should be passed; /// between analyses of different functions.; ///; /// At the moment, its primary goal is to make the information gathered during; /// the analysis of the blocks available during the analysis of the enclosing; /// function. This is important due to the fact that blocks are analyzed before; /// the enclosed function is even parsed fully, so it is not viable to access; /// anything in the outer scope while analyzing the block. On the other hand,; /// re-building CFG for blocks and re-analyzing them when we do have all the; /// information (i.e. during the analysis of the enclosing function) seems to be; /// ill-designed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:442,Security,access,access,442,"/// InterProceduralData aims to be a storage of whatever data should be passed; /// between analyses of different functions.; ///; /// At the moment, its primary goal is to make the information gathered during; /// the analysis of the blocks available during the analysis of the enclosing; /// function. This is important due to the fact that blocks are analyzed before; /// the enclosed function is even parsed fully, so it is not viable to access; /// anything in the outer scope while analyzing the block. On the other hand,; /// re-building CFG for blocks and re-analyzing them when we do have all the; /// information (i.e. during the analysis of the enclosing function) seems to be; /// ill-designed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:98,Integrability,depend,dependent,98,// An AST Visitor that calls a callback function on each callable DEFINITION; // that is NOT in a dependent context:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl; // `FunctionDecl->hasBody()` returns true if the function has a body; // somewhere defined. But we want to know if this `Node` has a body; // child. So we use `doesThisDeclarationHaveABody`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:31,Availability,error,errors,31,// exit if having uncompilable errors or ignoring all warnings:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Safety,Unsafe,UnsafeBufferUsage,3,// UnsafeBufferUsage analysis settings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:30,Performance,perform,performs,30,// The Callback function that performs analyses:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Performance,Perform,Perform,3,// Perform unsafe buffer usage analysis:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:11,Safety,unsafe,unsafe,11,// Perform unsafe buffer usage analysis:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:57,Availability,error,errors,57,"// We avoid doing analysis-based warnings when there are errors for; // two reasons:; // (1) The CFGs often can't be constructed (if the body is invalid), so; // don't bother trying.; // (2) The code already has problems; running the analysis just takes more; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:6,Safety,avoid,avoid,6,"// We avoid doing analysis-based warnings when there are errors for; // two reasons:; // (1) The CFGs often can't be constructed (if the body is invalid), so; // don't bother trying.; // (2) The code already has problems; running the analysis just takes more; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:15,Integrability,depend,dependent,15,"// For code in dependent contexts, we'll do this at instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:57,Safety,avoid,avoid,57,// Don't generate EH edges for CallExprs as we'd like to avoid the n^2; // explosion for destructors that can result and the compile time hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:40,Safety,safe,safety,40,// Unreachable code analysis and thread safety require a linearized CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Install,Install,3,// Install the logical handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:15,Testability,log,logical,15,// Install the logical handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:31,Testability,assert,assert,31,"// FIXME: We should be able to assert that block is non-null, but; // the CFG analysis can skip potentially-evaluated expressions in; // edge cases; see test/Sema/vla-2.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:153,Testability,test,test,153,"// FIXME: We should be able to assert that block is non-null, but; // the CFG analysis can skip potentially-evaluated expressions in; // edge cases; see test/Sema/vla-2.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:20,Safety,safe,safety,20,// Check for thread safety violations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:91,Availability,error,error,91,"// If none of the previous checks caused a CFG build, trigger one here; // for the logical error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:83,Testability,log,logical,83,"// If none of the previous checks caused a CFG build, trigger one here; // for the logical error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:50,Integrability,Interface,Interface,50,"//===- CodeCompleteConsumer.cpp - Code Completion Interface ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CodeCompleteConsumer class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,Energy Efficiency,efficient,efficient,27,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:119,Energy Efficiency,allocate,allocated,119,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:91,Integrability,rout,routine,91,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:31,Performance,cache,cached,31,// Check whether we've already cached the parent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,Availability,avail,availability,27,/// Retrieve the effective availability of the given declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:11,Availability,avail,availability,11,// Set the availability based on attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:58,Integrability,protocol,protocols,58,"// FIXME: Forward declarations of Objective-C classes and protocols; // are not directly exposed, but we want code completion to treat them; // like a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:89,Security,expose,exposed,89,"// FIXME: Forward declarations of Objective-C classes and protocols; // are not directly exposed, but we want code completion to treat them; // like a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:20,Usability,simpl,simple,20,"// If the name is a simple identifier (by far the common case), or a; // zero-argument selector, just return a reference to that identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:69,Integrability,depend,dependent,69,"/// Build the coroutine body statements, including the; /// ""promise dependent"" statements when the promise type is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:120,Integrability,depend,dependent,120,"/// Build the coroutine body statements, including the; /// ""promise dependent"" statements when the promise type is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:59,Integrability,depend,dependent,59,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:176,Integrability,depend,depending,176,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:338,Performance,perform,perform,338,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:115,Safety,avoid,avoid,115,"// If the 'InlineParams' in Declarator is unused and big enough, put our; // parameter list there (in an effort to avoid new/delete traffic). If it; // is already used (consider a function returning a function pointer) or too; // small (function with too many parameters), go to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for bindings and stash them away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:36,Testability,assert,assert,36,"// Unlike the other cases, we don't assert that we actually get a decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:206,Availability,error,error,206,"/// Finish - This does final analysis of the declspec, rejecting things like; /// ""_Imaginary"" (lacking an FP type). After calling this method, DeclSpec is; /// guaranteed to be self-consistent, even if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Security,Validat,Validate,3,// Validate and finalize AltiVec vector declspec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:73,Modifiability,enhance,enhancements,73,// vector float is unsupported for ZVector unless we have the; // vector-enhancements facility 1 (ISA revision 12).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:8,Performance,perform,perform,8,//TODO: perform validation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:16,Security,validat,validation,16,//TODO: perform validation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Security,Validat,Validate,3,// Validate the width of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,Availability,recover,recover,49,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,Safety,recover,recover,49,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,Availability,recover,recovered,21,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,Safety,recover,recovered,21,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp:585,Security,Access,AccessedEntity,585,"//===- DelayedDiagnostic.cpp - Delayed declarator diagnostics -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DelayedDiagnostic class implementation, which; // is used to record diagnostics that are being conditionally produced; // during declarator parsing.; //; // This file also defines AccessedEntity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp:72,Performance,load,load,72,// If the translation unit has external storage force external decls to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp:49,Performance,load,load,49,// Force external decls in the HLSL namespace to load from the PCH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp:260,Energy Efficiency,Allocate,Allocates,260,//===----------------------------------------------------------------------===//; // IdDeclInfoMap class; //===----------------------------------------------------------------------===//; /// IdDeclInfoMap - Associates IdDeclInfos with declaration names.; /// Allocates 'pools' (vectors of IdDeclInfos) to avoid allocating each; /// individual IdDeclInfo to heap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp:306,Safety,avoid,avoid,306,//===----------------------------------------------------------------------===//; // IdDeclInfoMap class; //===----------------------------------------------------------------------===//; /// IdDeclInfoMap - Associates IdDeclInfos with declaration names.; /// Allocates 'pools' (vectors of IdDeclInfos) to avoid allocating each; /// individual IdDeclInfo to heap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:200,Safety,detect,detect,200,"/// JumpScopeChecker - This object is used by Sema to diagnose invalid jumps; /// into VLA and other protected scopes. For example, this rejects:; /// goto L;; /// int a[n];; /// L:; ///; /// We also detect jumps out of protected scopes when it's not possible to do; /// cleanups properly. Indirect jumps and ASM jumps can't do cleanups because; /// the target is unknown. Return statements with \c [[clang::musttail]] cannot; /// handle any cleanups due to the nature of a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,Availability,recover,recovering,27,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:43,Availability,error,errors,43,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,Safety,recover,recovering,27,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:69,Modifiability,variab,variable,69,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:191,Modifiability,variab,variable,191,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:505,Modifiability,variab,variable,505,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:627,Modifiability,variab,variable,627,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:9,Modifiability,variab,variable,9,"// For a variable of (array of) class type declared without an; // initializer, we will have call-style initialization and the initializer; // will be the CXXConstructExpr with no intervening nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:86,Deployability,install,installed,86,"// If the decl has an initializer, walk it with the potentially new; // scope we just installed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:57,Modifiability,variab,variables,57,/// Build scope information for a captured block literal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:28,Modifiability,variab,variables,28,// exclude captured __block variables; there's no destructor; // associated with the block literal for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:148,Safety,avoid,avoid,148,"// ""goto *&&lbl;"" is a special case which we treat as equivalent; // to a normal goto. In addition, we don't calculate scope in the; // operand (to avoid recording the address-of-label use), which; // works only because of the restricted set of expressions which; // we detect as constant targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:270,Safety,detect,detect,270,"// ""goto *&&lbl;"" is a special case which we treat as equivalent; // to a normal goto. In addition, we don't calculate scope in the; // operand (to avoid recording the address-of-label use), which; // works only because of the restricted set of expressions which; // we detect as constant targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:46,Modifiability,variab,variable,46,// Evaluate the C++17 init stmt and condition variable; // before entering the scope of the switch statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:54,Integrability,synchroniz,synchronized,54,"// Disallow jumps into the protected statement of an @synchronized, but; // allow jumps into the object expression it protects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,Integrability,synchroniz,synchronized,37,"// Recursively walk the AST for the @synchronized object expr, it is; // evaluated in the normal scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,Integrability,synchroniz,synchronized,37,"// Recursively walk the AST for the @synchronized part, protected by a new; // scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:64,Modifiability,extend,extended,64,// Disallow jumps out of scopes containing temporaries lifetime-extended to; // automatic storage duration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:146,Safety,avoid,avoid,146,"// Cases, labels, and defaults aren't ""scope parents"". It's also; // important to handle these iteratively instead of recursively in; // order to avoid blowing out the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:128,Availability,down,down,128,"// Collect a single representative of every scope containing an indirect; // goto. For most code bases, this substantially cuts down on the number of; // jump sites we'll have to consider later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:52,Safety,safe,safely,52,// Mark all the enclosing scopes from which you can safely jump; // into the target scope. 'Min' will end up being the index of; // the shallowest such scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:32,Availability,error,error,32,/// Return true if a particular error+note combination must be downgraded to a; /// warning in Microsoft mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:63,Availability,down,downgraded,63,/// Return true if a particular error+note combination must be downgraded to a; /// warning in Microsoft mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:47,Availability,down,downgraded,47,/// Return true if a particular note should be downgraded to a compatibility; /// warning in C++11 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:16,Security,Validat,Validate,16,"/// CheckJump - Validate that the specified jump statement is valid: that it is; /// jumping within or out of its current scope, not into a deeper one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:10,Availability,error,errors,10,// Handle errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:16,Modifiability,config,configure,16,// Go ahead and configure all the inline capacity. This is just a memset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:14,Energy Efficiency,allocate,allocate,14,"// Otherwise, allocate something new.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:51,Modifiability,plugin,plugin,51,// Otherwise this may be an attribute defined by a plugin.; // Search for a ParsedAttrInfo whose name and syntax match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:360,Availability,avail,available,360,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:207,Modifiability,variab,variables,207,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:174,Usability,clear,clear,174,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:24,Modifiability,variab,variable,24,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:102,Modifiability,variab,variables,102,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:73,Usability,Clear,Clear,73,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:65,Availability,avail,available,65,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:124,Availability,avail,available,124,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:16,Modifiability,variab,variable,16,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:19,Integrability,message,message,19,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:27,Security,access,accessing,27,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:428,Performance,perform,performs,428,"//===--- Sema.cpp - AST Builder and Semantic Analysis Implementation ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the actions class which performs semantic analysis and; // builds an AST out of a parse stream.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:106,Availability,avail,available,106,// This evaluation context exists to ensure that there's always at least one; // valid evaluation context available. It is never removed from the; // evaluation stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Integrability,Protocol,Protocol,48,// Create the built-in forward declaratino for 'Protocol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:10,Performance,cache,cached,10,// Delete cached satisfactions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Availability,error,error,48,"/// makeUnavailableInSystemHeader - There is an error in the current; /// context. If we're still in a system header, and we can plausibly; /// make the relevant declaration unavailable instead of erroring, do; /// so and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:197,Availability,error,erroring,197,"/// makeUnavailableInSystemHeader - There is an error in the current; /// context. If we're still in a system header, and we can plausibly; /// make the relevant declaration unavailable instead of erroring, do; /// so and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:39,Availability,error,error,39,"// If we're not in a function, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:47,Availability,error,error,47,"// If we're in template instantiation, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:54,Availability,error,error,54,"// If that function's not in a system header, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:55,Availability,error,error,55,"// If the function is already unavailable, it's not an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:87,Usability,simpl,simply,87,"// C17 6.7.1p6 footnote 124: The implementation can treat any register; // declaration simply as an auto declaration. However, whether or not; // addressable storage is actually used, the address of any part of an; // object declared with storage-class specifier register cannot be; // computed, either explicitly(by use of the unary & operator as discussed; // in 6.5.3.2) or implicitly(by converting an array name to a pointer as; // discussed in 6.3.2.1).Thus, the only operator that can be applied to an; // array declared with storage-class specifier register is sizeof.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Modifiability,variab,variable,11,/*register variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:8,Modifiability,variab,variable,8,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:114,Modifiability,variab,variable,114,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:231,Modifiability,variab,variable,231,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,Usability,usab,usable,17,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:16,Modifiability,variab,variable,16,"// If this is a variable template and none of its specializations is used,; // we should warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:60,Modifiability,variab,variable,60,/// Determine whether ND is an external-linkage function or variable whose; /// type has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:43,Modifiability,variab,variables,43,/// Obtains a sorted list of functions and variables that are undefined but; /// ODR-used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:85,Modifiability,variab,variable,85,"// C++ [basic.link]p8:; // A type without linkage shall not be used as the type of a variable; // or function with external linkage unless; // -- the entity has C language linkage; // -- the entity is not odr-used or is defined in the same TU; //; // As an extension, accept this in cases where the type is externally; // visible, since the function or variable actually can be defined in; // another translation unit in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:353,Modifiability,variab,variable,353,"// C++ [basic.link]p8:; // A type without linkage shall not be used as the type of a variable; // or function with external linkage unless; // -- the entity has C language linkage; // -- the entity is not odr-used or is defined in the same TU; //; // As an extension, accept this in cases where the type is externally; // visible, since the function or variable actually can be defined in; // another translation unit in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:36,Availability,error,error,36,"// FIXME: We can promote this to an error. The function or variable can't; // be defined anywhere else, so the program must necessarily violate the; // one definition rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:59,Modifiability,variab,variable,59,"// FIXME: We can promote this to an error. The function or variable can't; // be defined anywhere else, so the program must necessarily violate the; // one definition rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:140,Performance,perform,performed,140,"// If the template function is marked as late template parsed at this; // point, it has not been instantiated and therefore we have not; // performed semantic analysis on it yet, so we cannot know if the type; // can be considered complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:22,Availability,avail,available,22,// Friend classes are available as the TypeSourceInfo of the FriendDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:24,Availability,avail,available,24,// Friend functions are available through the NamedDecl of FriendDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:135,Integrability,inject,injected,135,/// This is called before the very first declaration in the translation unit; /// is parsed. Note that the ASTContext may have already injected some; /// declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:135,Security,inject,injected,135,/// This is called before the very first declaration in the translation unit; /// is parsed. Note that the ASTContext may have already injected some; /// declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:165,Deployability,install,installed,165,"// Transfer late parsed template instantiations over to the pending template; // instantiation list. During normal compilation, the late template parser; // will be installed and instantiating these templates will succeed.; //; // If we are building a TU prefix for serialization, it is also safe to; // transfer these over, even though they are not parsed. The end of the TU; // should be outside of any eager template instantiation scope, so when this; // AST is deserialized, these templates will not be parsed until the end of; // the combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:292,Safety,safe,safe,292,"// Transfer late parsed template instantiations over to the pending template; // instantiation list. During normal compilation, the late template parser; // will be installed and instantiating these templates will succeed.; //; // If we are building a TU prefix for serialization, it is also safe to; // transfer these over, even though they are not parsed. The end of the TU; // should be outside of any eager template instantiation scope, so when this; // AST is deserialized, these templates will not be parsed until the end of; // the combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:8,Performance,Perform,Perform,8,"// C++: Perform implicit template instantiations.; //; // FIXME: When we perform these implicit instantiations, we do not; // carefully keep track of the point of instantiation (C++ [temp.point]).; // This means that name lookup that occurs within the template; // instantiation will always happen at the end of the translation unit,; // so it will find some names that are not required to be found. This is; // valid, but we could do better by diagnosing if an instantiation uses a; // name that was not visible at its first point of instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:73,Performance,perform,perform,73,"// C++: Perform implicit template instantiations.; //; // FIXME: When we perform these implicit instantiations, we do not; // carefully keep track of the point of instantiation (C++ [temp.point]).; // This means that name lookup that occurs within the template; // instantiation will always happen at the end of the translation unit,; // so it will find some names that are not required to be found. This is; // valid, but we could do better by diagnosing if an instantiation uses a; // name that was not visible at its first point of instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:3,Performance,Load,Load,3,// Load pending instantiations from the external source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:65,Performance,perform,performed,65,// We pass an empty TypoCorrection to indicate no correction was performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:40,Performance,perform,perform,40,"// If code completion is enabled, don't perform any end-of-translation-unit; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:61,Performance,perform,perform,61,// Complete translation units and modules define vtables and perform implicit; // instantiations. PCH files do not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:59,Safety,safe,safe,59,"// If we are building a TU prefix for serialization, it is safe to transfer; // these over, even though they are not parsed. The end of the TU should be; // outside of any eager template instantiation scope, so when this AST is; // deserialized, these templates will not be parsed until the end of the; // combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,Integrability,interface,interface,31,"// If we are building a module interface unit, we need to have seen the; // module declaration by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:3,Performance,Queue,Queue,3,"// Queue the submodules, so their exports will also be resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:113,Modifiability,variab,variable,113,"// If the tentative definition was completed, getActingDefinition() returns; // null. If we've already seen this variable before, insert()'s second; // return value is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:24,Performance,perform,performed,24,// No initialization is performed for a tentative definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,Availability,error,errors,17,"// If there were errors, disable 'unused' warnings since they will mostly be; // noise. Don't warn for a use from a module: either we should warn on all; // file-scope declarations in modules or not at all, but whether the; // declaration is used is immaterial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:10,Performance,Load,Load,10,// FIXME: Load additional unused private field candidates from the external; // source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:82,Modifiability,variab,variable,82,"// Check we've noticed that we're no longer parsing the initializer for every; // variable. If we miss cases, then at best we have a performance issue and; // at worst a rejects-valid bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:133,Performance,perform,performance,133,"// Check we've noticed that we're no longer parsing the initializer for every; // variable. If we miss cases, then at best we have a performance issue and; // at worst a rejects-valid bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:202,Modifiability,refactor,refactor,202,"// FIXME: It doesn't make sense to me that DiagID is an incoming argument here; // and yet we also use the current diag ID on the DiagnosticsEngine. This has; // been made more painfully obvious by the refactor that introduced this; // function, but it is possible that the incoming argument can be; // eliminated. If it truly cannot be (for example, there is some reentrancy; // issue I am not seeing yet), then there should at least be a clarifying; // comment somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:14,Availability,failure,failure,14,// Count this failure so that we know that template argument deduction; // has failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:28,Security,access,access,28,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:84,Security,Access,AccessCheckingSFINAE,84,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:146,Security,access,access,146,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,Usability,clear,clear,31,"// Now the diagnostic state is clear, produce a C++98 compatibility; // warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:147,Availability,error,error,147,"// If this is not a note, and we're in a template instantiation; // that is different from the last template instantiation where; // we emitted an error, print a template instantiation; // backtrace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Availability,error,error,11,// Respect error limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Integrability,message,messages,48,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:158,Integrability,message,messages,158,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:243,Integrability,message,messages,243,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:1322,Integrability,depend,depends,1322,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:435,Modifiability,variab,variables,435,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:705,Modifiability,variab,variables,705,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:1075,Modifiability,variab,variables,1075,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:234,Integrability,depend,depending,234,// Whether the visiting of the function has been done. Done[0] is for the; // case not in OpenMP device context. Done[1] is for the case in OpenMP; // device context. We need two sets because diagnostics emission may be; // different depending on whether it is in OpenMP device context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Availability,error,error,11,// Respect error limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,Availability,error,errors,99,"// In CUDA, there are some constructs which may appear in semantically-valid; // code, but trigger errors if we ever generate code for the function in which; // they appear. Essentially every construct you're not allowed to use on the; // device falls into this category, because you are allowed to use these; // constructs in a __host__ __device__ function, but only if that function is; // never codegen'ed on the device.; //; // To handle semantic checking for these constructs, we keep track of the set of; // functions we know will be emitted, either because we could tell a priori that; // they would be emitted, or because they were transitively called by a; // known-emitted function.; //; // We also keep a partial call graph of which not-known-emitted functions call; // which other not-known-emitted functions.; //; // When we see something which is illegal if the current function is emitted; // (usually by way of CUDADiagIfDeviceCode, CUDADiagIfHostCode, or; // CheckCUDACall), we first check if the current function is known-emitted. If; // so, we immediately output the diagnostic.; //; // Otherwise, we ""defer"" the diagnostic. It sits in Sema::DeviceDeferredDiags; // until we discover that the function is known-emitted, at which point we take; // it out of this map and emit the diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:51,Availability,error,error,51,"// Emit our diagnostic and, if it was a warning or error, output a callstack; // if Fn isn't a priori known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:20,Availability,error,errors,20,"// Try to associate errors with the lexical context, if that is a function, or; // the value declaration otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:409,Deployability,update,update,409,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,Integrability,rout,routine,99,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:343,Integrability,inject,injects,343,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:343,Security,inject,injects,343,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:7,Performance,Cache,CachedFunctionScope,7,// Use CachedFunctionScope to avoid allocating memory when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:30,Safety,avoid,avoid,30,// Use CachedFunctionScope to avoid allocating memory when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:178,Modifiability,variab,variables,178,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:145,Performance,perform,performs,145,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:45,Security,access,accessible,45,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:41,Modifiability,variab,variables,41,// Set the EscapingByref flag of __block variables captured by; // escaping blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:38,Modifiability,variab,variable,38,// Nothing to do if this is a __block variable captured by a; // non-escaping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:30,Modifiability,variab,variable,30,// Check whether the captured variable is or contains an object of; // non-trivial C union type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Modifiability,variab,variables,11,// __block variables might require us to capture a copy-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:49,Modifiability,variab,variable,49,"// It's currently invalid to ever have a __block variable with an; // array type; should we diagnose that here?; // Regardless, we don't want to ignore array nesting when; // constructing this copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:26,Availability,error,errors,26,/// Determine whether any errors occurred within this function/method/; /// block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,Availability,recover,recover,95,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:111,Availability,error,error,111,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,Safety,recover,recover,95,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:407,Integrability,rout,routines,407,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:31,Security,Access,Access,31,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:424,Security,access,access,424,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,Availability,error,error,90,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:39,Security,access,access,39,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:127,Security,access,access,127,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:187,Security,access,access,187,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,access,19,// Use the lexical access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:14,Security,access,access,14,// C++ [class.access.spec]p3: When a member is redeclared its access; // specifier must be same as its initial declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:62,Security,access,access,62,// C++ [class.access.spec]p3: When a member is redeclared its access; // specifier must be same as its initial declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:104,Security,access,access,104,"// An implicit deduction guide is semantically in the context enclosing the; // class template, but for access purposes behaves like the constructor; // from which it was produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:25,Usability,guid,guide,25,"// An implicit deduction guide is semantically in the context enclosing the; // class template, but for access purposes behaves like the constructor; // from which it was produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:16,Security,access,access,16,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:88,Security,access,access,88,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:144,Security,access,access,144,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:188,Security,access,access,188,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:236,Security,access,access,236,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:287,Security,access,access,287,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:349,Security,access,access,349,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:65,Usability,simpl,simplicity,65,"// We want to add canonical declarations to the EC lists for; // simplicity of checking, but we need to walk up through the; // actual current DC chain. Otherwise, something like a local; // extern or friend which happens to be the canonical; // declaration will really mess us up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:78,Security,access,access-control,78,"/// Retrieves the innermost ""useful"" context. Can be null if we're; /// doing access-control without privileges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:15,Security,Access,AccessedEntity,15,"/// Like sema::AccessedEntity, but kindly lets us scribble all over; /// it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:134,Integrability,depend,dependence,134,"/// Checks whether one class is derived from another, inclusively.; /// Properly indicates when it couldn't be determined due to; /// dependence.; ///; /// This should probably be donated to AST or at least Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Integrability,depend,dependent,24,"// If the context isn't dependent, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:49,Integrability,depend,dependent,49,"// If the context isn't dependent, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,Integrability,depend,dependent,52,"// If the template names don't match, it can't be a dependent; // match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:87,Integrability,depend,dependent,87,"// If the class's context can't instantiate to the friend's; // context, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Integrability,depend,dependent,21,"// Otherwise, it's a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Security,access,accesses,13,// Whitelist accesses if there's an invalid or unsupported friend; // declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Integrability,depend,dependent,28,// FIXME: declarations with dependent or templated scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:62,Security,access,access,62,/// A helper class for checking for a friend which will grant access; /// to a protected instance member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Availability,down,down,13,/// The path down to the current base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Performance,Perform,Perform,4,/// Perform a search starting at the given class.; ///; /// PrivateDepth is the index of the last (least derived) class; /// along the current path such that a notional public member of; /// the final class in the path would have access in that class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:230,Security,access,access,230,/// Perform a search starting at the given class.; ///; /// PrivateDepth is the index of the last (least derived) class; /// along the current path such that a notional public member of; /// the final class in the path would have access in that class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:22,Modifiability,inherit,inheritance,22,"// If this is private inheritance, then a public member of the; // base will not have any access in classes derived from Cur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,Security,access,access,90,"// If this is private inheritance, then a public member of the; // base will not have any access in classes derived from Cur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:267,Security,access,access,267,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:523,Security,access,access,523,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:592,Security,access,access,592,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:727,Security,access,accessible,727,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:928,Security,access,access,928,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1032,Security,access,access,1032,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1155,Security,access,accessible,1155,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1270,Security,access,accessible,1270,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1336,Security,access,accessible,1336,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:46,Security,access,access,46,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:104,Security,access,access,104,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:256,Security,access,access,256,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:379,Security,access,access,379,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:502,Security,access,accesses,502,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:172,Security,access,access,172,"// Despite the standard's confident wording, there is a case; // where you can have an instance member that's neither in a; // pointer-to-member expression nor in a member access: when; // it names a field in an unevaluated context that can't be an; // implicit member. Pending clarification, we just apply the; // same naming-class restriction here.; // FIXME: we're probably not correctly adding the; // protected-member restriction when we retroactively convert; // an expression to being evaluated.; // We know that ECRecord derives from NamingClass. The; // restriction says to check whether NamingClass derives from; // ECRecord, but that's not really necessary: two distinct; // classes can't be recursively derived from each other. So; // along this path, we just need to check whether the classes; // are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:73,Security,access,access,73,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:87,Security,access,access,87,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:208,Security,access,access,208,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2680,Integrability,depend,dependent,2680,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1328,Modifiability,inherit,inheritance,1328,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1527,Modifiability,inherit,inheritance,1527,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1711,Modifiability,inherit,inheritance,1711,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:139,Security,access,access,139,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:174,Security,access,accessible,174,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:636,Security,access,accessible,636,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:667,Security,access,accessible,667,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:729,Security,access,access,729,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:773,Security,access,accessible,773,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1238,Security,access,accessible,1238,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1286,Security,access,accessible,1286,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1544,Security,access,access,1544,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1578,Security,access,access,1578,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1639,Security,access,accessible,1639,"t is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1881,Security,access,access,1881,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1908,Security,access,accessible,1908,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1942,Security,Access,Access,1942,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1960,Security,access,access,1960,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2109,Security,Access,Accessible,2109,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2147,Security,Access,Accessible,2147,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2204,Security,Access,Accessible,2204,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2273,Security,Access,Accessible,2273,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2348,Security,Access,AccessToBase,2348,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2369,Security,Access,Access,2369,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2413,Security,Access,Accessible,2413,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2429,Security,Access,AccessToBase,2429,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2460,Security,Access,AccessToBase,2460,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2491,Security,access,accessible,2491,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2572,Security,access,access,2572,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:40,Integrability,depend,dependent,40,// FIXME: fail correctly when there are dependent paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:30,Security,access,access,30,// Derive the friend-modified access along each path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:135,Security,access,accessible,135,"// If the declaration is a private member of a base class, there; // is no level of friendship in derived classes that can make it; // accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Testability,test,tests,10,// Future tests are not against members and so do not have; // instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:34,Security,Access,Access,34,// Note that we modify the path's Access field to the; // friend-modified access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Security,access,access,74,// Note that we modify the path's Access field to the; // friend-modified access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Integrability,depend,dependent,74,"// We didn't find a public path, but at least one path was subject; // to dependent friendship, so delay the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:47,Security,access,access,47,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Security,access,access,74,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:129,Security,access,access,129,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,access,accesses,28,// Only applies to instance accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:131,Security,access,access,131,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:270,Security,access,access,270,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:297,Security,access,access,297,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:83,Availability,error,error,83,"// TODO: it would be great to have a fixit here, since this is; // such an obvious error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Security,access,access,21,/// We are unable to access a given declaration due to its direct; /// access control; diagnose that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:71,Security,access,access,71,/// We are unable to access a given declaration due to its direct; /// access control; diagnose that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,Access,AccessSpecDecl,28,// Check whether there's an AccessSpecDecl preceding this in the; // chain of the DeclContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:98,Security,access,access,98,// This basically repeats the main algorithm but keeps some more; // information.; // The natural access so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:25,Security,access,accessible,25,"// If the declaration is accessible when named in its declaring; // class, then we must be constrained by the path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:17,Security,access,accessible,17,"// Is the entity accessible when named in the deriving class, as; // modified by the base specifier?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Security,access,access,10,"// If the access to this base is worse than the access we have to; // the declaration, remember it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:48,Security,access,access,48,"// If the access to this base is worse than the access we have to; // the declaration, remember it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:23,Modifiability,inherit,inheritance,23,"// If this was private inheritance, but we don't have access to; // the deriving class, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:54,Security,access,access,54,"// If this was private inheritance, but we don't have access to; // the deriving class, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,Availability,failure,failure,52,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:45,Security,access,access,45,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Modifiability,inherit,inheritance,24,"// We're constrained by inheritance, but we want to say; // ""declared private here"" if we're diagnosing a hierarchy; // conversion and this is the final step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:260,Availability,error,error,260,"/// MSVC has a bug where if during an using declaration name lookup,; /// the declaration found is unaccessible (private) and that declaration; /// was bring into scope via another using declaration whose target; /// declaration is accessible (public) then no error is generated.; /// Example:; /// class A {; /// public:; /// int f();; /// };; /// class B : public A {; /// private:; /// using A::f;; /// };; /// class C : public B {; /// private:; /// using B::f;; /// };; ///; /// Here, B::f is private so this should fail in Standard C++, but; /// because B::f refers to A::f which is public MSVC accepts it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:232,Security,access,accessible,232,"/// MSVC has a bug where if during an using declaration name lookup,; /// the declaration found is unaccessible (private) and that declaration; /// was bring into scope via another using declaration whose target; /// declaration is accessible (public) then no error is generated.; /// Example:; /// class A {; /// public:; /// int f();; /// };; /// class B : public A {; /// private:; /// using A::f;; /// };; /// class C : public B {; /// private:; /// using B::f;; /// };; ///; /// Here, B::f is private so this should fail in Standard C++, but; /// because B::f refers to A::f which is public MSVC accepts it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:27,Security,access,accessed,27,/// Determines whether the accessed entity is accessible. Public members; /// have been weeded out by this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:46,Security,access,accessible,46,/// Determines whether the accessed entity is accessible. Public members; /// have been weeded out by this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:32,Security,access,access,32,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:68,Security,access,accesses,68,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,accesses,121,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:225,Security,access,access,225,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:241,Integrability,depend,dependently,241,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:118,Security,access,access,118,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:226,Security,access,accessible,226,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:390,Security,access,access,390,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:310,Testability,assert,assertion,310,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,accesses,19,// We lower member accesses to base accesses by pretending that the; // member is a base class of its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:36,Security,access,accesses,36,// We lower member accesses to base accesses by pretending that the; // member is a base class of its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:35,Security,access,accessible,35,// Determine if the declaration is accessible from EC when named; // in its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Security,access,accessible,13,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:143,Security,access,accessible,143,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:224,Security,access,access,224,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:95,Usability,simpl,simply,95,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,access,access,28,// Append the declaration's access if applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to an entity from the given effective context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Security,access,access,10,"// If the access path is public, it's accessible everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:38,Security,access,accessible,38,"// If the access path is public, it's accessible everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:70,Security,access,access,70,"// If we're currently parsing a declaration, we may need to delay; // access control checking, because our effective context might be; // different based on what the declaration comes out as.; //; // For example, we might be parsing a declaration with a scope; // specifier, like this:; // A::private_type A::foo() { ... }; //; // Or we might be parsing something that will turn out to be a friend:; // void foo(A::private_type);; // void B::foo(A::private_type);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:3,Security,Access,Access,3,"// Access control for names used in the declarations of functions; // and function templates should normally be evaluated in the context; // of the declaration, just in case it's a friend of something.; // However, this does not apply to local extern declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Performance,Perform,Perform,4,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:12,Security,access,access-control,12,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:75,Security,access,access,75,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Security,access,accessible,24,/// Is the given member accessible for the purposes of deciding whether to; /// define a special member function as deleted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:67,Security,access,access,67,// There's never a path involved when checking implicit destructor access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:9,Safety,avoid,avoid,9,// TODO: avoid copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:307,Usability,clear,clear,307,"// Initializing a base sub-object is an instance method call on an; // object of the derived class. Otherwise, we have an instance method; // call on an object of the constructed type.; //; // FIXME: If we have a parent, we're initializing the base class subobject; // in aggregate initialization. It's not clear whether the object class; // should be the base class or the derived class in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Modifiability,inherit,inheriting,21,"// If we're using an inheriting constructor to construct an object,; // the object class is the derived class, not the base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to an overloaded operator new or delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,Security,access,access,20,/// Checks implicit access to a member in a structured binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,"/// Checks access to an overloaded member operator, including; /// conversion operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to the target of a friend declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:72,Modifiability,inherit,inheritance,72,"// Friendship lookup is a redeclaration lookup, so there's never an; // inheritance path modifying access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:99,Security,access,access,99,"// Friendship lookup is a redeclaration lookup, so there's never an; // inheritance path modifying access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:103,Performance,perform,performed,103,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,access,121,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to all the declarations in the given result set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:434,Integrability,Depend,Depending,434,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:70,Security,access,access,70,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,access,121,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:212,Security,access,accessed,212,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:341,Security,access,access,341,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:413,Security,access,access,413,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:527,Security,access,access,527,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:649,Security,access,access,649,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:780,Security,access,access,780,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:971,Security,access,accessible,971,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:3,Performance,Perform,Perform,3,// Perform the C++ accessibility checks first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,accessibility,19,// Perform the C++ accessibility checks first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,Security,access,access,20,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:78,Security,access,accessed,78,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:114,Security,access,access,114,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:183,Security,access,access,183,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:250,Security,access,access,250,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:41,Security,access,accessible,41,// @public and @package ivars are always accessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Integrability,interface,interface,74,"// If we are inside a class or category implementation, determine the; // interface we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:22,Integrability,interface,interface,22,"// If we're not in an interface, this ivar is inaccessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Integrability,interface,interface,28,"// If we're inside the same interface that owns the ivar, we're fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:109,Energy Efficiency,power,power,109,"// For most of the platforms we support, native and natural are the same.; // With XL, native is the same as power, natural means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:49,Energy Efficiency,power,power,49,"// If specified then alignment must be a ""small"" power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:69,Testability,log,logic,69,// FIXME: Use DefaultFunctionArrayLValueConversion() in place of the logic; // that adds implicit casts here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:58,Availability,redundant,redundant,58,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:58,Safety,redund,redundant,58,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:181,Safety,avoid,avoid,181,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,Availability,redundant,redundant,15,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,Safety,redund,redundant,15,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:136,Modifiability,variab,variable,136,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:153,Modifiability,variab,variable,153,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:233,Modifiability,variab,variable,233,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:263,Modifiability,variab,variable,263,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:129,Modifiability,variab,variables,129,"// Each rule in Rules must be a strict subset of the attribute's; // SubjectMatch rules. I.e. we're allowed to use; // `apply_to=variables(is_global)` on an attrubute with SubjectList<[Var]>,; // but should not allow `apply_to=variables` on an attribute which has; // `SubjectList<[GlobalVar]>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:227,Modifiability,variab,variables,227,"// Each rule in Rules must be a strict subset of the attribute's; // SubjectMatch rules. I.e. we're allowed to use; // `apply_to=variables(is_global)` on an attrubute with SubjectList<[Var]>,; // but should not allow `apply_to=variables` on an attribute which has; // `SubjectList<[GlobalVar]>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:78,Performance,optimiz,optimize,78,"// In the future, check other pragmas if they're implemented (e.g. pragma; // optimize 0 will probably map to this functionality too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:74,Performance,optimiz,optimizations,74,"// Don't modify the function attributes if it's ""on"". ""on"" resets the; // optimizations to the ones listed on the command line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:13,Safety,unsafe,unsafe,13,"// For value unsafe context, combining this pragma with eval method; // setting is not recommended. See comment in function FixupInvocation#506.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:14,Availability,error,error,14,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:20,Availability,recover,recovery,20,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:20,Safety,recover,recovery,20,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:6,Usability,simpl,simplify,6,"// To simplify the implementation, never keep around an empty stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:258,Testability,log,logic,258,"// Several attributes carry different semantics than the parsing requires, so; // those are opted out of the common argument checks.; //; // We also bail on unknown and ignored attributes because those are handled; // as part of the target-specific handling logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:32,Availability,Avail,Availability,32,"//===--- SemaAvailability.cpp - Availability attribute handling -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file processes the availability attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:407,Availability,avail,availability,407,"//===--- SemaAvailability.cpp - Availability attribute handling -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file processes the availability attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:14,Availability,Avail,AvailabilityAttr,14,// Check each AvailabilityAttr to find the one for this platform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:241,Availability,avail,availability,241,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:166,Integrability,Message,Message,166,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:219,Integrability,message,message,219,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:348,Integrability,message,message,348,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:52,Availability,avail,available,52,"// For typedefs, if the typedef declaration appears available look; // to the underlying type to see if it is more restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:19,Availability,avail,availability,19,"// For +new, infer availability from -init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:32,Availability,avail,availability,32,// Checks if we should emit the availability diagnostic in the context of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:197,Security,access,access,197,"// It is perfectly fine to refer to an 'unavailable' Objective-C method; // when it is referenced from within the @implementation itself. In this; // context, we interpret unavailable as a form of access control.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:40,Availability,avail,availability,40,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Integrability,interface,interface,60,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:90,Performance,load,load,90,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:33,Availability,avail,availability,33,// A category implicitly has the availability of the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:53,Integrability,interface,interface,53,// A category implicitly has the availability of the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,avail,availability,17,// Always enable availability diagnostics for shader models.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:40,Availability,avail,availability,40,// New targets should always warn about availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:147,Availability,avail,availability,147,"// end anonymous namespace; /// Tries to parse a string as ObjC method name.; ///; /// \param Name The string to parse. Expected to originate from availability; /// attribute argument.; /// \param SlotNames The vector that will be populated with slot names. In case; /// of unsuccessful parsing can contain invalid data.; /// \returns A number of method parameters if parsing was successful,; /// std::nullopt otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:21,Availability,avail,availability,21,"/// Actually emit an availability diagnostic for a reference to an unavailable; /// decl.; ///; /// \param Ctx The context that the reference occurred in; /// \param ReferringDecl The exact declaration that was referenced.; /// \param OffendingDecl A related decl to \c ReferringDecl that has an; /// availability attribute corresponding to \c K attached to it. Note that this; /// may not be the same as ReferringDecl, i.e. if an EnumDecl is annotated and; /// we refer to a member EnumConstantDecl, ReferringDecl is the EnumConstantDecl; /// and OffendingDecl is the EnumDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:301,Availability,avail,availability,301,"/// Actually emit an availability diagnostic for a reference to an unavailable; /// decl.; ///; /// \param Ctx The context that the reference occurred in; /// \param ReferringDecl The exact declaration that was referenced.; /// \param OffendingDecl A related decl to \c ReferringDecl that has an; /// availability attribute corresponding to \c K attached to it. Note that this; /// may not be the same as ReferringDecl, i.e. if an EnumDecl is annotated and; /// we refer to a member EnumConstantDecl, ReferringDecl is the EnumConstantDecl; /// and OffendingDecl is the EnumDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:37,Availability,avail,availability,37,"// The declaration can have multiple availability attributes, we are looking; // at one of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:30,Modifiability,inherit,inherited,30,"// If D is a declaration with inherited attributes, the note should; // point to the declaration with actual attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Availability,avail,availability,60,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:98,Deployability,deploy,deployment,98,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:45,Availability,avail,availability,45,// Don't offer a fixit for declarations with availability attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,failure,failures,17,// Most of these failures are due to extra restrictions in ARC;; // reflect that in the primary diagnostic when applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,Availability,avail,availability,38,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:158,Availability,avail,available,158,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:237,Availability,avail,available,237,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,Availability,avail,available,38,/// Stack of potentially nested 'if (@available(...))'s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:43,Availability,avail,available,43,"// If the context of this function is less available than D, we should not; // emit a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Availability,avail,availability,60,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:98,Deployability,deploy,deployment,98,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:3,Availability,avail,available,3,/*@available*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:58,Availability,avail,available,58,// Find the statement which should be enclosed in the if @available check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:131,Availability,avail,available,131,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:83,Integrability,wrap,wrap,83,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:113,Modifiability,variab,variables,113,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:164,Safety,avoid,avoid,164,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,Availability,redundant,redundant,56,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,Safety,redund,redundant,56,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,avail,availability,17,"// This isn't an availability checking 'if', we can just continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:47,Availability,avail,availability,47,"// FIXME: We only examine the pattern decl for availability violations now,; // but we should also examine instantiated templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:75,Availability,avail,availability,75,"// Conservatively search the entire current function scope context for; // availability violations. This ensures we always correctly analyze nested; // classes, blocks, lambdas, etc. that may or may not be inside if(@available); // checks themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:217,Availability,avail,available,217,"// Conservatively search the entire current function scope context for; // availability violations. This ensures we always correctly analyze nested; // classes, blocks, lambdas, etc. that may or may not be inside if(@available); // checks themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:24,Availability,avail,available,24,"// We need to know the @available context in the current function to; // diagnose this use, let DiagnoseUnguardedAvailabilityViolations do that; // when we're done parsing the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,Integrability,rout,routines,32,// Top-level semantics-checking routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Availability,down,down,8,"// Walk down from the CE to the OrigSrcExpr, and mark all immediate; // ImplicitCastExpr's as being part of ExplicitCastExpr. The original CE; // (which is a ExplicitCastExpr), and the OrigSrcExpr are not touched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:33,Integrability,wrap,wrap,33,"// If this is an unbridged cast, wrap the result in an implicit; // cast that yields the unbridged-cast placeholder type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do the semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Performance,perform,perform,87,"// In C++20, if the underlying destination type is a RecordType, Clang; // attempts to perform parentesized aggregate initialization if constructor; // overload fails:; //; // C++20 [expr.static.cast]p4:; // An expression E can be explicitly converted to a type T...if overload; // resolution for a direct-initialization...would find at least one viable; // function ([over.match.viable]), or if T is an aggregate type having a; // first element X and there is an implicit conversion sequence from E to; // the type of X.; //; // If that fails, then we'll generate the diagnostics from the failed; // previous constructor overload attempt. Array initialization, however, is; // not done after attempting constructor overloading, so we exit as there; // won't be a failed overload result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Safety,Detect,Detect,3,"// Detect if both types are (ptr to) class, and note any incompleteness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:199,Availability,down,down,199,"// We've unwrapped at least one level. If the resulting T1 is a (possibly; // multidimensional) array type, any qualifier on any matching layer of; // T2 is considered to correspond to T1. Decompose down to the element; // type of T1 so that we can compare properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:173,Availability,down,downcasts,173,/// CheckDynamicCast - Check that a dynamic_cast\<DestType\>(SrcExpr) is valid.; /// Refer to C++ 5.2.7 for details. Dynamic casts are used mostly for runtime-; /// checked downcasts in class hierarchies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:39,Modifiability,polymorphi,polymorphic,39,"// C++ 5.2.7p6: Otherwise, v shall be [polymorphic].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:23,Availability,avail,available,23,"// dynamic_cast is not available with -fno-rtti.; // As an exception, dynamic_cast to void* is available because it doesn't; // use RTTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:95,Availability,avail,available,95,"// dynamic_cast is not available with -fno-rtti.; // As an exception, dynamic_cast to void* is available because it doesn't; // use RTTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:85,Availability,down,downcast,85,/// Check that a reinterpret_cast\<DestType\>(SrcExpr) is not used as upcast; /// or downcast between respective pointers or references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:97,Availability,avail,available,97,"// Examining subobjects for records is only possible if the complete and; // valid definition is available. Also, template instantiation is not; // allowed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:45,Modifiability,variab,variable,45,// In a cast involving function types with a variable argument list only the; // types of initial arguments that are provided are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Testability,test,test,8,"// This test is outside everything else because it's the only case where; // a non-lvalue-reference target type does not lead to decay.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:50,Performance,perform,performed,50,"/// TryStaticCast - Check if a static cast can be performed, and do so if; /// possible. If @p CStyle, ignore access restrictions on hierarchy casting; /// and casting away constness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:110,Security,access,access,110,"/// TryStaticCast - Check if a static cast can be performed, and do so if; /// possible. If @p CStyle, ignore access restrictions on hierarchy casting; /// and casting away constness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:307,Availability,down,downcast,307,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:442,Availability,down,downcast,442,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:17,Testability,test,tests,17,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:26,Availability,down,downcast,26,"// C++ 5.2.9p5, reference downcast.; // See the function for details.; // DR 427 specifies that this is to be applied before paragraph 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:131,Modifiability,inherit,inheritance,131,// Reverse pointer upcast. C++ 4.10p3 specifies pointer upcast.; // C++ 5.2.9p8 additionally disallows a cast path through virtual inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:139,Security,access,access,139,// Reverse member pointer conversion. C++ 4.11 specifies member pointer; // conversion. C++ 5.2.9p9 has additional information.; // DR54's access restrictions apply here also.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to N2844 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,Availability,down,downcast,32,"// Because we try the reference downcast before this function, from now on; // this is the only cast possibility, so we issue an error if we fail now.; // FIXME: Should allow casting away constness if CStyle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:129,Availability,error,error,129,"// Because we try the reference downcast before this function, from now on; // this is the only cast possibility, so we issue an error if we fail now.; // FIXME: Should allow casting away constness if CStyle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to C++ 5.2.9p5 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:340,Security,access,accessible,340,"// C++ 5.2.9p5: An lvalue of type ""cv1 B"", where B is a class type, can be; // cast to type ""reference to cv2 D"", where D is a class derived from B,; // if a valid standard conversion from ""pointer to D"" to ""pointer to B""; // exists, cv2 >= cv1, and B is not a virtual base class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context. Although the wording of DR54 only applies to the pointer; // variant of this rule, the intent is clearly for it to apply to the this; // conversion as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:476,Usability,clear,clearly,476,"// C++ 5.2.9p5: An lvalue of type ""cv1 B"", where B is a class type, can be; // cast to type ""reference to cv2 D"", where D is a class derived from B,; // if a valid standard conversion from ""pointer to D"" to ""pointer to B""; // exists, cv2 >= cv1, and B is not a virtual base class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context. Although the wording of DR54 only applies to the pointer; // variant of this rule, the intent is clearly for it to apply to the this; // conversion as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to C++ 5.2.9p8 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:371,Security,access,accessible,371,"// C++ 5.2.9p8: An rvalue of type ""pointer to cv1 B"", where B is a class; // type, can be converted to an rvalue of type ""pointer to cv2 D"", where D; // is a class derived from B, if a valid standard conversion from ""pointer; // to D"" to ""pointer to B"" exists, cv2 >= cv1, and B is not a virtual base; // class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:133,Availability,down,downcast,133,/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and; /// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to; /// DestType is possible and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:110,Testability,Test,Tests,110,/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and; /// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to; /// DestType is possible and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Availability,Down,Downcast,3,"// Downcast can only happen in class hierarchies, so we need classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:70,Availability,error,error,70,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:607,Availability,error,error,607,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:613,Integrability,message,message,613,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:228,Availability,error,error,228,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:234,Integrability,message,message,234,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:35,Testability,Test,Tests,35,"/// TryStaticMemberPointerUpcast - Tests whether a conversion according to; /// C++ 5.2.9p9 is valid:; ///; /// An rvalue of type ""pointer to member of D of type cv1 T"" can be; /// converted to an rvalue of type ""pointer to member of B of type cv2 T"",; /// where B is a base class of D [...].; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Availability,down,down,8,"// Lock down the inheritance model right now in MS ABI, whether or not the; // pointee types are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:17,Modifiability,inherit,inheritance,17,"// Lock down the inheritance model right now in MS ABI, whether or not the; // pointee types are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:68,Availability,error,error,68,"// B is a base of D. But is it an allowed base? If not, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Integrability,depend,dependent,46,// Optimistically assume that the delayed and dependent cases; // will work out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:28,Testability,Test,Tests,28,"/// TryStaticImplicitCast - Tests whether a conversion according to C++ 5.2.9p2; /// is valid:; ///; /// An expression e can be explicitly converted to a type T using a; /// @c static_cast if the declaration ""T t(e);"" is well-formed [...].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Performance,perform,perform,87,"/// TryConstCast - See if a const_cast from source to destination is allowed,; /// and perform it if it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:143,Integrability,message,message,143,"// Cannot const_cast non-lvalue to lvalue reference type. But if this; // is C-style, static_cast might find a way, so we simply suggest a; // message and tell the parent to keep searching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:122,Usability,simpl,simply,122,"// Cannot const_cast non-lvalue to lvalue reference type. But if this; // is C-style, static_cast might find a way, so we simply suggest a; // message and tell the parent to keep searching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:23,Usability,clear,clear,23,"// It's not completely clear under the standard whether we can; // const_cast bit-field gl-values. Doing so would not be; // intrinsically complicated, but for now, we say no for; // consistency with other compilers and await the word of the; // committee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:187,Usability,clear,clear,187,"// Cannot cast to non-pointer, non-reference type. Note that, if DestType; // was a reference type, we converted it to a pointer above.; // The status of rvalue references isn't entirely clear, but it looks like; // conversion to them is simply invalid.; // C++ 5.2.11p3: For two pointer types [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:238,Usability,simpl,simply,238,"// Cannot cast to non-pointer, non-reference type. Note that, if DestType; // was a reference type, we converted it to a pointer above.; // The status of rvalue references isn't entirely clear, but it looks like; // conversion to them is simply invalid.; // C++ 5.2.11p3: For two pointer types [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:160,Security,access,accessing,160,// Checks for undefined behavior in reinterpret_cast.; // The cases that is checked for is:; // *reinterpret_cast<T*>(&a); // reinterpret_cast<T&>(a); // where accessing 'a' as type 'T' will result in undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:28,Modifiability,inherit,inheritance,28,// We need to determine the inheritance model that the class will use if; // haven't yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:207,Usability,clear,clear,207,"// C++ 5.2.10p2 has a note that mentions that, subject to all other; // restrictions, a cast to the same type is allowed so long as it does not; // cast away constness. In C++98, the intent was not entirely clear here,; // since all other paragraphs explicitly forbid casts to the same type.; // C++11 clarifies this case with p2.; //; // The only allowed types are: integral, enumeration, pointer, or; // pointer-to-member types. We also won't restrict Obj-C pointers either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:323,Modifiability,config,configurable,323,"// C++0x 5.2.10p8: Converting a pointer to a function into a pointer to; // an object type or vice versa is conditionally-supported.; // Compilers support it in C++03 too, though, because it's necessary for; // casting the return value of dlsym() and GetProcAddress().; // FIXME: Conditionally-supported behavior should be configurable in the; // TargetInfo or similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:19,Testability,log,logic,19,"// Even though the logic below is general enough and can be applied to; // non-OpenCL mode too, we fast-path above because no other languages; // define overlapping address spaces currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Testability,test,test,87,"// C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // This test is outside everything else because it's the only case where; // a non-lvalue-reference target type does not lead to decay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do any other semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:38,Performance,perform,performed,38,"// C++ [expr.cast]p5: The conversions performed by; // - a const_cast,; // - a static_cast,; // - a static_cast followed by a const_cast,; // - a reinterpret_cast, or; // - a reinterpret_cast followed by a const_cast,; // can be performed using the cast notation of explicit type conversion.; // [...] If a conversion can be interpreted in more than one of the ways; // listed above, the interpretation that appears first in the list is used,; // even if a cast resulting from that interpretation is ill-formed.; // In plain language, this means trying a const_cast ...; // Note that for address space we check compatibility after const_cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:229,Performance,perform,performed,229,"// C++ [expr.cast]p5: The conversions performed by; // - a const_cast,; // - a static_cast,; // - a static_cast followed by a const_cast,; // - a reinterpret_cast, or; // - a reinterpret_cast followed by a const_cast,; // can be performed using the cast notation of explicit type conversion.; // [...] If a conversion can be interpreted in more than one of the ways; // listed above, the interpretation that appears first in the list is used,; // even if a cast resulting from that interpretation is ill-formed.; // In plain language, this means trying a const_cast ...; // Note that for address space we check compatibility after const_cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:190,Availability,failure,failure,190,"// If DestType is a function type (not to be confused with the function; // pointer type), it will be possible to resolve the function address,; // but the type cast should be considered as failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do any other semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:180,Availability,error,error,180,/// Checks that a call expression's argument count is at least the desired; /// number. This is useful when doing custom type-checking on a variadic; /// function. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:179,Availability,error,error,179,/// Checks that a call expression's argument count is at most the desired; /// number. This is useful when doing custom type-checking on a variadic; /// function. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:173,Availability,error,error,173,/// Checks that a call expression's argument count is in the desired range. This; /// is useful when doing custom type-checking on a variadic function. Returns; /// true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:143,Availability,error,error,143,/// Checks that a call expression's argument count is the desired number.; /// This is useful when doing custom type-checking. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,down,down,108,"/// Check that the value argument for __builtin_is_aligned(value, alignment) and; /// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer; /// type (but not a function pointer) and that the alignment is a power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:226,Energy Efficiency,power,power-of-two,226,"/// Check that the value argument for __builtin_is_aligned(value, alignment) and; /// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer; /// type (but not a function pointer) and that the alignment is a power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,Availability,error,error,38,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,Integrability,message,message,44,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:55,Integrability,depend,dependent,55,// We can't check validity of alignment if it is value dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the literal in parentheses to attach a source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:40,Performance,perform,performing,40,// Register a note to explain why we're performing the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Availability,error,errors,29,"// Bail out if we've hit any errors, even if we managed to build the; // call. We don't want to produce more than one error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:118,Availability,error,error,118,"// Bail out if we've hit any errors, even if we managed to build the; // call. We don't want to produce more than one error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:219,Safety,safe,safe,219,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Security,access,access,68,"// Try to instantiate the class template as appropriate; otherwise, access to; // its data() may lead to a crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:53,Security,validat,validate,53,"// Second argument is a callable, but we can't fully validate it until we try; // calling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap parentheses around the given pointer. This is not necessary for; // correct code generation, but it means that when we pretty-print the call; // arguments in our diagnostics we will produce '(&s)->n' instead of the; // incorrect '&s->n'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:36,Integrability,depend,depends,36,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:291,Safety,abort,abort,291,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Availability,avail,available,17,"// Scopes aren't available during instantiation. Fortunately, builtin; // functions cannot be template args so they cannot be formed through template; // instantiation. Therefore checking once during the parse is sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,Availability,error,error,27,"// Get the location of the error. If a block literal has been passed; // (BlockExpr) then we can point straight to the offending argument,; // else we just point to the variable reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:169,Modifiability,variab,variable,169,"// Get the location of the error. If a block literal has been passed; // (BlockExpr) then we can point straight to the offending argument,; // else we just point to the variable reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Performance,queue,queue,162,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:292,Performance,queue,queue,292,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:521,Performance,queue,queue,521,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:685,Performance,queue,queue,685,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:106,Modifiability,variab,variable,106,"// With four arguments, there is only one form that the function could be; // called in: no events and no variable arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:61,Availability,error,error,61,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,Safety,detect,detected,38,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:19,Security,access,access,19,/// Returns OpenCL access qual.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Security,Validat,Validates,3,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Security,access,access,17,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Security,access,access,94,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:187,Availability,error,error,187,"// Performs semantic analysis for the read/write_pipe call.; // \param S Reference to the semantic analyzer.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs semantic analysis for the read/write_pipe call.; // \param S Reference to the semantic analyzer.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,error,error,241,"// Performs a semantic analysis on the {work_group_/sub_group_; // /_}reserve_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on the {work_group_/sub_group_; // /_}reserve_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:236,Availability,error,error,236,"// Performs a semantic analysis on {work_group_/sub_group_; // /_}commit_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on {work_group_/sub_group_; // /_}commit_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:227,Availability,error,error,227,"// Performs a semantic analysis on the call to built-in Pipe; // Query Functions.; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on the call to built-in Pipe; // Query Functions.; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:305,Availability,error,error,305,"// OpenCL v2.0 s6.13.9 - Address space qualifier functions.; // Performs semantic analysis for the to_global/local/private call.; // \param S Reference to the semantic analyzer.; // \param BuiltinID ID of the builtin function.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:64,Performance,Perform,Performs,64,"// OpenCL v2.0 s6.13.9 - Address space qualifier functions.; // Performs semantic analysis for the to_global/local/private call.; // \param S Reference to the semantic analyzer.; // \param BuiltinID ID of the builtin function.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,Availability,error,error,11,// Emit an error and return true if the current object format type is in the; // list of unsupported types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,Availability,error,error,11,// Emit an error and return true if the current architecture is not in the list; // of supported architectures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,error,error,108,"// Check if \p Ty is a valid type for the elementwise math builtins. If it is; // not a valid type, emit an error message and return true. Otherwise return; // false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:114,Integrability,message,message,114,"// Check if \p Ty is a valid type for the elementwise math builtins. If it is; // not a valid type, emit an error message and return true. Otherwise return; // false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:39,Availability,error,errors,39,"// Don't diagnose previously diagnosed errors.; // If any arguments are required to be ICE's, check and diagnose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Deployability,release,release,16,"// The acquire, release, and no fence variants are ARM and AArch64 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:130,Deployability,release,release,130,"// TheCall will be freed by the smart pointer here, but that's fine, since; // SemaBuiltinShuffleVector guts it, but then doesn't release it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:111,Integrability,depend,dependent,111,// We warn about copying to or from `nullptr` pointers when `size` is; // greater than 0. When `size` is value dependent we cannot evaluate its; // value so we bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:103,Integrability,depend,dependent,103,// We warn about filling to `nullptr` pointers when `size` is greater than; // 0. When `size` is value dependent we cannot evaluate its value so we bail; // out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:185,Performance,load,load,185,/// getNeonEltType - Return the QualType corresponding to the elements of; /// the vector type specified by the NeonTypeFlags. This is used to check; /// the pointer arguments for Neon load/store intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform all the immediate checks for this builtin call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Availability,avail,available,29,// Check intrinsics that are available in [sve2p1 or sme/sme2].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Security,validat,validate,68,"// For NEON intrinsics which are overloaded on vector element type, validate; // the immediate which specifies which variant to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Performance,load,loaded,56,"// In general, we allow ints, floats and pointers to be loaded and stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:136,Availability,error,error,136,"// For intrinsics which take an immediate value as part of the instruction,; // range check them here.; // FIXME: VFP Intrinsics should error if VFP not present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,Security,access,access,49,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:87,Security,access,access,87,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:153,Security,access,access,153,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:175,Security,access,access,175,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:314,Testability,test,tests,314,"// CheckMipsBuiltinArgument - Checks the constant value passed to the; // intrinsic is correct. The switch statement is ordered by DSP, MSA. The; // ordering for DSP is unspecified. MSA is ordered by the data format used; // by the underlying instruction i.e., df/m, df/n and then by size.; //; // FIXME: The size tests here should instead be tablegen'd along with the; // definitions from include/clang/Basic/BuiltinsMips.def.; // FIXME: GCC is strict on signedness for some of these intrinsics, we should; // be too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:32,Performance,load,loads,32,// Memory offsets and immediate loads.; // These intrinsics take a signed 10 bit immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:264,Availability,Mask,Mask,264,"/// DecodePPCMMATypeFromStr - This decodes one PPC MMA type descriptor from Str,; /// advancing the pointer over the consumed characters. The decoded type is; /// returned. If the decoded type represents a constant integer with a; /// constraint on its value then Mask is set to that value. The type descriptors; /// used in Str are specific to PPC MMA builtins and are documented in the file; /// defining the PPC builtins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:135,Integrability,wrap,wrap,135,"/// Returns true if the argument consists of one contiguous run of 1s with any; /// number of 0s on either side. The 1s are allowed to wrap from LSB to MSB, so; /// 0x000FFF0, 0x0000FFFF, 0xFF0000FF, 0x0 are all runs. 0x0F0F0000 is not,; /// since all 1s are not contiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:54,Availability,Avail,Available,54,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Availability,avail,available,116,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,Energy Efficiency,Power,PowerPC,27,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:159,Modifiability,extend,extended,159,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Availability,mask,mask,58,"// For __rlwnm, __rlwimi and __rldimi, the last parameter mask must; // be a constant that represents a contiguous bit field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:65,Availability,error,error,65,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:75,Integrability,message,message,75,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:28,Safety,detect,detect,28,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Availability,Error,Error,3,// Error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:9,Integrability,message,message,9,// Error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:148,Availability,error,error,148,"// Given that caller already checked isRVVType() before calling this function,; // if we don't have at least zve32x supported, then we need to emit error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:35,Availability,error,error,35,"// Note that we don't force a hard error on the range check here, allowing; // template-generated or macro-generated dead code to potentially have out-of-; // range values. These need to code generate, but don't need to necessarily; // make any sense. We use a warning that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:289,Availability,error,error,289,"// Note that we don't force a hard error on the range check here, allowing; // template-generated or macro-generated dead code to potentially have out-of-; // range values. These need to code generate, but don't need to necessarily; // make any sense. We use a warning that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:169,Safety,safe,safe,169,"// 16 byte ByVal alignment not due to a vector member is not honoured by XL; // on AIX. Emit a warning here that users are generating binary incompatible; // code to be safe.; // Here we try to get information about the alignment of the struct member; // from the struct passed to the caller function. We only warn when the struct; // is passed byval, hence the series of checks and early returns if we are a not; // passing a struct byval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:8,Safety,safe,safety,8,// Type safety checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:137,Availability,avail,available,137,"// If the callee has an AArch64 SME attribute to indicate that it is an; // __arm_streaming function, then the caller requires SME to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:72,Safety,safe,safety,72,/// CheckConstructorCall - Check a constructor call for correctness and safety; /// properties not enforced by the C type system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,Safety,safe,safety,86,/// CheckFunctionCall - Check a direct function call for various correctness; /// and safety properties not strictly enforced by the C type system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:45,Integrability,depend,depending,45,"// ImplicitThis may or may not be a pointer, depending on whether . or -> is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Usability,simpl,simple,73,"// None of the checks below are needed for functions that don't have; // simple names (e.g., C++ conversion functions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Availability,avail,available,68,"/// Checks function calls when a FunctionDecl or a NamedDecl is not available,; /// such as function pointers returned from functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:145,Integrability,synchroniz,synchronization,145,// All the non-OpenCL operations take one of the following forms.; // The OpenCL operations take the __c11 forms with one extra argument for; // synchronization scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:7,Availability,mask,mask,7,// Bit mask for extra allowed value types other than integers for atomic; // arithmetic operations. Add/sub allow pointer and floating point. Min/max; // allow floating point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Availability,error,errors,94,"// GCC does not enforce these rules for GNU atomics, but we do to help catch; // trivial type errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Integrability,inject,inject,142,// All atomic operations have an overload which takes a pointer to a volatile; // 'A'. We shouldn't let the volatile-ness of the pointee-type inject itself; // into the result or the other operands. Similarly atomic_load takes a; // pointer to a const 'A'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Security,inject,inject,142,// All atomic operations have an overload which takes a pointer to a volatile; // 'A'. We shouldn't let the volatile-ness of the pointee-type inject itself; // into the result or the other operands. Similarly atomic_load takes a; // pointer to a const 'A'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:2,Availability,failure,failure,2,/*failure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:317,Availability,error,error,317,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Performance,perform,perform,63,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:174,Integrability,rout,routines,174,"/// We have a call to a function like __sync_fetch_and_add, which is an; /// overloaded function based on the pointer type of its first argument.; /// The main BuildCallExpr routines have already promoted the types of; /// arguments because all of these calls are prototyped as void(...).; ///; /// This function goes through and does final semantic checking for these; /// builtins, as well as generating any warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform builtin lookup to avoid redeclaring it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Safety,avoid,avoid,29,// Perform builtin lookup to avoid redeclaring it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:132,Availability,error,error,132,"// GCC does an implicit conversion to the pointer or integer ValType. This; // can fail in some cases (1i -> int**), check for this error case now.; // Initialize the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Security,access,access,142,"// Inspect the last argument of the nontemporal builtin. This should always; // be a pointer type, from which we imply the type of the memory access.; // Because it is a pointer type, we don't have to worry about any implicit; // casts here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:180,Usability,simpl,simplify,180,/// CheckObjCString - Checks that the argument to the builtin; /// CFString constructor is correct; /// Note: It might also make sense to do the UTF-16 conversion here (would; /// simplify the backend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Availability,failure,failure,24,// Check for conversion failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:102,Availability,error,error,102,/// Check the arguments to '__builtin_va_start' or '__builtin_ms_va_start'; /// for validity. Emit an error and return true on failure; return false; /// on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:127,Availability,failure,failure,127,/// Check the arguments to '__builtin_va_start' or '__builtin_ms_va_start'; /// for validity. Emit an error and return true on failure; return false; /// on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,Security,validat,validate,34,// __va_start on Windows does not validate the parameter qualifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:77,Safety,safe,safe,77,"// Make sure any conversions are pushed back into the call; this is; // type safe since unordered compare builtins are declared as ""_Bool; // foo(...)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Availability,mask,mask,63,"// __builtin_isfpclass has integer parameter that specify test mask. It is; // passed in (...), so it should be analyzed completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Testability,test,test,58,"// __builtin_isfpclass has integer parameter that specify test mask. It is; // passed in (...), so it should be analyzed completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Performance,Perform,Perform,4,/// Perform semantic analysis for a call to __builtin_complex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:96,Availability,mask,mask,96,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,mask,mask,108,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:136,Availability,mask,mask,136,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,Availability,mask,mask,86,"// Check to see if we have a call with 2 vector arguments, the unary shuffle; // with mask. If so, verify that RHS is an integer vector type with the; // same number of elts as lhs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Energy Efficiency,power,power,116,"/// Handle __builtin_alloca_with_align. This is declared; /// as (size_t, size_t) where the second size_t must be a power of 2 greater; /// than 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:89,Safety,avoid,avoid,89,// Check formatting specifiers. NOTE: We're only doing this for the non-size; // call to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Energy Efficiency,power,power,116,/// SemaBuiltinConstantArgPower2 - Check if argument ArgNum of TheCall is a; /// constant expression representing a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,Energy Efficiency,power,power,31,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:98,Energy Efficiency,power,power,98,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:20,Testability,test,test,20,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:48,Availability,down,down,48,"// Check if it's a shifted byte, by shifting it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,Security,validat,validates,13,// This code validates writes to PSTATE registers.; // Not a write.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,Security,access,accesses,31,// The 128-bit system register accesses do not touch PSTATE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,Security,access,accesses,30,"// These are the named PSTATE accesses using ""MSR (immediate)"" instructions,; // along with the upper limit on the immediates allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Security,validat,validating,56,"// If this is not a named PSTATE, just continue without validating, as this; // will be lowered to an ""MSR (register)"" instruction directly",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:91,Availability,error,error,91,/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.; /// Emit an error and return true on failure; return false on success.; /// TypeStr is a string containing the type descriptor of the value returned by; /// the builtin and the descriptors of the expected type of the arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Availability,failure,failure,116,/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.; /// Emit an error and return true on failure; return false on success.; /// TypeStr is a string containing the type descriptor of the value returned by; /// the builtin and the descriptors of the expected type of the arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:23,Availability,Mask,Mask,23,"// If the value of the Mask is not 0, we have a constraint in the size of; // the integer argument so here we ensure the argument is a constant that; // is in the valid range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,error,error,241,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:247,Integrability,message,message,247,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Usability,clear,clear,58,"// A string has been found with all arguments covered, so clear out; // the diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:9,Deployability,update,update,9,// Don't update if a previous string covers all arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,Integrability,wrap,wrapper,13,// This is a wrapper class around StringLiteral to support offsetted string; // literals as format strings. It takes the offset into account when returning; // the string and its length or the source locations to display notes correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:140,Integrability,depend,dependent,140,// Technically -Wformat-nonliteral does not warn about this case.; // The behavior of printf and friends in this case is implementation; // dependent. Ideally if the format string cannot be null then; // it should have a 'nonnull' attribute in the function prototype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:123,Security,secur,security,123,"// While __func__, etc., are technically not string literals, they; // cannot contain format specifiers and thus are not a security; // liability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:32,Availability,error,errors,32,"// As an exception, do not flag errors for variables binding to; // const string literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:43,Modifiability,variab,variables,43,"// As an exception, do not flag errors for variables binding to; // const string literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:441,Testability,log,logmessage,441,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:509,Testability,log,logmessage,509,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:875,Testability,log,logstring,875,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:1149,Testability,log,log,1149,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:550,Testability,log,logic,550,"// CHECK: format string is not a string literal.; //; // Dynamically generated format strings are difficult to; // automatically vet at compile time. Requiring that format strings; // are string literals: (1) permits the checking of format strings by; // the compiler and thereby (2) can practically remove the source of; // many format string exploits.; // Format string can be either ObjC string (e.g. @""%d"") or; // C string (e.g. ""%d""); // ObjC string uses the same format specifiers as C string, so we can use; // the same format string checking logic for both ObjC and C strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Safety,detect,detected,56,// Generate a diagnostic where an uncovered argument is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:83,Safety,safe,safe,83,"// Strftime is particular as it always uses a single 'time' argument,; // so it is safe to pass a non-literal string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,Security,secur,security,59,"// If there are no arguments specified, warn with -Wformat-security, otherwise; // warn only with -Wformat-nonliteral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,Availability,error,error,49,// The presence of a null character is likely an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Availability,error,error,50,// Note that this may return NULL if there was an error parsing or building; // one of the argument expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:130,Integrability,message,messages,130,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:256,Integrability,message,message,256,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:653,Integrability,message,message,653,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Availability,error,errors,62,// Don't do any more checking. We will just emit; // spurious errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:177,Safety,safe,safe,177,"// Type check the data argument. It should be an 'int'.; // Although not in conformance with C99, we also allow the argument to be; // an 'unsigned int' as that is a reasonably safe case. GCC also; // doesn't emit a warning for that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Availability,error,errors,62,// Don't do any more checking. We will just emit; // spurious errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Availability,error,error,162,// The check to see if the argIndex is valid will come later.; // We set the bit here because we may exit early from this; // function if we encounter some other error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Integrability,depend,depend,24,// The remaining checks depend on the data arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Modifiability,layers,layers,29,// Use a 'while' to peel off layers of typedefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,Availability,error,error,44,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Integrability,message,message,50,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:199,Integrability,message,message,199,"// In this case, the expression could be printed using a different; // specifier, but we've decided that the specifier is probably correct; // and we should cast instead. Just use the normal warning message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Availability,error,error,162,// The check to see if the argIndex is valid will come later.; // We set the bit here because we may exit early from this; // function if we encounter some other error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Integrability,depend,depend,24,// The remaining checks depend on the data arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Safety,Detect,Detect,4,/// Detect if \c SizeofExpr is likely to calculate the sizeof an object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:67,Availability,error,error,67,"// If we're memsetting or bzeroing 0 bytes, then this is likely an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:109,Availability,error,error,109,"// If the second argument to a memset is a sizeof expression and the third; // isn't, this is also likely an error. This should catch; // 'memset(buf, sizeof(buf), 0xff)'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:114,Safety,abort,abort,114,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Security,Validat,Validate,63,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:74,Performance,cache,cache,74,"// We only compute IDs for expressions if the warning is enabled, and; // cache the sizeof arg's ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:19,Integrability,rout,routine,19,// A little helper routine: ignore addition and subtraction of integer literals.; // This intentionally does not ignore all integer constant expressions because; // we don't want to remove sizeof().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Modifiability,flexible,flexible,47,"// Only handle constant-sized or VLAs, but not flexible members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:109,Modifiability,enhance,enhanced,109,"// Output a FIXIT hint if the destination is an array (rather than a; // pointer to an array). This could be enhanced to handle some; // pointers if we know the actual size, like if DstArg is 'array+2'; // we could say 'sizeof(array)-2'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Usability,simpl,simpler,63,// Prefer something that doesn't involve a cast to make things simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:273,Availability,failure,failure,273,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:139,Energy Efficiency,allocate,allocate,139,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:237,Energy Efficiency,allocate,allocate,237,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:245,Modifiability,variab,variable,245,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:222,Safety,detect,detect,222,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:276,Usability,clear,clearly,276,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:82,Energy Efficiency,reduce,reduced,82,// We need a 1-bit-wider range if:; // 1) LHS can be negative: least value can be reduced.; // 2) RHS can be negative: greatest value can be increased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Usability,Simpl,Simple,3,"// Simple assignments just pass through the RHS, which will have; // been coerced to the LHS type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:52,Testability,log,logically,52,// ...except that we want to treat '1 << (blah)' as logically; // positive. It's an important idiom.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:76,Performance,perform,performed,76,"// Combine the two ranges, but limit the result to the type in which we; // performed the computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:36,Performance,perform,performed,36,// The type the comparison is being performed in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:23,Integrability,depend,dependent,23,// Don't analyze value-dependent comparisons directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Safety,Avoid,Avoid,3,// Avoid warning about comparison of integers with different signs when; // RHS/LHS has a `typeof(E)` type whose sign is different from the sign of; // the type of `E`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:25,Integrability,depend,dependent,25,// Ignore value- or type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:66,Energy Efficiency,reduce,reduce,66,"// In C, the macro 'true' from stdbool.h will evaluate to '1'; To reduce; // false positives where the user is demonstrating they intend to use the; // bit-field as a Boolean, check to see if the value is 1 and we're assigning; // to a one-bit bit-field to see if the value came from a macro named 'true'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:22,Usability,simpl,simple,22,/// Analyze the given simple or compound assignment for warning-worthy; /// operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Availability,down,down,50,"// FIXME: Force the precision of the source value down so we don't print; // digits which are usually useless (we don't really care here if we; // truncate a digit by accident in edge cases). Ideally, APFloat::toString; // would automatically print the shortest representation, but it's a bit; // tricky to implement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,Safety,safe,safe,30,// Return if target type is a safe conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:21,Integrability,wrap,wrapped,21,// __null is usually wrapped in a macro. Go up a macro if that is the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:272,Safety,detect,detect,272,"// If the conversion context location is invalid don't complain. We also; // don't want to emit a warning if the issue occurs from the expansion of; // a system macro. The problem is that 'getSpellingLoc()' is slow, so we; // delay this check as long as possible. Once we detect we are in that; // scenario, we just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:121,Availability,error,error,121,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:65,Testability,log,logical,65,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Testability,assert,assert,108,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:26,Performance,scalab,scalable,26,// Handle conversion from scalable to fixed when msve-vector-bits is; // specified,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Safety,Detect,Detect,3,"// Detect the case where a call result is converted from floating-point to; // to bool, and the final argument to the call is converted from bool, to; // discover this typo:; //; // bool b = fabs(x < 1.0); // should be ""bool b = fabs(x) < 1.0;""; //; // FIXME: This is an incredibly special case; is there some more general; // way to detect this class of misplaced-parentheses bug?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:334,Safety,detect,detect,334,"// Detect the case where a call result is converted from floating-point to; // to bool, and the final argument to the call is converted from bool, to; // discover this typo:; //; // bool b = fabs(x < 1.0); // should be ""bool b = fabs(x) < 1.0;""; //; // FIXME: This is an incredibly special case; is there some more general; // way to detect this class of misplaced-parentheses bug?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:113,Energy Efficiency,reduce,reduced,113,"// TODO: remove this early return once the false positives for constant->bool; // in templates, macros, etc, are reduced or removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:80,Testability,log,logical,80,/// Check conversion of given expression to boolean.; /// Input argument E is a logical expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:113,Performance,optimiz,optimization,113,// Go ahead and check any implicit conversions we might have skipped.; // The non-canonical typecheck is just an optimization;; // CheckImplicitConversion will filter out dead implicit conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:12,Usability,simpl,simple,12,// And with simple assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Testability,log,logical,47,// Ignore checking string literals that are in logical and operators.; // This is a common pattern for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:103,Testability,assert,asserts,103,// Ignore checking string literals that are in logical and operators.; // This is a common pattern for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:37,Integrability,depend,dependent,37,// Don't diagnose for value- or type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:192,Modifiability,variab,variable,192,"// Check for array bounds violations in cases where the check isn't triggered; // elsewhere for other Expr types (like BinaryOperators), e.g. when an; // ArraySubscriptExpr is on the RHS of a variable initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:41,Modifiability,variab,variable,41,// This is not the right CC for (e.g.) a variable initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:106,Testability,log,logical,106,/// CheckBoolLikeConversion - Check conversion of given expression to boolean.; /// Input argument E is a logical expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform path compression as we go.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,Energy Efficiency,reduce,reduce,59,/// Expressions to check later. We defer checking these to reduce; /// stack usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,down,downgrade,241,"/// RAII object wrapping the visitation of a sequenced subexpression of an; /// expression. At the end of this process, the side-effects of the evaluation; /// become sequenced with respect to the value computation of the result, so; /// we downgrade any UK_ModAsSideEffect within the evaluation to; /// UK_ModAsValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping the visitation of a sequenced subexpression of an; /// expression. At the end of this process, the side-effects of the evaluation; /// become sequenced with respect to the value computation of the result, so; /// we downgrade any UK_ModAsSideEffect within the evaluation to; /// UK_ModAsValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:120,Usability,clear,clearing,120,"// Add a new usage with usage kind UK_ModAsValue, and then restore; // the previous usage with UK_ModAsSideEffect (thus clearing it if; // the previous one was empty).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping the visitation of a subexpression which we might; /// choose to evaluate as a constant. If any subexpression is evaluated and; /// found to be non-constant, this allows us to suppress the evaluation of; /// the outer expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:1223,Availability,down,downgrade,1223,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:989,Integrability,wrap,wrap,989,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:705,Safety,detect,detect,705,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:186,Deployability,update,update,186,"// C++11 [expr.ass]p1:; // [...] the assignment is sequenced after the value computation; // of the right and left operands, [...]; //; // so check it before inspecting the operands and update the; // map afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,"// C++11 [expr.log.or]p2:; // If the second expression is evaluated, every value computation and; // side effect associated with the first expression is sequenced before; // every value computation and side effect associated with the; // second expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,// C++11 [expr.log.or]p1:; // [...] the second operand is not evaluated if the first operand; // evaluates to true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,"// C++11 [expr.log.and]p2:; // If the second expression is evaluated, every value computation and; // side effect associated with the first expression is sequenced before; // every value computation and side effect associated with the; // second expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,// C++11 [expr.log.and]p1:; // [...] the second operand is not evaluated if the first operand is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:581,Availability,down,downgrade,581,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:471,Integrability,wrap,wrap,471,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:192,Safety,avoid,avoid,192,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:383,Safety,detect,detect,383,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:184,Performance,perform,performed,184,"/// CheckParmsForFunctionDef - Check that the parameters of the given; /// function are appropriate for the definition of a function. This; /// takes care of any checks that cannot be performed on the; /// declaration itself, e.g., that the types of each of the function; /// parameters are complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:228,Modifiability,variab,variable,228,"// C99 6.7.5.3p12:; // If the function declarator is not part of a definition of that; // function, parameters may have incomplete type and may use the [*]; // notation in their sequences of declarator specifiers to specify; // variable length array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:179,Performance,perform,perform,179,"// If the parameter is a c++ class type and it has to be destructed in the; // callee function, declare the destructor so that it can be called by the; // callee function. Do not perform any direct access check on the dtor here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:198,Security,access,access,198,"// If the parameter is a c++ class type and it has to be destructed in the; // callee function, declare the destructor so that it can be called by the; // callee function. Do not perform any direct access check on the dtor here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Modifiability,variab,variable,62,"// FIXME: If VD is captured by copy or is an escaping __block variable,; // use the alignment of VD's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Depend,Dependent,3,// Dependent alignment cannot be resolved -> bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:10,Integrability,depend,dependent,10,// Ignore dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Integrability,message,message,94,"// Need to compute max possible elements in address space, since that; // is included in diag message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:8,Integrability,message,message,8,"// Diag message shows element size in bits and in ""bytes"" (platform-; // dependent CharUnits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Integrability,depend,dependent,73,"// Diag message shows element size in bits and in ""bytes"" (platform-; // dependent CharUnits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:279,Security,access,access,279,"// It is possible that the type of the base expression after; // IgnoreParenCasts is incomplete, even though the type of the base; // expression before IgnoreParenCasts is complete (see PR39746 for an; // example). In this case we have no information about whether the array; // access exceeds the array bounds. However we can still diagnose an array; // access which precedes the array bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:355,Security,access,access,355,"// It is possible that the type of the base expression after; // IgnoreParenCasts is incomplete, even though the type of the base; // expression before IgnoreParenCasts is complete (see PR39746 for an; // example). In this case we have no information about whether the array; // access exceeds the array bounds. However we can still diagnose an array; // access which precedes the array bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:55,Modifiability,variab,variable,55,// namespace; /// Consider whether capturing the given variable can possibly lead to; /// a retain cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:42,Modifiability,variab,variable,42,"// In ARC, it's captured strongly iff the variable has __strong; // lifetime. In MRR, it's captured strongly if the variable is; // __block and has an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Modifiability,variab,variable,116,"// In ARC, it's captured strongly iff the variable has __strong; // lifetime. In MRR, it's captured strongly if the variable is; // __block and has an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:84,Modifiability,variab,variable,84,// namespace; /// Check whether the given argument is a block which captures a; /// variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:12,Integrability,message,message,12,/// Check a message send to see if it's likely to cause a retain cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Modifiability,variab,variable,17,// Try to find a variable that the receiver is strongly owned by.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Modifiability,variab,variable,47,"// Because we don't have an expression for the variable, we have to set the; // location explicitly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:10,Modifiability,variab,variables,10,// Member variables require a different approach to check for self moves.; // MemberExpr's are the same if every nested MemberExpr refers to the same; // Decl and that the base Expr's are DeclRefExpr's with the same Decl or; // the base Expr's are CXXThisExpr's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:412,Performance,perform,performed,412,"//===--- CHECK: pointer_with_type_tag attribute: datatypes should match ----//; /// Given a type tag expression find the type tag itself.; ///; /// \param TypeExpr Type tag expression, as it appears in user's code.; ///; /// \param VD Declaration of an identifier that appears in a type tag.; ///; /// \param MagicValue Type tag magic value.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:413,Performance,perform,performed,413,"/// Retrieve the C type corresponding to type tag TypeExpr.; ///; /// \param TypeExpr Expression that specifies a type tag.; ///; /// \param MagicValues Registered magic values.; ///; /// \param FoundWrongKind Set to true if a type tag was found, but of a wrong; /// kind.; ///; /// \param TypeInfo Information about the corresponding C type.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.; ///; /// \returns true if the corresponding C type was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Modifiability,Variab,Variable,3,// Variable declaration that has type_tag_for_datatype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:194,Integrability,depend,depending,194,"// C++11 [basic.fundamental] p1:; // Plain char, signed char, and unsigned char are three distinct types.; //; // But we treat plain `char' as equivalent to `signed char' or `unsigned; // char' depending on the current char signedness mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,Security,access,access,34,// Synthesize offset of the whole access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:268,Energy Efficiency,reduce,reduced,268,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Usability,Intuit,Intuitively,73,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Deployability,Update,Update,3,// Update call argument to use the possibly converted matrix argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:80,Integrability,Depend,DependentTy,80,"// If any part of the result matrix type is still pending, just use; // Context.DependentTy, until all parts are resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:84,Integrability,rout,routines,84,"/// The type of a name-lookup filter, which can be provided to the; /// name-lookup routines to specify which declarations should be included in; /// the result set (when it returns true) and which declarations should be; /// filtered out (returns false).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Performance,optimiz,optimized,41,"/// An entry in the shadow map, which is optimized to store; /// a single (declaration, index) mapping (the common case) but; /// can also store a list of (declaration, index) mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Energy Efficiency,allocate,allocate,26,/// The allocator used to allocate new code-completion strings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:101,Modifiability,inherit,inheritance,101,"/// A list of shadow maps, which is used to model name hiding at; /// different levels of, e.g., the inheritance hierarchy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,Availability,avail,available,213,"/// Set the cv-qualifiers on the object type, for us in filtering; /// calls to member functions.; ///; /// When there are qualifiers in this set, they will be used to filter; /// out member functions that aren't available (because there will be a; /// cv-qualifier mismatch) or prefer functions with an exact qualifier; /// match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:35,Energy Efficiency,allocate,allocate,35,/// Retrieve the allocator used to allocate code completion strings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:168,Security,access,access,168,"/// Decide whether or not a use of function Decl can be a call.; ///; /// \param ND the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:179,Security,access,access,179,"/// Decide whether or not a use of member function Decl can be a call.; ///; /// \param Method the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:500,Security,access,access,500,"/// Add a new result to this result set, where we already know; /// the hiding declaration (if any).; ///; /// \param R the result to add (if it is unique).; ///; /// \param CurContext the context in which this result will be named.; ///; /// \param Hiding the declaration that hides the result.; ///; /// \param InBaseClass whether the result was found in a base; /// class of the searched context.; ///; /// \param BaseExprType the type of expression that precedes the ""."" or ""->""; /// in a member access expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Testability,Log,Logical,3,"// Logical operators, assume we want bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Testability,assert,assertion,55,"// FIXME(ibiryukov): handle the missing op, re-add the assertion.; // assert(false && ""unhandled binary op"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:70,Testability,assert,assert,70,"// FIXME(ibiryukov): handle the missing op, re-add the assertion.; // assert(false && ""unhandled binary op"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:32,Deployability,update,update,32,"// Keep the expected type, only update the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:6,Usability,simpl,simplified,6,"/// A simplified classification of types used to determine whether two; /// types are ""similar enough"" when adjusting priorities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:76,Availability,down,down,76,"// Dig through references, function pointers, and block pointers to; // get down to the likely type of an expression when the entity is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:83,Integrability,message,message,83,"// Use CCP_Type for type declarations unless we're in a statement, Objective-C; // message receiver, or parenthesized expression context. There, it's as; // likely that the user will want to write a type as other declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Integrability,Protocol,Protocols,3,// Protocols are in distinct namespaces from everything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,Integrability,depend,depending,213,"// Will Candidate ever be called on the object, when overloaded with Incumbent?; // Returns Dominates if Candidate is always called, Dominated if Incumbent is; // always called, BothViable if either may be called depending on arguments.; // Precondition: must actually be overloads!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:92,Security,access,access,92,"// We apply heuristics only to CCC_Symbol:; // * CCC_{Arrow,Dot}MemberAccess reflect member access expressions:; // f.method() and f->method(). These are always calls.; // * A qualified name to a member function may *not* be a call. We have to; // subdivide the cases: For example, f.Base::method(), which is regarded as; // CCC_Symbol, should be a call.; // * Non-member functions and static member functions are always considered; // calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Detect,Detect,3,// Detect cases where a ref-qualified method cannot be invoked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:15,Integrability,interface,interfaces,15,// Objective-C interfaces names are not filtered by this method because they; // can be used in a class property expression. We can still filter out; // @class declarations though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Integrability,interface,interfaces,31,"// For purposes of this check, interfaces match too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Performance,perform,perform,19,"// FIXME: We could perform more analysis here to determine whether a; // particular class type has any conversions to Objective-C types. For now,; // just accept all class types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:77,Modifiability,variab,variable,77,/// Determines whether the given declaration is an Objective-C; /// instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Security,access,access-checking,41,// NamingClass and BaseType are used for access-checking. See; // Sema::IsSimplyAccessible for details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Security,access,access,27,"// Naming class to use for access check. In most cases it was provided; // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),; // for unqualified lookup we fallback to the \p Ctx in which we found the; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:99,Security,access,access,99,"// Naming class to use for access check. In most cases it was provided; // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),; // for unqualified lookup we fallback to the \p Ctx in which we found the; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:130,Safety,avoid,avoid,130,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,Security,access,access,201,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,Security,access,access,58,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:136,Usability,clear,clear,136,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:144,Integrability,rout,routine,144,/// Retrieve the string representation of the given type as a string; /// that has the appropriate lifetime for code completion.; ///; /// This routine provides a fast path where we provide constant strings for; /// common type names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:45,Integrability,depend,dependent,45,// using typename qualifier::name (only in a dependent context),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:40,Integrability,depend,depending,40,"// ""return expression ;"" or ""return ;"", depending on the return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:7,Integrability,interface,interface,7,// The interface can be NULL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:144,Availability,avail,available,144,"// Params are unavailable in FunctionTypeLoc if the FunctionType is invalid.; // It would be better to pass in the param Type, which is usually available.; // But this case is rare, so just pretend we fell back to int as elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:22,Integrability,depend,dependent,22,// The argument for a dependent or non-block parameter is a placeholder; // containing that parameter's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Usability,simpl,simple,27,// Non-variadic macros are simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:118,Energy Efficiency,allocate,allocated,118,"/// If possible, create a new code completion string for the given; /// result.; ///; /// \returns Either a new, heap-allocated code completion string describing; /// how to use this result, or NULL to indicate that the string or name of the; /// result is all that is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Avoid,Avoid,3,// Avoid running it if this is not a call: We should emit *all* template; // parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:338,Safety,Detect,Detect,338,"// Some of the function template arguments cannot be deduced from a; // function call, so we introduce an explicit template argument list; // containing all of the arguments up to the first deducible argument.; //; // Or, if this isn't a call, emit all the template arguments; // to disambiguate the (potential) overloads.; //; // FIXME: Detect cases where the function parameters can be deduced from; // the surrounding context, as per [temp.deduct.funcaddr].; // e.g.,; // template <class T> void foo(T);; // void (*f)(int) = foo;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:162,Safety,avoid,avoids,162,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:151,Usability,clear,clear,151,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Availability,avail,availability,24,"// FIXME: Set priority, availability appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Performance,Load,Load,3,// Load the named module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:182,Integrability,message,message,182,"// If we're in a context where we might have an expression (rather than a; // declaration), and what we've seen so far is an Objective-C type that could; // be a receiver of a class message, this may be a class message send with; // the initial opening bracket '[' missing. Add appropriate completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:211,Integrability,message,message,211,"// If we're in a context where we might have an expression (rather than a; // declaration), and what we've seen so far is an Objective-C type that could; // be a receiver of a class message, this may be a class message send with; // the initial opening bracket '[' missing. Add appropriate completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Availability,redundant,redundant,48,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Safety,avoid,avoid,31,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Safety,redund,redundant,48,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Performance,Perform,Perform,4,/// Perform code-completion in an expression context when we know what; /// type we're looking for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:32,Integrability,protocol,protocols,32,// Add properties in referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Performance,perform,performing,24,"// Indicate that we are performing a member access, and the cv-qualifiers; // for the base object type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Security,access,access,44,"// Indicate that we are performing a member access, and the cv-qualifiers; // for the base object type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Security,Access,Access,3,"// Access to a C/C++ class, struct, or union.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,Integrability,depend,dependent,143,"// The ""template"" keyword can follow ""->"" or ""."" in the grammar.; // However, we only want to suggest the template keyword if something; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:194,Integrability,depend,dependent,194,"// Returns the RecordDecl inside the BaseType, falling back to primary template; // in case of specializations. Since we might not have a decl for the; // instantiation/specialization yet, e.g. dependent code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,Availability,down,down,201,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:914,Security,access,access,914,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:185,Usability,simpl,simple,185,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:952,Usability,simpl,simpler,952,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Security,access,accessed,19,"// Whether this is accessed as T.member, T->member, or T::member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:36,Modifiability,variab,variable,36,// What's known about the type of a variable or return type of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:53,Modifiability,variab,variable,53,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:72,Security,expose,expose,72,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:177,Usability,simpl,simply,177,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:73,Security,access,accessible,73,"// BaseType is the type parameter T to infer members from.; // T must be accessible within S, as we use it to find the template entity; // that T is attached to in order to gather the relevant constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:52,Integrability,depend,dependent,52,"// Infer members of T, given that the expression E (dependent on T) is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:270,Usability,simpl,simplicity,270,"// If the concept is; // template <class A, class B> concept CD = f<A, B>();; // And the concept specialization is; // CD<int, T>; // Then we're substituting T for B, so we want to make f<A, B>() true; // by adding members to B - i.e. believe(f<A, B>(), B);; //; // For simplicity:; // - we don't attempt to substitute int for A; // - when T is used in other ways (like CD<T*>) we ignore it",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:69,Availability,error,error,69,// Can't tell us anything about T.; // Now Req cannot a substitution-error: those aren't dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:89,Integrability,depend,dependent,89,// Can't tell us anything about T.; // Now Req cannot a substitution-error: those aren't dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:50,Modifiability,variab,variable,50,"// In T.foo or T->foo, `foo` is a member function/variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Modifiability,variab,variable,48,"// In T::foo, `foo` is a static member function/variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:111,Modifiability,variab,variable,111,"// If this is the callee of an immediately-enclosing CallExpr, then; // treat it as a method, otherwise it's a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:77,Modifiability,variab,variables,77,// Gets all the type constraint expressions that might apply to the type; // variables associated with DC (as returned by getTemplatedEntity()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:107,Integrability,Depend,DependentTy,107,"// Returns a type for E that yields acceptable member completions.; // In particular, when E->getType() is DependentTy, try to guess a likely type.; // We accept some lossiness (like dropping parameters).; // We only try to handle common expressions on the LHS of MemberExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,Depend,DependentTy,19,"// We only resolve DependentTy, or undeduced autos (including auto* etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:5,Integrability,depend,dependent,5,"// A dependent member: approximate-resolve the base, then lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:28,Modifiability,variab,variable,28,// A reference to an `auto` variable: approximate-resolve its initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Performance,perform,performing,49,"// Objective-C property reference. Bail if we're performing fix-it code; // completion since Objective-C properties are normally backed by ivars,; // most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:37,Integrability,interface,interface,37,// Add property results based on our interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Integrability,protocol,protocols,27,// Add properties from the protocols in a qualified interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:52,Integrability,interface,interface,52,// Add properties from the protocols in a qualified interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Modifiability,variab,variable,24,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Performance,perform,performing,55,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:33,Security,access,access,33,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:378,Integrability,depend,dependent,378,"// We look into the AST of the case statement to determine which; // enumerator was named. Alternatively, we could compute the value of; // the integral constant expression, then compare it against the; // values of each enumerator. However, value-based approach would not; // work as well with C++ templates where enumerators declared within a; // template are type- and value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,Availability,recover,recover,173,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,Safety,recover,recover,173,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:28,Integrability,wrap,wrapping,28,// Unwrap types that may be wrapping the function type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:75,Integrability,depend,dependent,75,// FIXME: Provide support for variadic template functions.; // Ignore type-dependent call expressions entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Integrability,depend,dependent,18,// In presence of dependent args we surface all possible signatures using the; // non-dependent args in the prefix. Afterwards we do a post filtering to make; // sure provided candidates satisfy parameter count restrictions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:86,Integrability,depend,dependent,86,// In presence of dependent args we surface all possible signatures using the; // non-dependent args in the prefix. Afterwards we do a post filtering to make; // sure provided candidates satisfy parameter count restrictions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:37,Modifiability,variab,variable,37,"// Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Safety,avoid,avoid,16,"// Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:39,Security,access,accessible,39,"// As SS is invalid, we try to collect accessible contexts from the current; // scope with a dummy lookup so that the completion consumer can try to; // guess what the specified scope is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:2,Performance,Load,LoadExternal,2,/*LoadExternal=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:54,Integrability,depend,dependent,54,// Always pretend to enter a context to ensure that a dependent type; // resolves to a dependent record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:87,Integrability,depend,dependent,87,// Always pretend to enter a context to ensure that a dependent type; // resolves to a dependent record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:30,Integrability,depend,dependent,30,// Try to instantiate any non-dependent declaration contexts before; // we look in them. Bail out if we fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:127,Integrability,depend,dependent,127,"// The ""template"" keyword can follow ""::"" in the grammar, but only; // put it into the grammar if the nested-name-specifier is dependent.; // FIXME: results is always empty, this appears to be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:146,Modifiability,extend,extended,146,"// We only want to see those namespaces that have already been defined; // within this scope, because its likely that the user is creating an; // extended namespace declaration. Keep track of the most recent; // definition of each namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:38,Modifiability,extend,extended,38,// Add the most recent definition (or extended definition) of each; // namespace to the list of results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:29,Modifiability,variab,variables,29,// Look for other capturable variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:92,Integrability,depend,depending,92,"/// Macro that optionally prepends an ""@"" to the string literal passed in via; /// Keyword, depending on whether NeedAt is true or false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,"// Since we have an interface or protocol, we can end it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:33,Integrability,protocol,protocol,33,"// Since we have an interface or protocol, we can end it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,interface,interface,4,"// @interface name; // FIXME: Could introduce the whole pattern, including superclasses and; // such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,protocol,protocol,4,// @protocol name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,protocol,protocol,4,// @protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:15,Integrability,protocol,protocol-name,15,// @protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,synchroniz,synchronized,4,// @synchronized ( expression ) { statements },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Safety,avoid,avoid,41,"/// A set of selectors, which is used to avoid introducing multiple; /// completions with the same selector into the result set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,Integrability,protocol,protocol,143,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:318,Integrability,protocol,protocols,318,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:530,Integrability,rout,routine,530,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:626,Performance,perform,performing,626,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Integrability,message,messaged,49,// The instance methods on the root class can be messaged via the; // metaclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:13,Integrability,protocol,protocols,13,// Visit the protocols of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Integrability,protocol,protocols,26,// Visit the protocols of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Integrability,protocol,protocols,18,// Add methods in protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,protocol,protocol,20,// Add a categories protocol methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Safety,Avoid,Avoid,34,// Add methods in superclass.; // Avoid passing in IsRootClass since root classes won't have super classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,interface,interface,19,// Try to find the interface where getters might live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,interface,interface,19,// Try to find the interface where setters might live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:168,Integrability,rout,routine,168,"/// When we have an expression with type ""id"", we may assume; /// that it has some more-specific class type based on knowledge of; /// common uses of Objective-C. This routine returns that class type,; /// or NULL if no better result could be determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:46,Integrability,message,message,46,// Determine the class that we're sending the message to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Integrability,message,message,34,"// Add a special completion for a message send to ""super"", which fills in the; // most likely case of forwarding all of our arguments to the superclass; // function.; ///; /// \param S The semantic analysis object.; ///; /// \param NeedSuperKeyword Whether we need to prefix this completion with; /// the ""super"" keyword. Otherwise, we just need to provide the arguments.; ///; /// \param SelIdents The identifiers in the selector that have already been; /// provided as arguments for a send to ""super"".; ///; /// \param Results The set of results to augment.; ///; /// \returns the Objective-C method declaration that would be invoked by; /// this ""super"" completion. If NULL, no completion was added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,// Figure out which interface we're in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,Integrability,message,message,58,"// We are inside an instance method, which means that the message; // send [super ...] is actually calling an instance method on the; // current object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:40,Modifiability,variab,variable,40,"// ""super"" may be the name of a type or variable. Figure out which; // it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,"// ""super"" names an interface. Use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:65,Integrability,message,message,65,"/// Given a set of code-completion results for the argument of a message; /// send, determine the preferred type (if any) for that argument expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Integrability,interface,interface,34,"// If the given name refers to an interface type, retrieve the; // corresponding declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:65,Integrability,protocol,protocols,65,"// Add all of the factory methods in this Objective-C class, its protocols,; // superclasses, categories, implementation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:105,Performance,load,load,105,"// We're messaging ""id"" as a type; provide all class/factory methods.; // If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:104,Performance,perform,performing,104,"// If we're actually at the argument expression (rather than prior to the; // selector), we're actually performing code completion for an expression.; // Determine whether we have a single, best method. If so, we can; // code-complete the expression using the corresponding parameter type as; // our preferred type, improving completion results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Integrability,message,message,49,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:129,Integrability,message,message,129,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to a qualified ID (""id<foo>"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,// Handle messages to a pointer to interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:35,Integrability,interface,interface,35,// Handle messages to a pointer to interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to ""id"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:138,Performance,load,load,138,"// We're messaging ""id"", so provide all instance methods we know; // about as code-completion results.; // If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:104,Performance,perform,performing,104,"// If we're actually at the argument expression (rather than prior to the; // selector), we're actually performing code completion for an expression.; // Determine whether we have a single, best method. If so, we can; // code-complete the expression using the corresponding parameter type as; // our preferred type, improving completion results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Performance,load,load,34,"// If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,protocol,protocol,19,/// Add all of the protocol declarations that we find in the given; /// (translation unit) context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,Integrability,protocol,protocols,14,// Record any protocols we find.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Integrability,protocol,protocols,44,// Tell the result set to ignore all of the protocols we have; // already seen.; // FIXME: This doesn't work when caching code-completion results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,protocol,protocols,11,// Add all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,protocol,protocols,11,// Add all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Integrability,interface,interface,31,/// Add all of the Objective-C interface declarations that we find in; /// the given (translation unit) context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,Integrability,interface,interfaces,14,// Record any interfaces we find.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:80,Integrability,interface,interface,80,// Ignore any categories we find that have already been implemented by this; // interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Integrability,interface,interface,26,"// Find the corresponding interface. If we couldn't find the interface, the; // program itself is ill-formed. However, we'll try to be helpful still by; // providing the list of all of the categories we know about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:61,Integrability,interface,interface,61,"// Find the corresponding interface. If we couldn't find the interface, the; // program itself is ill-formed. However, we'll try to be helpful still by; // providing the list of all of the categories we know about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:53,Integrability,interface,interface,53,"// Add all of the categories that have corresponding interface; // declarations in this class and any of its superclasses, except for; // already-implemented categories in the class itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,// Figure out which interface we're looking into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Modifiability,variab,variables,27,// Add all of the instance variables in this class and its superclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce the priority of this result by one, to give it a slight; // advantage over other results whose names don't match so closely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:91,Integrability,protocol,protocols,91,"/// Find all of the methods that reside in the given container; /// (and its superclasses, protocols, etc.) that meet the given; /// criteria. Insert those methods into the map of known methods,; /// indexed by selector so they can be easily found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Recurse into protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Integrability,interface,interface,55,"// If this category is the original class, jump to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Recurse into protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Modifiability,inherit,inherits,44,/// Determine whether the given class is or inherits from a class by; /// the given name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Security,access,accessor,18,// Add the normal accessor -(type)key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:121,Security,access,accessor,121,"// If we have an integral or boolean property (or the user has provided; // an integral or boolean return type), add the accessor -(type)isKey.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:25,Security,access,accessors,25,// Indexed and unordered accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,interface,interface,11,"// If this interface type is not provably derived from a known; // collection, penalize the corresponding completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Security,access,accessors,19,// Mutable indexed accessors; // - (void)insertObject:(type *)object inKeyAtIndex:(NSUInteger)index,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:21,Security,access,accessors,21,// Mutable unordered accessors; // - (void)addKeyObject:(type *)object,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Security,access,accessor,48,// Add Key-Value-Coding and Key-Value-Observing accessor methods for all of; // the properties in this class and its categories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Performance,load,load,34,"// If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Availability,error,error,4,// #error <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,message,message,11,// #error <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:13,Integrability,message,message,13,// #warning <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:233,Testability,assert,assert,233,"// Note: #ident and #sccs are such crazy anachronisms that we don't provide; // completions for them. And __include_macros is a Clang-internal extension; // that we don't want to encourage anyone to use.; // FIXME: we don't support #assert or #unassert, so don't suggest them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:17,Safety,detect,detect,17,// FIXME: Can we detect when the user just wrote an include guard above?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:108,Usability,simpl,simplicity,108,"// RelDir should use /, but unescaped \ is possible on windows!; // Our completions will normalize to / for simplicity, this case is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Avoid,Avoid,3,// Avoid dangling StringRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:496,Availability,error,error,496,"// We have the following case:; // template<typename> requires func(0) struct S { };; // The user probably isn't aware of the parentheses required around; // the function call, and we're only going to parse 'func' as the; // primary-expression, and complain that it is of non-bool type.; //; // However, if we're in a lambda, this might also be:; // []<typename> requires var () {};; // Which also looks like a function call due to the lambda parentheses,; // but unlike the first case, isn't an error, so this check is skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:71,Availability,Recover,RecoveryExpr,71,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:234,Availability,failure,failure,234,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:71,Safety,Recover,RecoveryExpr,71,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,Availability,recover,recovery,222,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,Safety,recover,recovery,222,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:18,Availability,error,error,18,// We do not want error diagnostics escaping here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:16,Availability,error,error,16,// A non-SFINAE error has occurred as a result of this; // substitution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:517,Modifiability,extend,extend,517,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:319,Performance,perform,performed,319,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:406,Performance,Perform,Perform,406,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:37,Integrability,depend,dependent,37,// No need to check satisfaction for dependent constraint expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:55,Safety,predict,predictible,55,"// A list of the template argument list flattened in a predictible manner for; // the purposes of caching. The ConstraintSatisfaction type is in AST so it; // has no access to the MultiLevelTemplateArgumentList, so this has to happen; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:166,Security,access,access,166,"// A list of the template argument list flattened in a predictible manner for; // the purposes of caching. The ConstraintSatisfaction type is in AST so it; // has no access to the MultiLevelTemplateArgumentList, so this has to happen; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Availability,Recover,RecoveryExpr,150,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:234,Performance,cache,cached,234,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:473,Performance,cache,cached,473,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Safety,Recover,RecoveryExpr,150,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:15,Usability,simpl,simply,15,// Else we can simply add this satisfaction to the list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:46,Integrability,depend,dependent,46,"// Don't check constraints if the function is dependent. Also don't check if; // this is a function template specialization, as the call to; // CheckinstantiatedFunctionTemplateConstraints after this will check it; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:112,Integrability,Depend,DependsOnEnclosingTemplate,112,"// The logic for non-templates is handled in ASTContext::isSameEntity, so we; // don't have to bother checking 'DependsOnEnclosingTemplate' for a; // non-function-template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:7,Testability,log,logic,7,"// The logic for non-templates is handled in ASTContext::isSameEntity, so we; // don't have to bother checking 'DependsOnEnclosingTemplate' for a; // non-function-template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:5,Usability,simpl,simple,5,// A simple case - expr type is the type being constrained and the concept; // was not provided arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:156,Availability,down,down,156,"// These two cases will in practice only be reached when using fold; // expressions with || and &&, since otherwise the || and && will have been; // broken down into atomic constraints during satisfaction checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:36,Integrability,depend,dependent,36,// FIXME: RequiresExpr should store dependent diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:100,Safety,avoid,avoid,100,"// In case the ConstrainedDecl comes from modules, it is necessary to use; // the canonical decl to avoid different atomic constraints with the 'same'; // declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:34,Integrability,depend,dependent,34,// We reach this ctor with either dependent types (in which; // IsSatisfied doesn't matter) or with non-dependent type in; // which the existence of the type indicates satisfaction.; /*IsSatisfied=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:104,Integrability,depend,dependent,104,// We reach this ctor with either dependent types (in which; // IsSatisfied doesn't matter) or with non-dependent type in; // which the existence of the type indicates satisfaction.; /*IsSatisfied=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp:36,Integrability,interface,interface,36,"//===-- SemaConsumer.cpp - Abstract interface for AST semantics -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:73,Usability,resume,resume,73,"// See if return type is coroutine-handle and if so, invoke builtin coro-resume; // on its address. This is to enable the support for coroutine-handle; // returning await_suspend that results in a guaranteed tail call to the target; // coroutine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:394,Deployability,update,update,394,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:550,Integrability,wrap,wrap,550,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:182,Modifiability,variab,variable,182,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:18,Performance,optimiz,optimizations,18,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:387,Security,access,access,387,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:565,Testability,log,logic,565,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:311,Integrability,contract,contract,311,"// Clean up temporary objects so that they don't live across suspension points; // unnecessarily. We choose to clean up before the call to; // __builtin_coro_resume so that the cleanup code are not inserted in-between; // the resume call and return instruction, which would interfere with the; // musttail call contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:226,Usability,resume,resume,226,"// Clean up temporary objects so that they don't live across suspension points; // unnecessarily. We choose to clean up before the call to; // __builtin_coro_resume so that the cleanup code are not inserted in-between; // the resume call and return instruction, which would interfere with the; // musttail call contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,Performance,perform,performed,27,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1131,Performance,perform,perform,1131,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1143,Safety,safe,safety,1143,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1192,Safety,safe,safe,1192,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:300,Energy Efficiency,power,powerful,300,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:108,Performance,perform,perform,108,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:215,Performance,perform,perform,215,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,Availability,toler,tolerant,368,"// This is problematic if the user calls the await_suspend standalone. But on; // the on hand, it is not incorrect semantically since inlining is not part; // of the standard. On the other hand, it is relatively rare to call; // the await_suspend function standalone.; //; // And given we've already had the long-term plan, the current workaround; // looks relatively tolerant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:487,Integrability,wrap,wrapping,487,"/// Build calls to await_ready, await_suspend, and await_resume for a co_await; /// expression.; /// The generated AST tries to clean up temporary objects as early as; /// possible so that they don't live across suspension points if possible.; /// Having temporary objects living across suspension points unnecessarily can; /// lead to large frame size, and also lead to memory corruptions if the; /// coroutine frame is destroyed after coming back from suspension. This is done; /// by wrapping both the await_ready call and the await_suspend call with; /// ExprWithCleanups. In the end of this function, we also need to explicitly; /// set cleanup state so that the CoawaitExpr is also wrapped with an; /// ExprWithCleanups to clean up the awaiter associated with the co_await; /// expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:688,Integrability,wrap,wrapped,688,"/// Build calls to await_ready, await_suspend, and await_resume for a co_await; /// expression.; /// The generated AST tries to clean up temporary objects as early as; /// possible so that they don't live across suspension points if possible.; /// Having temporary objects living across suspension points unnecessarily can; /// lead to large frame size, and also lead to memory corruptions if the; /// coroutine frame is destroyed after coming back from suspension. This is done; /// by wrapping both the await_ready call and the await_suspend call with; /// ExprWithCleanups. In the end of this function, we also need to explicitly; /// set cleanup state so that the CoawaitExpr is also wrapped with an; /// ExprWithCleanups to clean up the awaiter associated with the co_await; /// expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:22,Integrability,wrap,wrap,22,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:116,Integrability,contract,contract,116,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:232,Integrability,wrap,wrapped,232,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:276,Usability,resume,resume,276,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:95,Integrability,wrap,wrapped,95,"// Create an initialization sequence for the promise type using the; // constructor arguments, wrapped in a parenthesized list expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:117,Performance,perform,performed,117,"// [dcl.fct.def.coroutine]5.7; // promise-constructor-arguments is determined as follows: overload; // resolution is performed on a promise constructor call created by; // assembling an argument list q_1 ... q_n . If a viable constructor is; // found ([over.match.viable]), then promise-constructor-arguments is ( q_1; // , ..., q_n ), otherwise promise-constructor-arguments is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:402,Testability,log,logically,402,"// co_await promise.final_suspend() could end up calling; // __builtin_coro_resume for symmetric transfer if await_suspend(); // returns a handle. In that case, even __builtin_coro_resume is not; // declared as noexcept and may throw, it does not throw _into_ the; // coroutine that just suspended, but rather throws back out from; // whoever called coroutine_handle::resume(), hence we claim that; // logically it does not throw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,Usability,resume,resume,368,"// co_await promise.final_suspend() could end up calling; // __builtin_coro_resume for symmetric transfer if await_suspend(); // returns a handle. In that case, even __builtin_coro_resume is not; // declared as noexcept and may throw, it does not throw _into_ the; // coroutine that just suspended, but rather throws back out from; // whoever called coroutine_handle::resume(), hence we claim that; // logically it does not throw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:166,Availability,error,error,166,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:182,Availability,error,error,182,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:188,Integrability,message,message,188,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:287,Integrability,message,messages,287,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:167,Safety,avoid,avoid,167,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:85,Integrability,Depend,DependentCoawaitExpr,85,"// Attempts to resolve and build a CoawaitExpr from ""raw"" inputs, bailing out to; // DependentCoawaitExpr if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:171,Performance,perform,performed,171,"// [dcl.fct.def.coroutine]p12; // The deallocation function's name is looked up by searching for it in the; // scope of the promise type. If nothing is found, a search is performed in; // the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:39,Availability,reliab,reliably,39,"// The always_inline attribute doesn't reliably apply to a coroutine,; // because the coroutine will be split into pieces and some pieces; // might be called indirectly, as in a virtual call. Even the ramp; // function cannot be inlined at -O0, due to pipeline ordering; // problems (see https://llvm.org/PR53413). Tell the user about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:252,Deployability,pipeline,pipeline,252,"// The always_inline attribute doesn't reliably apply to a coroutine,; // because the coroutine will be split into pieces and some pieces; // might be called indirectly, as in a virtual call. Even the ramp; // function cannot be inlined at -O0, due to pipeline ordering; // problems (see https://llvm.org/PR53413). Tell the user about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:32,Integrability,wrap,wrapper,32,// Build body for the coroutine wrapper statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:105,Integrability,wrap,wrap,105,// The body of the coroutine may be a try statement if it is in; // 'function-try-block' syntax. Here we wrap it into a compound; // statement for consistency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:162,Energy Efficiency,allocate,allocated,162,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:421,Energy Efficiency,allocate,allocate,421,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:782,Performance,perform,performed,782,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:261,Performance,perform,performed,261,"// [dcl.fct.def.coroutine]p9; // The allocation function's name is looked up by searching for it in the; // scope of the promise type.; // - If any declarations are found, ...; // - If no declarations are found in the scope of the promise type, a search; // is performed in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:118,Performance,perform,performed,118,"// [dcl.fct.def.coroutine]p9; // If no viable function is found ([over.match.viable]), overload; // resolution; // is performed again on a function call created by passing just the amount; // of space required as an argument of type std::size_t.; //; // Proposed Change of [dcl.fct.def.coroutine]p9 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the requested alignment as; // an argument of type std:align_val_t as the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:349,Performance,perform,performed,349,"// [dcl.fct.def.coroutine]p9; // If no viable function is found ([over.match.viable]), overload; // resolution; // is performed again on a function call created by passing just the amount; // of space required as an argument of type std::size_t.; //; // Proposed Change of [dcl.fct.def.coroutine]p9 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the requested alignment as; // an argument of type std:align_val_t as the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:848,Modifiability,variab,variable,848,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:99,Performance,perform,performed,99,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:346,Performance,perform,performed,346,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:106,Deployability,update,update,106,"// If we found a non-aligned allocation function in the promise_type,; // it indicates the user forgot to update the allocation function. Let's emit; // a warning here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,Availability,error,error,27,"// FIXME: We should add an error here. According to:; // [dcl.fct.def.coroutine]p12; // If no usual deallocation function is found, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:43,Integrability,wrap,wrapped,43,"// Since the body of the coroutine will be wrapped in try-catch, it will; // be incompatible with SEH __try if present in a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:240,Integrability,depend,depending,240,"// The call to get_­return_­object is sequenced before the call to; // initial_­suspend and is invoked at most once, but there are caveats; // regarding on whether the prvalue result object may be initialized; // directly/eager or delayed, depending on the types involved.; //; // More info at https://github.com/cplusplus/papers/issues/1414",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:18,Availability,error,error,18,// Trigger a nice error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:24,Integrability,message,message,24,// Trigger a nice error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:12,Modifiability,variab,variable,12,/// Build a variable declaration for move parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:212,Modifiability,variab,variable,212,"// [dcl.fct.def.coroutine]p13; // When a coroutine is invoked, after initializing its parameters; // ([expr.call]), a copy is created for each coroutine parameter. For a; // parameter of type cv T, the copy is a variable of type cv T with; // automatic storage duration that is direct-initialized from an xvalue of; // type T referring to the parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:68,Modifiability,variab,variable,68,/// IdentifyTarget - Determine the CUDA compilation target for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:28,Modifiability,variab,variabless,28,// Only constexpr and const variabless with implicit constant attribute; // are emitted on both sides. Such variables are promoted to device side; // only if they have static constant intializers on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:108,Modifiability,variab,variables,108,// Only constexpr and const variabless with implicit constant attribute; // are emitted on both sides. Such variables are promoted to device side; // only if they have static constant intializers on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:25,Modifiability,variab,variable,25,// Function-scope static variable without explicit device or constant; // attribute are emitted; // - on both sides in host device functions; // - on device side in device or global functions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:27,Integrability,depend,depends,27,// (d) HostDevice behavior depends on compilation mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:41,Modifiability,variab,variable,41,// Check initializer for device/constant variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:32,Modifiability,variab,variable,32,// Check initializer for shared variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:19,Modifiability,variab,variable,19,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:82,Modifiability,variab,variable,82,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:132,Modifiability,variab,variable,132,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:198,Modifiability,variab,variable,198,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:287,Modifiability,variab,variables,287,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:378,Modifiability,variab,variables,378,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:556,Modifiability,variab,variables,556,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:16,Integrability,depend,dependent,16,// Do not check dependent variables since the ctor/dtor/initializer are not; // determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:26,Modifiability,variab,variables,26,// Do not check dependent variables since the ctor/dtor/initializer are not; // determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:30,Modifiability,variab,variable,30,// This is a host-side global variable. Check that the initializer is; // callable from the host side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:335,Availability,error,error,335,"// With -fcuda-host-device-constexpr, an unattributed constexpr function is; // treated as implicitly __host__ __device__, unless:; // * it is a variadic function (device-side variadic functions are not; // allowed), or; // * a __device__ function with this signature was already declared, in which; // case in which case we output an error, unless the __device__ decl is in a; // system header, in which case we leave the constexpr function unattributed.; //; // In addition, all function decls are treated as __host__ __device__ when; // ForceCUDAHostDeviceDepth > 0 (corresponding to code within a; // #pragma clang force_cuda_host_device_begin/end; // pair).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:113,Availability,error,error,113,"// We found a __device__ function with the same name and signature as NewD; // (ignoring CUDA attrs). This is an error unless that function is defined; // in a system header, in which case we simply return without making NewD; // host+device.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:192,Usability,simpl,simply,192,"// We found a __device__ function with the same name and signature as NewD; // (ignoring CUDA attrs). This is an error unless that function is defined; // in a system header, in which case we simply return without making NewD; // host+device.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:134,Deployability,pipeline,pipeline,134,// TODO: `__constant__` memory may be a limited resource for certain targets.; // A safeguard may be needed at the end of compilation pipeline if; // `__constant__` memory usage goes beyond limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:84,Safety,safe,safeguard,84,// TODO: `__constant__` memory may be a limited resource for certain targets.; // A safeguard may be needed at the end of compilation pipeline if; // `__constant__` memory usage goes beyond limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:18,Integrability,depend,dependent,18,// Do not promote dependent variables since the cotr/dtor/initializer are; // not determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:28,Modifiability,variab,variables,28,// Do not promote dependent variables since the cotr/dtor/initializer are; // not determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:128,Availability,error,errors,128,"// An HD function counts as host code if we're compiling for host, and; // device code if we're compiling for device. Defer any errors in device; // mode until the function is known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:128,Availability,error,errors,128,"// An HD function counts as host code if we're compiling for host, and; // device code if we're compiling for device. Defer any errors in device; // mode until the function is known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:113,Availability,error,error,113,"// If we know the caller will be emitted, we know this wrong-side call; // will be emitted, so it's an immediate error. Otherwise, defer the; // error until we know the caller is emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:145,Availability,error,error,145,"// If we know the caller will be emitted, we know this wrong-side call; // will be emitted, so it's an immediate error. Otherwise, defer the; // error until we know the caller is emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:23,Availability,error,error,23,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:187,Availability,error,error,187,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:274,Availability,error,error,274,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:3,Safety,Avoid,Avoid,3,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:66,Security,hash,hashtable,66,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:109,Modifiability,variab,variable,109,"// Check the wrong-sided reference capture of lambda for CUDA/HIP.; // A lambda function may capture a stack variable by reference when it is; // defined and uses the capture by reference when the lambda is called. When; // the capture and use happen on different sides, the capture is invalid and; // should be diagnosed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:58,Modifiability,variab,variables,58,"// File-scope lambda can only do init captures for global variables, which; // results in passing by value for these global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:124,Modifiability,variab,variables,124,"// File-scope lambda can only do init captures for global variables, which; // results in passing by value for these global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:104,Security,access,accessible,104,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:184,Security,access,access,184,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:232,Security,access,accessible,232,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:22,Deployability,configurat,configuration,22,// Legacy CUDA kernel configuration call,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:22,Modifiability,config,configuration,22,// Legacy CUDA kernel configuration call,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:302,Integrability,depend,dependent,302,"/// Compute the DeclContext that is associated with the given type.; ///; /// \param T the type for which we are attempting to find a DeclContext.; ///; /// \returns the declaration context represented by the type T,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:591,Integrability,depend,dependent,591,"/// Compute the DeclContext that is associated with the given; /// scope specifier.; ///; /// \param SS the C++ scope specifier as it appears in the source; ///; /// \param EnteringContext when true, we will be entering the context of; /// this scope specifier, so we can retrieve the declaration context of a; /// class template or class template partial specialization even if it is; /// not the current instantiation.; ///; /// \returns the declaration context represented by the scope specifier @p SS,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:305,Testability,test,tests,305,// FIXME: The fallback on the search of partial; // specialization using ContextType should be eventually removed since; // it doesn't handle the case of constrained template parameters; // correctly. Currently removing this fallback would change the; // diagnostic output for invalid code in a number of tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:82,Availability,recover,recover,82,"// A declaration of the partial specialization must be visible.; // We can always recover here, because this only happens when we're; // entering the context, and that can't happen in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:82,Safety,recover,recover,82,"// A declaration of the partial specialization must be visible.; // We can always recover here, because this only happens when we're; // entering the context, and that can't happen in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,Integrability,inject,injected,67,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,Security,inject,injected,67,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:206,Integrability,depend,dependent,206,"/// If the given nested name specifier refers to the current; /// instantiation, return the declaration that corresponds to that; /// current instantiation (C++0x [temp.dep.type]p1).; ///; /// \param NNS a dependent nested name specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:97,Integrability,rout,routine,97,"/// Require that the context specified by SS be complete.; ///; /// If SS refers to a type, this routine checks whether the type is; /// complete enough (or can be made complete enough) for name lookup; /// into the DeclContext. A type that is not yet completed can be; /// considered ""complete enough"" if it is a class/struct/union/enum; /// that is currently being defined. Or, if we have a type that names; /// a class template specialization that is not a complete type, we; /// will attempt to instantiate that class template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent type, then we consider it complete.; // FIXME: This is wrong; we should require a (visible) definition to; // exist in this case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:55,Performance,load,loaded,55,"// The actual information about the decl may have been loaded via an; // external source that created a new AST node/decl for the definition; // rather than reusing the one we had (DC) like the ASTReader does.; // To avoid the caller to continue using the still incomplete decl, let's; // set it to the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:217,Safety,avoid,avoid,217,"// The actual information about the decl may have been loaded via an; // external source that created a new AST node/decl for the definition; // rather than reusing the one we had (DC) like the ASTReader does.; // To avoid the caller to continue using the still incomplete decl, let's; // set it to the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:34,Availability,error,error,34,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:46,Availability,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:46,Safety,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:2,Availability,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:2,Safety,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:288,Modifiability,variab,variable,288,"/// Determines whether the given declaration is an valid acceptable; /// result for name lookup of a nested-name-specifier.; /// \param SD Declaration checked for nested-name-specifier.; /// \param IsExtension If not null and the declaration is accepted as an; /// extension, the pointed variable is assigned true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:90,Performance,perform,perform,90,"/// If the given nested-name-specifier begins with a bare identifier; /// (e.g., Base::), perform name lookup for that identifier as a; /// nested-name-specifier within the given scope, and return the result of that; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:616,Availability,Error,ErrorRecoveryLookup,616,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:686,Availability,error,error,686,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:692,Availability,recover,recovery,692,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:718,Availability,recover,recovery,718,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1348,Availability,Error,ErrorRecoveryLookup,1348,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
