id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:202,Integrability,Integrat,Integration,202,". Histogram package. The libHist library now depends on libMathCore which must be linked whenever one needs to use the histogram library. TF1. The code used for implementing numerical methods like TF1::Integration or TF1::Derivation or TF1::GetX has now been now moved in MathCore and used to implement corresponding classes like GaussIntegrator or BrentRootFinder. The implementation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a ",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:764,Integrability,rout,routine,764,". Histogram package. The libHist library now depends on libMathCore which must be linked whenever one needs to use the histogram library. TF1. The code used for implementing numerical methods like TF1::Integration or TF1::Derivation or TF1::GetX has now been now moved in MathCore and used to implement corresponding classes like GaussIntegrator or BrentRootFinder. The implementation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a ",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:985,Integrability,rout,routine,985,". Histogram package. The libHist library now depends on libMathCore which must be linked whenever one needs to use the histogram library. TF1. The code used for implementing numerical methods like TF1::Integration or TF1::Derivation or TF1::GetX has now been now moved in MathCore and used to implement corresponding classes like GaussIntegrator or BrentRootFinder. The implementation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a ",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:1821,Modifiability,variab,variable,1821,"ing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a couple of bugs in TH3::Project3DProfile. TProfile and TProfile2D. Add a new option ""W"" in TProfile::ProjectionX and TProfile::ProjectionXY to be able to return the equivalent weighted filled histogram. Its bin content is equal to the profile bin content multiplied by the bin entries. Implement in the TProfile a new option, ""G"" for the bin error. This option can be used, bin by bin, for the combination of measurements y with known gaussian error dy. In this case the profile must be filled; with a weight = 1./dy**2 and the resulting error from the combination (1./sqrt(Sum(1./dy**2) ) ) will be calculated by the profile. . THnSparse. Implement THnSparse::Projection and THnSparse::Merge. New Tutorials. tutorials/hist/sparsehist.C: an example how to use the new multi dim histogram class THnSparse.; tutorials/hist/drawspar",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:1414,Performance,perform,performed,1414,"tation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a couple of bugs in TH3::Project3DProfile. TProfile and TProfile2D. Add a new option ""W"" in TProfile::ProjectionX and TProfile::ProjectionXY to be able to return the equivalent weighted filled histogram. Its bin content is equal to the profile bin content multiplied by the bin entries. Implement in the TProfile a new option, ""G"" for the bin error. This option can be used, bin b",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:1406,Testability,test,test,1406,"tation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a couple of bugs in TH3::Project3DProfile. TProfile and TProfile2D. Add a new option ""W"" in TProfile::ProjectionX and TProfile::ProjectionXY to be able to return the equivalent weighted filled histogram. Its bin content is equal to the profile bin content multiplied by the bin entries. Implement in the TProfile a new option, ""G"" for the bin error. This option can be used, bin b",MatchSource.DOCS,hist/doc/v520/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:3782,Availability,error,error,3782,"ructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH3::Project reported by Marco Van Leeuwen in setting the bin error in the projected histogram when a range was set in the projected axis.; ; Add possibility to be used in the FitPanel (add a TH3::FitPanel() method). TProfile. Fix a bug in TProfile::Rebin. The underflow and overflow were not properly taken into account; ; TProfile3D. Fix a bug in the copy constructor and assignment operator; ; THnSparse; fix a bug in SetBinError; fix in THnSParse::Rebin; fix error calculation in Multiply. TGraph. Change the API of TGraph::GetPoint from; ; void TGraph::GetPoint(Int_t i, Double_t &x, Double_t &y) const; ; to; ; Int_t TGraph::GetPoint(Int_t i, Double_t &x, Double_t &y) const; ; The function returns -1 in case of an invalid request or the; point number otherwise.; ; Re-implement TGraph::Fit using the functions defined in HFitImpl.cxx. TGraph2D. Re-implement TGraph2D::Fit using the functions defined in HFitImpl.cxx.; Add possibility to be used in the FitPanel (add a TGraph2D::FitPanel() method). TMultiGraph. Re-implement TMultiGraph::Fit using the f",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:4183,Availability,error,error,4183,"tPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH3::Project reported by Marco Van Leeuwen in setting the bin error in the projected histogram when a range was set in the projected axis.; ; Add possibility to be used in the FitPanel (add a TH3::FitPanel() method). TProfile. Fix a bug in TProfile::Rebin. The underflow and overflow were not properly taken into account; ; TProfile3D. Fix a bug in the copy constructor and assignment operator; ; THnSparse; fix a bug in SetBinError; fix in THnSParse::Rebin; fix error calculation in Multiply. TGraph. Change the API of TGraph::GetPoint from; ; void TGraph::GetPoint(Int_t i, Double_t &x, Double_t &y) const; ; to; ; Int_t TGraph::GetPoint(Int_t i, Double_t &x, Double_t &y) const; ; The function returns -1 in case of an invalid request or the; point number otherwise.; ; Re-implement TGraph::Fit using the functions defined in HFitImpl.cxx. TGraph2D. Re-implement TGraph2D::Fit using the functions defined in HFitImpl.cxx.; Add possibility to be used in the FitPanel (add a TGraph2D::FitPanel() method). TMultiGraph. Re-implement TMultiGraph::Fit using the functions defined in; HFitImpl.cxx.; Add possibility to be used in the FitPanel (add a; TMultiGraph::FitPanel() method).; Protection added in Draw(): ""Cannot draw empty TMultiGraph"". TGraphPainter. When a histogram was drawn in a larger frame than its limits (using the; option ""SAME""), the `outside' vertical lines for the first and last bins; were not d",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:7445,Availability,error,errors,7445," TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel can also be open directly from the TCanvas menu; (under Tools); Improve the function selection by having the possibility to; support user defined function, predefined functions and functi",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1454,Deployability,configurat,configuration,1454,"erface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a T",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:5737,Deployability,Update,Update,5737,"FitImpl.cxx.; Add possibility to be used in the FitPanel (add a; TMultiGraph::FitPanel() method).; Protection added in Draw(): ""Cannot draw empty TMultiGraph"". TGraphPainter. When a histogram was drawn in a larger frame than its limits (using the; option ""SAME""), the `outside' vertical lines for the first and last bins; were not drawn. The macro below demonstrates the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.);; h.SetBinContent(1, 1.);; h.SetBinContent(3, 1.);; h.SetBinContent(10, 1.);; h.SetFillColor(1001);; h.SetFillColor(kOrange-2);; h.SetLineColor(kBlack);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; h.Draw(""SAME"");; }. TPaletteAxis. New method Int_t TPaletteAxis::GetBinColor(Int_t i, Int_t j) to; return the color index of the bin (i,j).; ; This function should be used after an histogram has been plotted with the; option COL or COLZ like in the following example:; ; h2->Draw(""COLZ"");; gPad->Update();; TPaletteAxis *palette =; (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; Int_t ci = palette->GetBinColor(20,15);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; . TFormula. Fixed a bug in TFormula::GetExprFormula. Now the correct formula is returned for expressions based on CINT type functions. TF1. Fixed a bug in the calculation of the integral of multi-dimensional interpreted functions. The method TF1::operator() (const double *x, const double *p) calls now TF1::InitArgs in the case of CINT functions.; Fixed a bug in using the TF1::GetMinimum(), TF1::GetMaximum(), TF1::GetMinimumX, TF1::GetMaximumX, TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro wa",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1336,Integrability,wrap,wrapping,1336,"erface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a T",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2185,Integrability,interface,interface,2185,". Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (Prof",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1454,Modifiability,config,configuration,1454,"erface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a T",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2729,Modifiability,variab,variable,2729,"en the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2901,Modifiability,variab,variable,2901," addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH3::Project reported by Marco Van Leeuwen in setting the bin error in the projected histogram when a range was",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:678,Performance,perform,performing,678,". Histogram package. Modify implementation of the Fit function in the histograms and data classes to use a new common implementation, defined in the file HFitImpl.cxx. This file provides the implementation of the function used for bin fitting of the data objects of the histogram package, TH1's, TGraph, TMultiGraph, TGraph2D, and un-binned maximum likelihood fit for TTree data (used by the TTree::UnbinnedFit method). HFitInterface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member fu",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:7300,Performance,optimiz,optimized,7300,"onst double *x, const double *p) calls now TF1::InitArgs in the case of CINT functions.; Fixed a bug in using the TF1::GetMinimum(), TF1::GetMaximum(), TF1::GetMinimumX, TF1::GetMaximumX, TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:7672,Performance,tune,tuned,7672," in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel can also be open directly from the TCanvas menu; (under Tools); Improve the function selection by having the possibility to; support user defined function, predefined functions and functions; used before for fitting. ; Allow the opening of the parameter dialog in case of linear; fitter. This is needed for example for fixing some of the; parameters; Improve minimization panel by adding some extra methods, ",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:8890,Performance,perform,perform,8890," root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel can also be open directly from the TCanvas menu; (under Tools); Improve the function selection by having the possibility to; support user defined function, predefined functions and functions; used before for fitting. ; Allow the opening of the parameter dialog in case of linear; fitter. This is needed for example for fixing some of the; parameters; Improve minimization panel by adding some extra methods, like; combined for a combined migrad-simplex minimization (option; ""MINIMIZE"" in Minuit).; Improve the slider by adding a numeric entry. ; Add the Advanced Graphics dialog, that allows the user to perform; Contour and Scan operation on the last fit.; Fix various bugs in setting the fit model function and in; setting the parameters (values, limits, etc..). Here is how the fit panel is now:; ; These are the currently support methods for the new Advance Graphics dialog:;  ; ",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2858,Safety,avoid,avoid,2858," addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH3::Project reported by Marco Van Leeuwen in setting the bin error in the projected histogram when a range was",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1904,Security,access,access,1904,". Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (Prof",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:6778,Usability,simpl,simple,6778,"unctions()->FindObject(""palette"");; Int_t ci = palette->GetBinColor(20,15);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; . TFormula. Fixed a bug in TFormula::GetExprFormula. Now the correct formula is returned for expressions based on CINT type functions. TF1. Fixed a bug in the calculation of the integral of multi-dimensional interpreted functions. The method TF1::operator() (const double *x, const double *p) calls now TF1::InitArgs in the case of CINT functions.; Fixed a bug in using the TF1::GetMinimum(), TF1::GetMaximum(), TF1::GetMinimumX, TF1::GetMaximumX, TF1::GetX with default arguments. ; Fixed a bug when copying functions obtained from member functions of interpreted classes; . THStack. In THStack::Paint() replace; fHistogram->Paint(""axissame""); by; gPad->RedrawAxis(); in order to fix the bug described here:; https://savannah.cern.ch/bugs/?41423 .; The simple following macro was enough to show the problem:. {; TH1D h(""h"", ""h"", 10., 0., 1.); h.Fill(.5);; THStack s(""s"", ""s""); s.Add(&h);; TCanvas canvas(""canvas"");; frame = canvas.DrawFrame(-1., 0., 2., 2.);; frame.SetLabelSize(0.05, ""XY"");; frame.Draw(); s.Draw(""same"");; }. Make the data member fHistogram persistent in order to save the; axis attributes which may have been changed during a root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding ",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:8730,Usability,simpl,simplex,8730," root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel can also be open directly from the TCanvas menu; (under Tools); Improve the function selection by having the possibility to; support user defined function, predefined functions and functions; used before for fitting. ; Allow the opening of the parameter dialog in case of linear; fitter. This is needed for example for fixing some of the; parameters; Improve minimization panel by adding some extra methods, like; combined for a combined migrad-simplex minimization (option; ""MINIMIZE"" in Minuit).; Improve the slider by adding a numeric entry. ; Add the Advanced Graphics dialog, that allows the user to perform; Contour and Scan operation on the last fit.; Fix various bugs in setting the fit model function and in; setting the parameters (values, limits, etc..). Here is how the fit panel is now:; ; These are the currently support methods for the new Advance Graphics dialog:;  ; ",MatchSource.DOCS,hist/doc/v522/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:1372,Availability,error,error,1372,">FindObject(""palette"");; Int_t ci = palette->GetValueColor(30.);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; ; This function is used by TPaletteAxis::GetBinColor(). TAxis. Implement a new function, TAxis::GetBinCenterLog(Int_t bin), as suggested at the issue #8263.; ; TGraph. When adding an object in the list of functions of a TGraph,; there was a crash at the TGraph drawing time if the; fitting option (gStyle->SetOptFit(1)) was on. This was; reported in: https://savannah.cern.ch/bugs/?46525; The following macro reproduces the problem:; ; {; gStyle->SetOptFit(1);; TGraph *gr = new TGraph(2);; gr->SetPoint(0,1,1);; gr->SetPoint(1,2,2);; TLatex *l1 = new TLatex(gr->GetX()[0], gr->GetY()[0], ""#1"");; gr->GetListOfFunctions()->Add(l1);; gr->Draw(""APL"");; }; . Fixed the bug #45607 by creating a list of functions when using TGraph default constructor.; Fixed a bug when fitting TGraphErrors with zero error in y but non-zero error in x. In GetHistogram:; if fHistogram exists, and the log scale is on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the function integral is computed in TH1::FillRandom; Add new functions TH1::IsBinUnderflow(bin) and TH1::IsBinOverflow(bin) which use the global bin number.; Add new functions Int_t TH1::FindFirstBinAbove(Double_t threshold, Int_t axis) and Int_t TH1::FindLastBinAbove(Double_t threshold, Int_t axis) which find first (and last) bin with the content above the given t",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:1396,Availability,error,error,1396,">FindObject(""palette"");; Int_t ci = palette->GetValueColor(30.);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; ; This function is used by TPaletteAxis::GetBinColor(). TAxis. Implement a new function, TAxis::GetBinCenterLog(Int_t bin), as suggested at the issue #8263.; ; TGraph. When adding an object in the list of functions of a TGraph,; there was a crash at the TGraph drawing time if the; fitting option (gStyle->SetOptFit(1)) was on. This was; reported in: https://savannah.cern.ch/bugs/?46525; The following macro reproduces the problem:; ; {; gStyle->SetOptFit(1);; TGraph *gr = new TGraph(2);; gr->SetPoint(0,1,1);; gr->SetPoint(1,2,2);; TLatex *l1 = new TLatex(gr->GetX()[0], gr->GetY()[0], ""#1"");; gr->GetListOfFunctions()->Add(l1);; gr->Draw(""APL"");; }; . Fixed the bug #45607 by creating a list of functions when using TGraph default constructor.; Fixed a bug when fitting TGraphErrors with zero error in y but non-zero error in x. In GetHistogram:; if fHistogram exists, and the log scale is on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the function integral is computed in TH1::FillRandom; Add new functions TH1::IsBinUnderflow(bin) and TH1::IsBinOverflow(bin) which use the global bin number.; Add new functions Int_t TH1::FindFirstBinAbove(Double_t threshold, Int_t axis) and Int_t TH1::FindLastBinAbove(Double_t threshold, Int_t axis) which find first (and last) bin with the content above the given t",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:3641,Availability,error,error,3641,"y histogram with default sum2 (i.e when TH1::GetDefaultSumw2() is true).; Add a method, TH1::ResetStats() to reset the internal statistics and force then the re-calculation suing the bin center first time is needed; Fix some problem with the statistics (in particular the number of entries) after some of the histogram operations. ; TH2. Consider in the projection of TH2 the axis range set by the user. This fix the issue https://savannah.cern.ch/bugs/index.php?47946; Add a new option, option ""o"", in the projection methods: TH2::ProjectionX, TH2::ProjectionY, TH2::ProfileX and TH2::ProfileY. When an axis range is set, using option ""o"", the original axis range of the taget axes will be; kept, but only the bins inside the selected range will be filled, while bins outside the range will be empty. TH3. Add implementation of TH3::Interpolate using a tri-linear interpolation method; Fix a bug in TH3::Project3D (https://savannah.cern.ch/bugs/?46432) for the error calculation in case of weighted histogram (or when using option ""E"") and no axis range is set. In the projection to Profile's, when Sumw2 is set, have the correct projected errors now with the new TProfile data member.; Add TH3::ProjectionX and TH3::ProjectionY to complement the already existing ProjectionZ. They are all impelmented using the Project3D method.; Re-implement the TH3::Project3D method using the internal methods DoProject1D and DoProject2D depending on the option. This new implementation is faster in case sub-ranges are selected and fix this issue (https://savannah.cern.ch/bugs/index.php?45494).; A similar new implementation is done for TH3::ProjectProfile.; Add the new option ""o"", as in TH2 for the histogram and profile projections. TProfile, TProfile2D, TProfile3D. Add a new data member (TArrayD fBinSumw2) for storing the sum of weight square per bin. This is needed for correct error calculation in case of profile filled with weights different than 1. The new structure is filled only when TProfile::Su",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:3820,Availability,error,errors,3820,"nal statistics and force then the re-calculation suing the bin center first time is needed; Fix some problem with the statistics (in particular the number of entries) after some of the histogram operations. ; TH2. Consider in the projection of TH2 the axis range set by the user. This fix the issue https://savannah.cern.ch/bugs/index.php?47946; Add a new option, option ""o"", in the projection methods: TH2::ProjectionX, TH2::ProjectionY, TH2::ProfileX and TH2::ProfileY. When an axis range is set, using option ""o"", the original axis range of the taget axes will be; kept, but only the bins inside the selected range will be filled, while bins outside the range will be empty. TH3. Add implementation of TH3::Interpolate using a tri-linear interpolation method; Fix a bug in TH3::Project3D (https://savannah.cern.ch/bugs/?46432) for the error calculation in case of weighted histogram (or when using option ""E"") and no axis range is set. In the projection to Profile's, when Sumw2 is set, have the correct projected errors now with the new TProfile data member.; Add TH3::ProjectionX and TH3::ProjectionY to complement the already existing ProjectionZ. They are all impelmented using the Project3D method.; Re-implement the TH3::Project3D method using the internal methods DoProject1D and DoProject2D depending on the option. This new implementation is faster in case sub-ranges are selected and fix this issue (https://savannah.cern.ch/bugs/index.php?45494).; A similar new implementation is done for TH3::ProjectProfile.; Add the new option ""o"", as in TH2 for the histogram and profile projections. TProfile, TProfile2D, TProfile3D. Add a new data member (TArrayD fBinSumw2) for storing the sum of weight square per bin. This is needed for correct error calculation in case of profile filled with weights different than 1. The new structure is filled only when TProfile::Sumw2() is called or when TH1::SetDefaultSumw2() is set.; Add a new internal class, TProfileHelper for providing a common impl",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:4554,Availability,error,error,4554,"n TH3::Project3D (https://savannah.cern.ch/bugs/?46432) for the error calculation in case of weighted histogram (or when using option ""E"") and no axis range is set. In the projection to Profile's, when Sumw2 is set, have the correct projected errors now with the new TProfile data member.; Add TH3::ProjectionX and TH3::ProjectionY to complement the already existing ProjectionZ. They are all impelmented using the Project3D method.; Re-implement the TH3::Project3D method using the internal methods DoProject1D and DoProject2D depending on the option. This new implementation is faster in case sub-ranges are selected and fix this issue (https://savannah.cern.ch/bugs/index.php?45494).; A similar new implementation is done for TH3::ProjectProfile.; Add the new option ""o"", as in TH2 for the histogram and profile projections. TProfile, TProfile2D, TProfile3D. Add a new data member (TArrayD fBinSumw2) for storing the sum of weight square per bin. This is needed for correct error calculation in case of profile filled with weights different than 1. The new structure is filled only when TProfile::Sumw2() is called or when TH1::SetDefaultSumw2() is set.; Add a new internal class, TProfileHelper for providing a common implementations for all TProfile classes for complex methods like Add and Merge.; Fix a bug in TProfile::GetStats method.; . THnSparse. Fix a bug where the axes of a THnSparse created by THnSparse::Projection() would be filled wrongly if the axis's range was set.; Fix a bug where the TAxis::kAxisRange bit was not reset for the new TH1/2/3 axes created by THnSparse::Projection(), if the original axis had a range and ""A"" was not given.; Implement new option ""O"" for Projection(): respect the range set for the target axis (i.e. only project bins that are in range) but create the target histogram with the full axis.; Fix a bug in the multiplication of THnSparse.; Fix a bug whe creating with a given set of axis. Ensure that the first bin of the axis is >= 1.; ; THistPainter",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:5591,Availability,error,errors,5591,"e new structure is filled only when TProfile::Sumw2() is called or when TH1::SetDefaultSumw2() is set.; Add a new internal class, TProfileHelper for providing a common implementations for all TProfile classes for complex methods like Add and Merge.; Fix a bug in TProfile::GetStats method.; . THnSparse. Fix a bug where the axes of a THnSparse created by THnSparse::Projection() would be filled wrongly if the axis's range was set.; Fix a bug where the TAxis::kAxisRange bit was not reset for the new TH1/2/3 axes created by THnSparse::Projection(), if the original axis had a range and ""A"" was not given.; Implement new option ""O"" for Projection(): respect the range set for the target axis (i.e. only project bins that are in range) but create the target histogram with the full axis.; Fix a bug in the multiplication of THnSparse.; Fix a bug whe creating with a given set of axis. Ensure that the first bin of the axis is >= 1.; ; THistPainter. In case the errors of the fit parameters had large values (>E+07) the; errors in the fit box looked weird. The Method GetBestFormat has been; changed. The problem was visible with the following macro:. {; gStyle->SetOptFit(1111);; h = new TH1F(""h"",""h"", 2,0.,1.);; h->SetBinContent(1, 5E8);; h->SetBinError(1, 4.9E8);; h->Fit(""pol0"");; }. In THistPainter::PaintAxis repainting (gPad->RedrawAxis()); alphanumeric labels axis on a plot done with the option HBAR (horizontal); needed some adjustements. The following macro showed the problem. The; axis labels were wrongly painted:. {; TCanvas* canvas = new TCanvas(""Canvas"", ""Canvas"", 0, 0, 1000, 500);; canvas->Divide(2,1);; THStack* stack = new THStack(""Stack"", ""StackTitle"");; TH1F* hist1 = new TH1F(""Hist1"", ""Title1"", 1, 0, 100);; TH1F* hist2 = new TH1F(""Hist2"", ""Title2"", 1, 0, 100);; hist1->SetFillColor(kBlack);; hist2->SetFillColor(kGray);; for (int i = 0; i < 4; ++i) {; char dataName[50];; sprintf(dataName, ""Data%d"", i);; hist1->Fill(dataName, 10 + 50*i);; hist2->Fill(dataName, 145 - 40*i);; };",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:5650,Availability,error,errors,5650,"e new structure is filled only when TProfile::Sumw2() is called or when TH1::SetDefaultSumw2() is set.; Add a new internal class, TProfileHelper for providing a common implementations for all TProfile classes for complex methods like Add and Merge.; Fix a bug in TProfile::GetStats method.; . THnSparse. Fix a bug where the axes of a THnSparse created by THnSparse::Projection() would be filled wrongly if the axis's range was set.; Fix a bug where the TAxis::kAxisRange bit was not reset for the new TH1/2/3 axes created by THnSparse::Projection(), if the original axis had a range and ""A"" was not given.; Implement new option ""O"" for Projection(): respect the range set for the target axis (i.e. only project bins that are in range) but create the target histogram with the full axis.; Fix a bug in the multiplication of THnSparse.; Fix a bug whe creating with a given set of axis. Ensure that the first bin of the axis is >= 1.; ; THistPainter. In case the errors of the fit parameters had large values (>E+07) the; errors in the fit box looked weird. The Method GetBestFormat has been; changed. The problem was visible with the following macro:. {; gStyle->SetOptFit(1111);; h = new TH1F(""h"",""h"", 2,0.,1.);; h->SetBinContent(1, 5E8);; h->SetBinError(1, 4.9E8);; h->Fit(""pol0"");; }. In THistPainter::PaintAxis repainting (gPad->RedrawAxis()); alphanumeric labels axis on a plot done with the option HBAR (horizontal); needed some adjustements. The following macro showed the problem. The; axis labels were wrongly painted:. {; TCanvas* canvas = new TCanvas(""Canvas"", ""Canvas"", 0, 0, 1000, 500);; canvas->Divide(2,1);; THStack* stack = new THStack(""Stack"", ""StackTitle"");; TH1F* hist1 = new TH1F(""Hist1"", ""Title1"", 1, 0, 100);; TH1F* hist2 = new TH1F(""Hist2"", ""Title2"", 1, 0, 100);; hist1->SetFillColor(kBlack);; hist2->SetFillColor(kGray);; for (int i = 0; i < 4; ++i) {; char dataName[50];; sprintf(dataName, ""Data%d"", i);; hist1->Fill(dataName, 10 + 50*i);; hist2->Fill(dataName, 145 - 40*i);; };",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:7916,Availability,error,errors,7916,"Painter. The painting option ""]["" did not work if the frame line width; (set with gStyle->SetFrameLineWidth()) was bigger than 1.; The clipping in case of option ""same"" was not correct since; the move from TGraph to TGraphPainter. The following small example; showed the problem:; ; {; TH1F * h1 = new TH1F(""h1"", ""h1"", 100, -3., 3.);; TH1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8143,Availability,error,error,8143,"mple; showed the problem:; ; {; TH1F * h1 = new TH1F(""h1"", ""h1"", 100, -3., 3.);; TH1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for sho",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8569,Availability,error,errors,8569,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8726,Availability,error,error,8726,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:9167,Availability,avail,available,9167,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:288,Deployability,Update,Update,288,". Histogram package; TPaletteAxis. New method Int_t TPaletteAxis::GetValueColor(z) to; return the color index of the given z value.; ; This function should be used after an histogram has been plotted with the; option COL or COLZ like in the following example:; ; h2->Draw(""COLZ"");; gPad->Update();; TPaletteAxis *palette =; (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; Int_t ci = palette->GetValueColor(30.);; ; Then it is possible to retrieve the RGB components in the following way:; ; TColor *c = gROOT->GetColor(ci);; float x,y,z;; c->GetRGB(x,y,z);; ; This function is used by TPaletteAxis::GetBinColor(). TAxis. Implement a new function, TAxis::GetBinCenterLog(Int_t bin), as suggested at the issue #8263.; ; TGraph. When adding an object in the list of functions of a TGraph,; there was a crash at the TGraph drawing time if the; fitting option (gStyle->SetOptFit(1)) was on. This was; reported in: https://savannah.cern.ch/bugs/?46525; The following macro reproduces the problem:; ; {; gStyle->SetOptFit(1);; TGraph *gr = new TGraph(2);; gr->SetPoint(0,1,1);; gr->SetPoint(1,2,2);; TLatex *l1 = new TLatex(gr->GetX()[0], gr->GetY()[0], ""#1"");; gr->GetListOfFunctions()->Add(l1);; gr->Draw(""APL"");; }; . Fixed the bug #45607 by creating a list of functions when using TGraph default constructor.; Fixed a bug when fitting TGraphErrors with zero error in y but non-zero error in x. In GetHistogram:; if fHistogram exists, and the log scale is on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:4105,Integrability,depend,depending,4105," by the user. This fix the issue https://savannah.cern.ch/bugs/index.php?47946; Add a new option, option ""o"", in the projection methods: TH2::ProjectionX, TH2::ProjectionY, TH2::ProfileX and TH2::ProfileY. When an axis range is set, using option ""o"", the original axis range of the taget axes will be; kept, but only the bins inside the selected range will be filled, while bins outside the range will be empty. TH3. Add implementation of TH3::Interpolate using a tri-linear interpolation method; Fix a bug in TH3::Project3D (https://savannah.cern.ch/bugs/?46432) for the error calculation in case of weighted histogram (or when using option ""E"") and no axis range is set. In the projection to Profile's, when Sumw2 is set, have the correct projected errors now with the new TProfile data member.; Add TH3::ProjectionX and TH3::ProjectionY to complement the already existing ProjectionZ. They are all impelmented using the Project3D method.; Re-implement the TH3::Project3D method using the internal methods DoProject1D and DoProject2D depending on the option. This new implementation is faster in case sub-ranges are selected and fix this issue (https://savannah.cern.ch/bugs/index.php?45494).; A similar new implementation is done for TH3::ProjectProfile.; Add the new option ""o"", as in TH2 for the histogram and profile projections. TProfile, TProfile2D, TProfile3D. Add a new data member (TArrayD fBinSumw2) for storing the sum of weight square per bin. This is needed for correct error calculation in case of profile filled with weights different than 1. The new structure is filled only when TProfile::Sumw2() is called or when TH1::SetDefaultSumw2() is set.; Add a new internal class, TProfileHelper for providing a common implementations for all TProfile classes for complex methods like Add and Merge.; Fix a bug in TProfile::GetStats method.; . THnSparse. Fix a bug where the axes of a THnSparse created by THnSparse::Projection() would be filled wrongly if the axis's range was set.; Fix a",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8500,Integrability,message,message,8500,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:1980,Performance,Optimiz,Optimize,1980,"blem:; ; {; gStyle->SetOptFit(1);; TGraph *gr = new TGraph(2);; gr->SetPoint(0,1,1);; gr->SetPoint(1,2,2);; TLatex *l1 = new TLatex(gr->GetX()[0], gr->GetY()[0], ""#1"");; gr->GetListOfFunctions()->Add(l1);; gr->Draw(""APL"");; }; . Fixed the bug #45607 by creating a list of functions when using TGraph default constructor.; Fixed a bug when fitting TGraphErrors with zero error in y but non-zero error in x. In GetHistogram:; if fHistogram exists, and the log scale is on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the function integral is computed in TH1::FillRandom; Add new functions TH1::IsBinUnderflow(bin) and TH1::IsBinOverflow(bin) which use the global bin number.; Add new functions Int_t TH1::FindFirstBinAbove(Double_t threshold, Int_t axis) and Int_t TH1::FindLastBinAbove(Double_t threshold, Int_t axis) which find first (and last) bin with the content above the given threshold. Same function have been added in TH2 and TH3.; Add a protection in TH1::Sumw2() to avoid calling GetBinContent when the histograms are empty.; In TH1::Copy reset temporarily the kCanRebin bit before calling SetBinContent.; Fix the bug #48649in TH1::Add.; Fix a bug when calling TH1::Sumw2() on a non-empty histogram with default sum2 (i.e when TH1::GetDefaultSumw2() is true).; Add a method, TH1::ResetStats() to reset the internal statistics and force then the re-calculation suing the bin center first time is needed; Fix some problem with the statistics (in particular the number of entries) after some of the histogram opera",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8418,Performance,perform,perform,8418,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:2458,Safety,avoid,avoid,2458," on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the function integral is computed in TH1::FillRandom; Add new functions TH1::IsBinUnderflow(bin) and TH1::IsBinOverflow(bin) which use the global bin number.; Add new functions Int_t TH1::FindFirstBinAbove(Double_t threshold, Int_t axis) and Int_t TH1::FindLastBinAbove(Double_t threshold, Int_t axis) which find first (and last) bin with the content above the given threshold. Same function have been added in TH2 and TH3.; Add a protection in TH1::Sumw2() to avoid calling GetBinContent when the histograms are empty.; In TH1::Copy reset temporarily the kCanRebin bit before calling SetBinContent.; Fix the bug #48649in TH1::Add.; Fix a bug when calling TH1::Sumw2() on a non-empty histogram with default sum2 (i.e when TH1::GetDefaultSumw2() is true).; Add a method, TH1::ResetStats() to reset the internal statistics and force then the re-calculation suing the bin center first time is needed; Fix some problem with the statistics (in particular the number of entries) after some of the histogram operations. ; TH2. Consider in the projection of TH2 the axis range set by the user. This fix the issue https://savannah.cern.ch/bugs/index.php?47946; Add a new option, option ""o"", in the projection methods: TH2::ProjectionX, TH2::ProjectionY, TH2::ProfileX and TH2::ProfileY. When an axis range is set, using option ""o"", the original axis range of the taget axes will be; kept, but only the bins inside the selected range will be filled, while bins outside the range wi",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8216,Safety,avoid,avoid,8216,"., 3.);; TH1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the min",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8365,Safety,detect,detect,8365,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:1456,Testability,log,log,1456,";; float x,y,z;; c->GetRGB(x,y,z);; ; This function is used by TPaletteAxis::GetBinColor(). TAxis. Implement a new function, TAxis::GetBinCenterLog(Int_t bin), as suggested at the issue #8263.; ; TGraph. When adding an object in the list of functions of a TGraph,; there was a crash at the TGraph drawing time if the; fitting option (gStyle->SetOptFit(1)) was on. This was; reported in: https://savannah.cern.ch/bugs/?46525; The following macro reproduces the problem:; ; {; gStyle->SetOptFit(1);; TGraph *gr = new TGraph(2);; gr->SetPoint(0,1,1);; gr->SetPoint(1,2,2);; TLatex *l1 = new TLatex(gr->GetX()[0], gr->GetY()[0], ""#1"");; gr->GetListOfFunctions()->Add(l1);; gr->Draw(""APL"");; }; . Fixed the bug #45607 by creating a list of functions when using TGraph default constructor.; Fixed a bug when fitting TGraphErrors with zero error in y but non-zero error in x. In GetHistogram:; if fHistogram exists, and the log scale is on, and the computed range minimum is > 0, and; the fHistogram minimum is zero, then it means fHistogram limits have been computed; in linear scale therefore they might be too strict and cut some points. In that; case the fHistogram limits should be recomputed ie: the existing fHistogram; should not be returned. A example covering this case has been added in; stressGraphics. TH1. Speed up TH1::GetStats, TH2::GetStats, TH3::GetStats in case the sum of weights is null and the number of entries is also null; Optimize the way the function integral is computed in TH1::FillRandom; Add new functions TH1::IsBinUnderflow(bin) and TH1::IsBinOverflow(bin) which use the global bin number.; Add new functions Int_t TH1::FindFirstBinAbove(Double_t threshold, Int_t axis) and Int_t TH1::FindLastBinAbove(Double_t threshold, Int_t axis) which find first (and last) bin with the content above the given threshold. Same function have been added in TH2 and TH3.; Add a protection in TH1::Sumw2() to avoid calling GetBinContent when the histograms are empty.; In TH1::Copy reset tem",MatchSource.DOCS,hist/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:1069,Availability,error,error,1069,"organize and draw a list of; objects evolving with time. An example of use is shown in the tutorials; $ROOTSYS/tutorials/graphs/gtime.C and; $ROOTSYS/tutorials/graphs/gtime2.C. The tutorial gtime.C shows the evolution of a set of points with time and it; produces the following picture. The tutorial gtime2.C is an example of TGraphTime showing how the class could be used to visualize; a set of particles with their time stamp in a MonteCarlo program.; It produces the following picture. THStack. The following macro produced two sets of superimposed labels with different; text sizes:. {; TH1F *hgaus1 = new TH1F(""Hgaus1"", """", 100, -10, 10);; TH1F *hgaus2 = new TH1F(""Hgaus2"", """", 100, -20, 20);; THStack *hst = new THStack();; hgaus1->FillRandom(""gaus"", 30000); hst->Add(hgaus1, ""ep"");; hgaus2->FillRandom(""gaus"", 30000); hst->Add(hgaus2, ""ep"");; hst->Draw(""nostack"");; hst->GetHistogram()->SetLabelSize(0.07, ""xy"");; }. Change THStack::GetMaximum() and THStack::GetMinimum(); to make sure the error bars fit entirely on the plot when a; THStack is plotted with the option E. The following; macro showed the problem:. {; TH1D *h1 = new TH1D(""h1"",""h1"",10,0,10);; TH1D *h2 = new TH1D(""h2"",""h2"",10,0,10);; THStack h;. h1->SetLineColor(kRed);; h1->SetMarkerStyle(20),; h2->SetLineColor(kBlue);; h2->SetMarkerStyle(21);. for(int i=0; i<11; i++){; h1->SetBinContent(i,1.5-i/10);; h1->SetBinError(i,0.5*i);; h2->SetBinContent(i,10.5-i/10);; h2->SetBinError(i,0.7*i);; }. h.Add(h1);; h.Add(h2);; h.Draw(""nostack E1"");; }. TGraphPainter. TGraphAsymmErrors and TGraphBentErrors were not correctly clipped when; paint with the option E3 (filled band) and zoomed.; When drawn with the option B, a TGraph had the first or/and last bar missing; if its lowest or/and highest value were equal to the minimum or/and maximum; of the pad. The following lines illustrate the problem:; ; Int_t x[5] = {0,1,2,3,4};; Int_t y[5] = {10,1,2,3,0};; Int_t n = 5;; TGraph *gr = new TGraph(n,x,y);; gr->Draw(""AB*"");; ; This prob",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:3617,Availability,error,error,3617,"stack"");; hst->GetHistogram()->SetLabelSize(0.07, ""xy"");; }. TH1. Fix problem in the resulting statistics of TH1::Add when the coeffient are negative, for an histogram subtraction. This fixes the issue; #55911.; In the implementation of TH1::ResetStats(), set the statistics to the one calculated using the bin center and also reset the number of entries to the; total bin content or to the effective entries in case of a weighted histogram.; Check the histogram compatibility, by comparing each bin, in the case of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the sta",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:3701,Availability,error,error,3701,"n the resulting statistics of TH1::Add when the coeffient are negative, for an histogram subtraction. This fixes the issue; #55911.; In the implementation of TH1::ResetStats(), set the statistics to the one calculated using the bin center and also reset the number of entries to the; total bin content or to the effective entries in case of a weighted histogram.; Check the histogram compatibility, by comparing each bin, in the case of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:5643,Availability,Error,Error,5643,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:5669,Availability,error,error,5669,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:5981,Deployability,release,released,5981,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:6033,Deployability,release,release,6033,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:6052,Deployability,Update,Update,6052,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:6089,Deployability,update,update,6089,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:3122,Modifiability,variab,variable,3122,"949. TFormula. Add support for the ternary condition operator ( cond ? if_expr : else_expr ). THStack. The following macro produced two sets of superimposed labels with different; text sizes:. {; TH1F *hgaus1 = new TH1F(""Hgaus1"", """", 100, -10, 10);; TH1F *hgaus2 = new TH1F(""Hgaus2"", """", 100, -20, 20);; THStack *hst = new THStack();; hgaus1->FillRandom(""gaus"", 30000); hst->Add(hgaus1, ""ep"");; hgaus2->FillRandom(""gaus"", 30000); hst->Add(hgaus2, ""ep"");; hst->Draw(""nostack"");; hst->GetHistogram()->SetLabelSize(0.07, ""xy"");; }. TH1. Fix problem in the resulting statistics of TH1::Add when the coeffient are negative, for an histogram subtraction. This fixes the issue; #55911.; In the implementation of TH1::ResetStats(), set the statistics to the one calculated using the bin center and also reset the number of entries to the; total bin content or to the effective entries in case of a weighted histogram.; Check the histogram compatibility, by comparing each bin, in the case of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:6396,Modifiability,variab,variable,6396,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:6501,Modifiability,variab,variable,6501,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:4932,Security,access,access,4932,"unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:5466,Security,access,access,5466,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:3927,Testability,test,tests,3927,"ted using the bin center and also reset the number of entries to the; total bin content or to the effective entries in case of a weighted histogram.; Check the histogram compatibility, by comparing each bin, in the case of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user ca",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:4133,Testability,test,tests,4133," of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the ",MatchSource.DOCS,hist/doc/v526/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:1927,Availability,error,error,1927,"rmalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""bar1"");; }; . The setting gStyle->SetHistMinimumZero() now works for horizontal; plots produced with the option HBAR.; . In the case of profile ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:1945,Availability,Error,Error,1945,"rmalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""bar1"");; }; . The setting gStyle->SetHistMinimumZero() now works for horizontal; plots produced with the option HBAR.; . In the case of profile ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:4551,Availability,error,errors,4551,"wing lines generated an empty stats box:; ; gStyle->SetStatFont(43);; gStyle->SetStatFontSize(12);; TH2D *h2 = new TH2D(""h2"",""h2"",10,0,1,10,0,1);; h2->Draw();; . PaintAxis does not redraw the axis labels and the axis title in case; of axis redrawing. Only the tick marks are redrawn. Redrawing the; labels and title made them appear a bit thicker. Fix a precision issue in PaintInit. The problem showed up with; the following lines:; ; TF1 *f = new TF1(""f"",""exp(-x)*exp(x-2.)"",0.,2.0);; f->Draw();; . For 2D histograms plotted with option TEXT, it is possible to; plot empty cells by calling gStyle->SetHistMinimumZero(). An empty frame is drawn when an empty 1D histogram is painted with log; scale along the Y axis and when a 2D histogram is painted with log scale; along the Z axis. Log axis for TH3 histograms did not work. With option COL and SCAT, TH2 was drawn empty when all bins have the same content. TGraphPainter. When painted with option ""2"" (errors represented with boxes) the graph; with error bars were not clipped if the boxes were outside the frame; limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and; TGraphBentErrors. The following macro showed the problem:; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,700,500);. const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);. TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);; gr3->SetFillStyle(3006);. c1->DrawFrame(-1,0,1,10);. gr1->Draw(""2"");; gr2->Draw(""2"");; gr3->Draw(""2"");; }; . In",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:4598,Availability,error,error,4598,"wing lines generated an empty stats box:; ; gStyle->SetStatFont(43);; gStyle->SetStatFontSize(12);; TH2D *h2 = new TH2D(""h2"",""h2"",10,0,1,10,0,1);; h2->Draw();; . PaintAxis does not redraw the axis labels and the axis title in case; of axis redrawing. Only the tick marks are redrawn. Redrawing the; labels and title made them appear a bit thicker. Fix a precision issue in PaintInit. The problem showed up with; the following lines:; ; TF1 *f = new TF1(""f"",""exp(-x)*exp(x-2.)"",0.,2.0);; f->Draw();; . For 2D histograms plotted with option TEXT, it is possible to; plot empty cells by calling gStyle->SetHistMinimumZero(). An empty frame is drawn when an empty 1D histogram is painted with log; scale along the Y axis and when a 2D histogram is painted with log scale; along the Z axis. Log axis for TH3 histograms did not work. With option COL and SCAT, TH2 was drawn empty when all bins have the same content. TGraphPainter. When painted with option ""2"" (errors represented with boxes) the graph; with error bars were not clipped if the boxes were outside the frame; limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and; TGraphBentErrors. The following macro showed the problem:; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,700,500);. const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);. TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);; gr3->SetFillStyle(3006);. c1->DrawFrame(-1,0,1,10);. gr1->Draw(""2"");; gr2->Draw(""2"");; gr3->Draw(""2"");; }; . In",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:6221,Availability,error,error,6221,",.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);. TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);; gr3->SetFillStyle(3006);. c1->DrawFrame(-1,0,1,10);. gr1->Draw(""2"");; gr2->Draw(""2"");; gr3->Draw(""2"");; }; . In PaintGraphBentErrors the fill style was not set for the boxes.; The following macro displayed the histogram out of the frame; (option ""b""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""b"");; }; . It was not possible to interactively move a graph with many points; close to each other. It was only possible to move the points one by one.; PaintGrapHist: improvements with the option ""]["".; The new markers (style 32 to 34) were not taken into account in the; error bars drawing. Ie: the error bars were crossing the down triangle; (style 32). TGraph. Fix a bug in TGraph::Eval when evaluating at the graph point; values. ; With the following macro the axis title was not displayed:; ; {; TGraph *graph = new TGraph ();; graph->SetPoint(0, 0.00100, 30.00);; graph->SetPoint(1, 0.00150, 20.00);; graph->SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max nu",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:6249,Availability,error,error,6249,");; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);. TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);; gr3->SetFillStyle(3006);. c1->DrawFrame(-1,0,1,10);. gr1->Draw(""2"");; gr2->Draw(""2"");; gr3->Draw(""2"");; }; . In PaintGraphBentErrors the fill style was not set for the boxes.; The following macro displayed the histogram out of the frame; (option ""b""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""b"");; }; . It was not possible to interactively move a graph with many points; close to each other. It was only possible to move the points one by one.; PaintGrapHist: improvements with the option ""]["".; The new markers (style 32 to 34) were not taken into account in the; error bars drawing. Ie: the error bars were crossing the down triangle; (style 32). TGraph. Fix a bug in TGraph::Eval when evaluating at the graph point; values. ; With the following macro the axis title was not displayed:; ; {; TGraph *graph = new TGraph ();; graph->SetPoint(0, 0.00100, 30.00);; graph->SetPoint(1, 0.00150, 20.00);; graph->SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max number; of iterations as extra parameters with default values of; tolerance=10E",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:6278,Availability,down,down,6278,");; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);. TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);; gr3->SetFillStyle(3006);. c1->DrawFrame(-1,0,1,10);. gr1->Draw(""2"");; gr2->Draw(""2"");; gr3->Draw(""2"");; }; . In PaintGraphBentErrors the fill style was not set for the boxes.; The following macro displayed the histogram out of the frame; (option ""b""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""b"");; }; . It was not possible to interactively move a graph with many points; close to each other. It was only possible to move the points one by one.; PaintGrapHist: improvements with the option ""]["".; The new markers (style 32 to 34) were not taken into account in the; error bars drawing. Ie: the error bars were crossing the down triangle; (style 32). TGraph. Fix a bug in TGraph::Eval when evaluating at the graph point; values. ; With the following macro the axis title was not displayed:; ; {; TGraph *graph = new TGraph ();; graph->SetPoint(0, 0.00100, 30.00);; graph->SetPoint(1, 0.00150, 20.00);; graph->SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max number; of iterations as extra parameters with default values of; tolerance=10E",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:7175,Availability,toler,tolerance,7175,"re not taken into account in the; error bars drawing. Ie: the error bars were crossing the down triangle; (style 32). TGraph. Fix a bug in TGraph::Eval when evaluating at the graph point; values. ; With the following macro the axis title was not displayed:; ; {; TGraph *graph = new TGraph ();; graph->SetPoint(0, 0.00100, 30.00);; graph->SetPoint(1, 0.00150, 20.00);; graph->SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max number; of iterations as extra parameters with default values of; tolerance=10E-10 and max iterations=100; . TH1. Implement a faster version of TH1::FillRandom(TH1*,int); when the passed histogram has the same bins. In this case generate; the flactuations bin by bins using Multinomial statistics; . THnSparse. Shrink THnSparse on disk by 70% in an arbitrary example case;; also reduce memory usage, especially when not filling.; ; IMPORTANT NOTE: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!. Add SetBinContent(), AddBinContent(), SetBinError() taking the; linear bin index. Use it in Projection() for a considerable; speed-up. TSpectrum2Painter. New parameter bf() in the SPEC option to define the buffer size; used by TSpectrum2Painter. It is needed in case of very; large canvases like 8000x5000. New TEfficiency class. This new class from Christian Gumpert (CERN summer student 201",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:7259,Availability,toler,tolerance,7259,"re not taken into account in the; error bars drawing. Ie: the error bars were crossing the down triangle; (style 32). TGraph. Fix a bug in TGraph::Eval when evaluating at the graph point; values. ; With the following macro the axis title was not displayed:; ; {; TGraph *graph = new TGraph ();; graph->SetPoint(0, 0.00100, 30.00);; graph->SetPoint(1, 0.00150, 20.00);; graph->SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max number; of iterations as extra parameters with default values of; tolerance=10E-10 and max iterations=100; . TH1. Implement a faster version of TH1::FillRandom(TH1*,int); when the passed histogram has the same bins. In this case generate; the flactuations bin by bins using Multinomial statistics; . THnSparse. Shrink THnSparse on disk by 70% in an arbitrary example case;; also reduce memory usage, especially when not filling.; ; IMPORTANT NOTE: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!. Add SetBinContent(), AddBinContent(), SetBinError() taking the; linear bin index. Use it in Projection() for a considerable; speed-up. TSpectrum2Painter. New parameter bf() in the SPEC option to define the buffer size; used by TSpectrum2Painter. It is needed in case of very; large canvases like 8000x5000. New TEfficiency class. This new class from Christian Gumpert (CERN summer student 201",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:7572,Energy Efficiency,reduce,reduce,7572,">SetPoint(2, 0.01150, 30.00);; graph->Draw(""AL*"");; graph->GetXaxis()->SetTitle(""foo"") ;; gPad->SetLogx(1) ;; }; . New method IsInside(x,y). TMultiGraph. New method IsInside(x,y). THStack. The color index used to erase the background while drawing a stack of 1D; histogram was wrong. TF1. Bug fixed in TF1 zooming on Y axis. To reproduce it do:; ; root [0] TF1 f1( ""f1"", ""-x"", 1,3); root [1] f1.Draw(); ; now selecting some range on the y-axis with the mouse; jumped to the range (0, 1) instead of chosen range.; ; Add in TF1::GetX and TF1::GetMaximum, TF1::GetMinimum and; TF1::GetMaximumX, TF1::GetMinimumX the tolerance and max number; of iterations as extra parameters with default values of; tolerance=10E-10 and max iterations=100; . TH1. Implement a faster version of TH1::FillRandom(TH1*,int); when the passed histogram has the same bins. In this case generate; the flactuations bin by bins using Multinomial statistics; . THnSparse. Shrink THnSparse on disk by 70% in an arbitrary example case;; also reduce memory usage, especially when not filling.; ; IMPORTANT NOTE: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!. Add SetBinContent(), AddBinContent(), SetBinError() taking the; linear bin index. Use it in Projection() for a considerable; speed-up. TSpectrum2Painter. New parameter bf() in the SPEC option to define the buffer size; used by TSpectrum2Painter. It is needed in case of very; large canvases like 8000x5000. New TEfficiency class. This new class from Christian Gumpert (CERN summer student 2010) handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and bayesian; confidence intervals as well as a function for combining several efficiencies.; Example of usage: Creating a TEfficiency object; ; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:11239,Energy Efficiency,Energy,Energy,11239,"l on the efficiencies. For each statistical; option a corresponding static function esists taking as parameters; n, the number of total events, k, the number of; passed events and cl the desired confidence level and a; boolean flag specyfing if the upper (or lower) interval boundary; must be computed. Each statistics option can be set using the method; TEfficiency::SetStatisticOption; The major statistics options are (see class; documentation for a full description and examples):; ; Clopper_pearson (default) using the function; TEfficiency::ClopperPearson(n, k, cl). Bayesian methods using the function; TEfficiency::Bayesian(n, k, cl, alpha, beta).; In this case the alpha and beta parameters of the; beta prior distribution for the efficiency can be specified.; . Merging and combining different TEfficiency objects is; supported; (see the class; documentation):; . New TKDE class. New class for Kernel density estimation from Bartolomeu; Rabacal. The algorithm used is described in ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" -; e-Print Archive: hep ex/0011057 and more information can be found; also in ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; and ""Jann Ben -, Univariate kernel; density estimation document for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:1933,Integrability,message,message,1933,"rmalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""bar1"");; }; . The setting gStyle->SetHistMinimumZero() now works for horizontal; plots produced with the option HBAR.; . In the case of profile ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:8628,Modifiability,variab,variable,8628," ; IMPORTANT NOTE: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!. Add SetBinContent(), AddBinContent(), SetBinError() taking the; linear bin index. Use it in Projection() for a considerable; speed-up. TSpectrum2Painter. New parameter bf() in the SPEC option to define the buffer size; used by TSpectrum2Painter. It is needed in case of very; large canvases like 8000x5000. New TEfficiency class. This new class from Christian Gumpert (CERN summer student 2010) handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and bayesian; confidence intervals as well as a function for combining several efficiencies.; Example of usage: Creating a TEfficiency object; ; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the beginning. You can then use one of the constructors for fixed or; variable bin size and your desired dimension. These constructors append the; created TEfficiency object to the current directory. So it will be written; automatically to a file during the next TFile::Write; command.; Example 1: create a twodimensional TEfficiency object with 10; bins along X and 20 bins along Y:; ; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. You can fill the TEfficiency object by calling the Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; The boolean flag ""bPassed"" indicates whether the current event is a good; (both histograms are filled) or not (only fTotalHistogram is filled).; The variables x,y and z determine the bin which is filled. For lower; dimensions the z- or even the y-value may be omitted.; ; You can also set the number of passed or total events for a bin directly by using the SetPassedEvents or SetTotalEvents method.; If you already have two histograms filled with the number of passed and t",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:9298,Modifiability,variab,variables,9298,"t and bayesian; confidence intervals as well as a function for combining several efficiencies.; Example of usage: Creating a TEfficiency object; ; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the beginning. You can then use one of the constructors for fixed or; variable bin size and your desired dimension. These constructors append the; created TEfficiency object to the current directory. So it will be written; automatically to a file during the next TFile::Write; command.; Example 1: create a twodimensional TEfficiency object with 10; bins along X and 20 bins along Y:; ; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. You can fill the TEfficiency object by calling the Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; The boolean flag ""bPassed"" indicates whether the current event is a good; (both histograms are filled) or not (only fTotalHistogram is filled).; The variables x,y and z determine the bin which is filled. For lower; dimensions the z- or even the y-value may be omitted.; ; You can also set the number of passed or total events for a bin directly by using the SetPassedEvents or SetTotalEvents method.; If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; to fullfill the conditions mentioned in CheckConsistency,; otherwise the construction will fail.; Example 2: Create TEfficiency from 2 existing histograms:; ; TEfficiency * pEff = 0;; if (TEfficiency::CheckConsistency(h_pass,h_total)); pEff = new TEfficiency(h_pass,h_total);; . The TEfficiency class provides various statistics option based on; frequentist or Bayesian statistics to compute; the confidence interval on the efficiencies. For each statistical; option a corresponding static function esists taking as parameters; ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12530,Modifiability,inherit,inheriting,12530,"cument for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:345,Safety,safe,safer,345,". Histogram package; TGraphDelaunay. New version of the method TGraphDelaunay::Enclose(). This method; decides if a point is inside a triangle or not. The way it was implemented; produced infinite numbers and generated wrong peaks. It was visible on some; machines only (for instance MacOsX). Now this method uses; TMath::IsInside(). It is much safer, it runs faster, and the; code is simpler. The problem could be seen with a simple macro like the; following one:; ; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,600,600);; c1->SetTheta(90.);; c1->SetPhi(0.0001);; gStyle->SetPalette(1);; TGraph2D *graph2d = new TGraph2D();; graph2d->SetPoint(0, 110, 110, 0.0);; graph2d->SetPoint(1, -80, 50, 1.0);; graph2d->SetPoint(2, -70, 40, 2.0);; graph2d->SetPoint(3,-110, -50, 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12210,Safety,detect,detector,12210," Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" -; e-Print Archive: hep ex/0011057 and more information can be found; also in ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; and ""Jann Ben -, Univariate kernel; density estimation document for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12251,Security,Access,Access,12251," Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" -; e-Print Archive: hep ex/0011057 and more information can be found; also in ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; and ""Jann Ben -, Univariate kernel; density estimation document for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12343,Security,Access,Access,12343," Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" -; e-Print Archive: hep ex/0011057 and more information can be found; also in ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; and ""Jann Ben -, Univariate kernel; density estimation document for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:1790,Testability,log,log,1790,", 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i,",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:2054,Testability,test,test,2054,"erated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""bar1"");; }; . The setting gStyle->SetHistMinimumZero() now works for horizontal; plots produced with the option HBAR.; . In the case of profile histograms it is possible to print the number; of entries instead of the bin content. It is enough to combine th",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:4284,Testability,log,log,4284,"Fill(1.5,2);; profile->Fill(2.5,3);; profile->Fill(3.5,4);; profile->Fill(4.5,5);; profile->Fill(5.5,5);; profile->Fill(6.5,4);; profile->Fill(7.5,3);; profile->Fill(8.5,2);; profile->Fill(9.5,1);; c02->cd(1); profile->Draw(""HIST TEXT0"");; c02->cd(2); profile->Draw(""HIST TEXT0E"");; }; . The following lines generated an empty stats box:; ; gStyle->SetStatFont(43);; gStyle->SetStatFontSize(12);; TH2D *h2 = new TH2D(""h2"",""h2"",10,0,1,10,0,1);; h2->Draw();; . PaintAxis does not redraw the axis labels and the axis title in case; of axis redrawing. Only the tick marks are redrawn. Redrawing the; labels and title made them appear a bit thicker. Fix a precision issue in PaintInit. The problem showed up with; the following lines:; ; TF1 *f = new TF1(""f"",""exp(-x)*exp(x-2.)"",0.,2.0);; f->Draw();; . For 2D histograms plotted with option TEXT, it is possible to; plot empty cells by calling gStyle->SetHistMinimumZero(). An empty frame is drawn when an empty 1D histogram is painted with log; scale along the Y axis and when a 2D histogram is painted with log scale; along the Z axis. Log axis for TH3 histograms did not work. With option COL and SCAT, TH2 was drawn empty when all bins have the same content. TGraphPainter. When painted with option ""2"" (errors represented with boxes) the graph; with error bars were not clipped if the boxes were outside the frame; limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and; TGraphBentErrors. The following macro showed the problem:; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,700,500);. const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:4352,Testability,log,log,4352,"Fill(1.5,2);; profile->Fill(2.5,3);; profile->Fill(3.5,4);; profile->Fill(4.5,5);; profile->Fill(5.5,5);; profile->Fill(6.5,4);; profile->Fill(7.5,3);; profile->Fill(8.5,2);; profile->Fill(9.5,1);; c02->cd(1); profile->Draw(""HIST TEXT0"");; c02->cd(2); profile->Draw(""HIST TEXT0E"");; }; . The following lines generated an empty stats box:; ; gStyle->SetStatFont(43);; gStyle->SetStatFontSize(12);; TH2D *h2 = new TH2D(""h2"",""h2"",10,0,1,10,0,1);; h2->Draw();; . PaintAxis does not redraw the axis labels and the axis title in case; of axis redrawing. Only the tick marks are redrawn. Redrawing the; labels and title made them appear a bit thicker. Fix a precision issue in PaintInit. The problem showed up with; the following lines:; ; TF1 *f = new TF1(""f"",""exp(-x)*exp(x-2.)"",0.,2.0);; f->Draw();; . For 2D histograms plotted with option TEXT, it is possible to; plot empty cells by calling gStyle->SetHistMinimumZero(). An empty frame is drawn when an empty 1D histogram is painted with log; scale along the Y axis and when a 2D histogram is painted with log scale; along the Z axis. Log axis for TH3 histograms did not work. With option COL and SCAT, TH2 was drawn empty when all bins have the same content. TGraphPainter. When painted with option ""2"" (errors represented with boxes) the graph; with error bars were not clipped if the boxes were outside the frame; limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and; TGraphBentErrors. The following macro showed the problem:; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,700,500);. const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:4381,Testability,Log,Log,4381,";; profile->Fill(6.5,4);; profile->Fill(7.5,3);; profile->Fill(8.5,2);; profile->Fill(9.5,1);; c02->cd(1); profile->Draw(""HIST TEXT0"");; c02->cd(2); profile->Draw(""HIST TEXT0E"");; }; . The following lines generated an empty stats box:; ; gStyle->SetStatFont(43);; gStyle->SetStatFontSize(12);; TH2D *h2 = new TH2D(""h2"",""h2"",10,0,1,10,0,1);; h2->Draw();; . PaintAxis does not redraw the axis labels and the axis title in case; of axis redrawing. Only the tick marks are redrawn. Redrawing the; labels and title made them appear a bit thicker. Fix a precision issue in PaintInit. The problem showed up with; the following lines:; ; TF1 *f = new TF1(""f"",""exp(-x)*exp(x-2.)"",0.,2.0);; f->Draw();; . For 2D histograms plotted with option TEXT, it is possible to; plot empty cells by calling gStyle->SetHistMinimumZero(). An empty frame is drawn when an empty 1D histogram is painted with log; scale along the Y axis and when a 2D histogram is painted with log scale; along the Z axis. Log axis for TH3 histograms did not work. With option COL and SCAT, TH2 was drawn empty when all bins have the same content. TGraphPainter. When painted with option ""2"" (errors represented with boxes) the graph; with error bars were not clipped if the boxes were outside the frame; limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and; TGraphBentErrors. The following macro showed the problem:; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",200,10,700,500);. const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};. TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);; gr1->SetFillStyle(3004);. TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);; gr2->SetFillStyle(3005);.",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:385,Usability,simpl,simpler,385,". Histogram package; TGraphDelaunay. New version of the method TGraphDelaunay::Enclose(). This method; decides if a point is inside a triangle or not. The way it was implemented; produced infinite numbers and generated wrong peaks. It was visible on some; machines only (for instance MacOsX). Now this method uses; TMath::IsInside(). It is much safer, it runs faster, and the; code is simpler. The problem could be seen with a simple macro like the; following one:; ; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,600,600);; c1->SetTheta(90.);; c1->SetPhi(0.0001);; gStyle->SetPalette(1);; TGraph2D *graph2d = new TGraph2D();; graph2d->SetPoint(0, 110, 110, 0.0);; graph2d->SetPoint(1, -80, 50, 1.0);; graph2d->SetPoint(2, -70, 40, 2.0);; graph2d->SetPoint(3,-110, -50, 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:427,Usability,simpl,simple,427,". Histogram package; TGraphDelaunay. New version of the method TGraphDelaunay::Enclose(). This method; decides if a point is inside a triangle or not. The way it was implemented; produced infinite numbers and generated wrong peaks. It was visible on some; machines only (for instance MacOsX). Now this method uses; TMath::IsInside(). It is much safer, it runs faster, and the; code is simpler. The problem could be seen with a simple macro like the; following one:; ; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,600,600);; c1->SetTheta(90.);; c1->SetPhi(0.0001);; gStyle->SetPalette(1);; TGraph2D *graph2d = new TGraph2D();; graph2d->SetPoint(0, 110, 110, 0.0);; graph2d->SetPoint(1, -80, 50, 1.0);; graph2d->SetPoint(2, -70, 40, 2.0);; graph2d->SetPoint(3,-110, -50, 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12685,Usability,simpl,simple,12685,"SVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in $ROOTSYS/tutorials/hist/:. ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12994,Usability,simpl,simple,12994,"SVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in $ROOTSYS/tutorials/hist/:. ",MatchSource.DOCS,hist/doc/v528/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:442,Availability,toler,tolerance,442,". Histogram package; All Histogram classes (including the TProfile's). Add support for filling histograms with negative weights. Now the correct global histogram statistics (Mean, Standard; deviation, etc..) is computed, while before the abs(w) was used when computing the histogram statistics.; ; Updated in all the projection function the check for the compatibility with previously existing histograms, now; the limits are checked using a tolerance/; Fix a bug in computing the point errors when fitting a 2d (or 3D) histogram with a 1d (or 2D) function. TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfe",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:487,Availability,error,errors,487,". Histogram package; All Histogram classes (including the TProfile's). Add support for filling histograms with negative weights. Now the correct global histogram statistics (Mean, Standard; deviation, etc..) is computed, while before the abs(w) was used when computing the histogram statistics.; ; Updated in all the projection function the check for the compatibility with previously existing histograms, now; the limits are checked using a tolerance/; Fix a bug in computing the point errors when fitting a 2d (or 3D) histogram with a 1d (or 2D) function. TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfe",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:913,Availability,error,errors,913,". Histogram package; All Histogram classes (including the TProfile's). Add support for filling histograms with negative weights. Now the correct global histogram statistics (Mean, Standard; deviation, etc..) is computed, while before the abs(w) was used when computing the histogram statistics.; ; Updated in all the projection function the check for the compatibility with previously existing histograms, now; the limits are checked using a tolerance/; Fix a bug in computing the point errors when fitting a 2d (or 3D) histogram with a 1d (or 2D) function. TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfe",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3285,Availability,error,error,3285,".; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fix",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3398,Availability,error,error,3398,".; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fix",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3473,Availability,error,error,3473,"with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fixes in the TEfficiency::Draw and Paint methods. . TSVDUnfold. Rescaling using full covariance matrix rather than neglecting; correlations.; Computed cova",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3666,Availability,error,error,3666,"verlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fixes in the TEfficiency::Draw and Paint methods. . TSVDUnfold. Rescaling using full covariance matrix rather than neglecting; correlations.; Computed covariance matrix via GetXtau() and inverse via; GetXinv(). ",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3901,Availability,error,errors,3901,"verlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fixes in the TEfficiency::Draw and Paint methods. . TSVDUnfold. Rescaling using full covariance matrix rather than neglecting; correlations.; Computed covariance matrix via GetXtau() and inverse via; GetXinv(). ",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:298,Deployability,Update,Updated,298,". Histogram package; All Histogram classes (including the TProfile's). Add support for filling histograms with negative weights. Now the correct global histogram statistics (Mean, Standard; deviation, etc..) is computed, while before the abs(w) was used when computing the histogram statistics.; ; Updated in all the projection function the check for the compatibility with previously existing histograms, now; the limits are checked using a tolerance/; Fix a bug in computing the point errors when fitting a 2d (or 3D) histogram with a 1d (or 2D) function. TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfe",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:3214,Deployability,Update,Update,3214,"r plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by ",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:4128,Deployability,Update,Update,4128,"verlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation of binomial errors in >TGraphAsymErrors::Divide for the case the histogram have weights.; Have methods working for Bayesian and Normal statistic options. For the others options the division using weights is; not supported.; . TEfficiency. Update in the class by implementing DistancetoPrimitive and ExecuteEvent. This allows the; possibility to click on the object; Add methods to returned the drawn graph (1D) or the histogram (2D).; Apply some fixes in the TEfficiency::Draw and Paint methods. . TSVDUnfold. Rescaling using full covariance matrix rather than neglecting; correlations.; Computed covariance matrix via GetXtau() and inverse via; GetXinv(). ",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:837,Performance,perform,perform,837,". Histogram package; All Histogram classes (including the TProfile's). Add support for filling histograms with negative weights. Now the correct global histogram statistics (Mean, Standard; deviation, etc..) is computed, while before the abs(w) was used when computing the histogram statistics.; ; Updated in all the projection function the check for the compatibility with previously existing histograms, now; the limits are checked using a tolerance/; Fix a bug in computing the point errors when fitting a 2d (or 3D) histogram with a 1d (or 2D) function. TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfe",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:1581,Performance,perform,performed,1581,". TH1. Add support for weighted likelihood fit of histogram by using a new option, WL and suppress the old option; LL.; The histogram must have the sum of the weight squared stored bin by bin to use this fit option; (i.e. TH1::Sumw2() has been called before filling).; Now one can perform likelihoof fit to weighted or scaled histograms and get the correct errors in the fit parameters.; (see bug report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. I",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:1988,Safety,avoid,avoid,1988,"g report 79754).; ; Fix for the bug 82562.; Fix a bug in TH1::Merge for histogram with labels (bug 75902).; Fix few bugs related with the Buffer. . TProfile. Fix a bug in TProfile::Merge when the kCanRebin bit is set; (bug 79675).; Fix a bug in LabelsDeflate (bug 77149). TH1. Add new method TH3::Rebin3D and alsoRebinX, RebinY and RebinZ thanks to Zhiyi Liu. THistPainter. TPad::SetTheta() and TPad::SetPhi() did not cause the; canvas redrawing.; Protection added in case two histograms were plotted in the same pad; using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:2526,Safety,avoid,avoid,2526,"using the option BOX (the 2nd one with option SAME).; The clipping was not correct when an interactive zoom was performed. The 2D functions, for instance a fit function, associated to a 2D; histogram were always drawn as scatter plots. This was very confusing.; Now they are drawn as a surface if the histogram plotting option is a; lego or a surface or as a contour plot for any other plotting options. When drawing scatter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option for",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html:2840,Testability,log,logic,2840,"atter plot for TH2 or TH2Poly do not use gRandom, but an independent random generator instance,; to avoid interfering with gRandom (bug 83021).; Now the same random sequence is always used for drawing the same histograms, giving therefore exactly the same scatter plot for the same; histogram, while before a slightly different plot was obtained every time. TH2Poly. Add(const TH1 *h1, Double_t c1) has been implemented.; Reset() has been implemented.; The destructor has been completed. THStack. When the 1D histograms in a stack are painted with patterns or hatches; the histograms are first painted with the TFrame background color to avoid; the hatches overlaps. In case the TFrame background color was 0 this did not; work because in that case the histogram is painted hollow. Instead of 0 we; now use 10 (also white). TGraph. The default browsing option for graphs is now ""alp"".; Like SetPoint the method Apply modifies the graph; content. So, a logic similar to the one implemented in SetPoint; is now done, ie:; ; if fHistogram exists it is reset.; if gPad exist a gPad->Modified() is issued. TGraphErrors. The following macro generated wrong C++ code. {; TGraphErrors *ge = new TGraphErrors(2);; ge->SetName(""aaa""); // <<< without this it works; ge->SetPoint(1, 1, 1); ge->SetPoint(2, 2, 1);; ge->Draw(""ap*"");; gPad->Update();; ge->SavePrimitive(cout);; }. The option ""0"" for graphs with error bars is no implemented:; ""By default, when a data point is outside the visible range; along the Y axis the error bars are not drawn. Combined with; other options, this option forces error bars' drawing for the; data points outside the visible range along the Y axis.""; A similar option already existed for histograms. When fitting TGraphErrors and a linear function, use the error in X, before they were not used,; while they were used for non-linear fits. . TFractionFitter. New version from Frank Filthaut providing the possibility to exclude bins from the fit. TGraphAsymErrors. Fix calculation",MatchSource.DOCS,hist/doc/v530/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v530/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:2124,Availability,error,error,2124,"::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro genera",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:2224,Availability,error,error,2224,". TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro generated a wrong output (tmp.C). void testGraphPrec() {; double offset=55.0;; T",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:1034,Deployability,update,update,1034,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:1681,Deployability,Update,Update,1681," SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are ",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:447,Modifiability,variab,variable,447,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:485,Modifiability,variab,variable,485,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:1870,Modifiability,variab,variable,1870,"mand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanv",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:36,Performance,perform,performances,36,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:287,Performance,perform,performs,287,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:2359,Safety,avoid,avoid,2359,"mand erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro generated a wrong output (tmp.C). void testGraphPrec() {; double offset=55.0;; TCanvas* myC = new TCanvas(""myC"",""myC"",600,400);; TGraph* gr=new TGraph();; for (int i=0; i < 1000; i++) {; double",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:3179,Testability,test,testGraphPrec,3179,"vas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanvas * canvas = new TCanvas(""glC"",""C"",800,800);; TH3D *h = new TH3D(""h3"",""h3"",150,0,20,150,-5,5,150,-5,5);; ntuple->Draw(""px:py+1:pz+4.7>>h3"","""",""Q"");; }. TGraph. TGraph::SavePrimitive() uses a greater precision to output the; X and Y vectors. The following macro generated a wrong output (tmp.C). void testGraphPrec() {; double offset=55.0;; TCanvas* myC = new TCanvas(""myC"",""myC"",600,400);; TGraph* gr=new TGraph();; for (int i=0; i < 1000; i++) {; double point_x = 3.0+((double) i)*1e-7;; double point_y = offset+((double) i)*1e-8;; gr->SetPoint(i,point_x,point_y);; }; gr->Draw(""AP"");; myC->Print(""tmp.C"");; }. The constructor from a file is now able to handle delimiters. Like in the .csv files.; (Implementation done by Mathieu Trocme). TGraphErrors. The constructor from a file is now able to handle delimiters. Like in the .csv files.; (Implementation done by Mathieu Trocme). TGraph2D. The constructor from a file is now able to handle delimiters. Like in the .csv files.; (Implementation done by Mathieu Trocme); . ",MatchSource.DOCS,hist/doc/v532/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:2178,Availability,error,errors,2178,"text for; each bin is placed taking into account the bar offset and bar width attributes. Previously,; when several histogram were drawn that way, the texts overlapped. When a TF1 was clipped vertically, horizotal lines appeared at the maximum and minimum; when the function was draw with a line width greater than 1.; The follwoing macro reproduces the problem:. {; TCanvas *c1=new TCanvas(""c1"", ""A canvas"", 10,0, 800, 600);; c1->SetLogy();; histo_dummy=c1->DrawFrame(0,1e-4,27,10);; TF1 gaussian_func(""gaussian_func"",""gaus"",0,25.4);; gaussian_func.SetLineColor(kRed);; gaussian_func.SetParameters(1e-2,10,3);; gaussian_func.Draw(""same"");; }. When two histograms where painted on top of each other with the option BOX (the; 2nd one with BOX,SAME) the plot was wrong if the minimum of the first histogram; was not zero. Take into account the absolute value of the histogram's minimum to compute the; maximal boxes' size when an histogram is drawn with the option BOX. Add support for drawing the asymmetric errors for the TH1 and TH2. The fit function was not drawn in the correct range when a fitted 2D histogram was painted; with the option lego or surf. With option TEXT, do not draw the bins with 0 content for 1D; histograms to be consistent with the 2D histograms case.; Example:. root [0] TH1D * histo = new TH1D (""histo"","""",20,-5.,5.) ;; root [1] histo->FillRandom(""gaus"",1000) ;; root [2] histo->Draw(""hist,text"") ;. TAxis. A time axis defined with the GMT option, saved into a root file in a; given time zone, was different when displayed in an other time zone.; The time zone offset in which the axis was created is now saved with; the time axis offset allowing to make the right adjustments when; the axis is displayed in an other time zone. TGraph2DPainter. Because of the range along the Z axis, the following macro produced a wrong plot.; The markers' colors did not match the palette and some of them were not clipped. {; Double_t x[10] = {1.,2.,3.,4.,5.,6.,7.,8.,9.,10.};; Double_t y[",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:4530,Availability,error,errors,4530,"200,10,700,500);; c1->SetFrameFillColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:4654,Availability,error,error,4654,"llColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin labels no warning is produced. ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:4713,Availability,error,errors,4713,"llColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin labels no warning is produced. ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:4779,Availability,error,errors,4779,"llColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin labels no warning is produced. ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:4837,Availability,error,error,4837,"llColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin labels no warning is produced. ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:5003,Availability,error,error,5003,"llColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->Draw(""a fb l3d"");; }. TH1. A canvas saved in a .C file generated wrong code if it contained; an histogram drawn with the option COLZ. Add the support for asymmetric errors, by adding the methods TH1::GetBinErrorLow(ibin) and; TH1::GetBinErrorUp(ibin). Add possibility to use different bin error types with TH1::SetBinErrorOption(type). The type of errors which one can set are:; TH1::kNormal: this are the default errors (symmetric) based on the normal approximation. Bin error = sqrt(N).; In case of a weighted histogram (non-integer bin content), the normal approximation is always used; TH1::kPoisson: in this case the lower and upper error are defined by the 68% classical (frequentist) Poisson interval for N counts; (Garwood Poisson interval).; TH1::kPoisson2: as above but in this case a 95% (2-sigma) Poisson interval is used. . Change all the TH1::Add, TH1::Divide, TH1::Multiply, methods and those in the derived classes (e.g. in TProfile classes) to return a boolean. The boolean is set to false in case the method fails (e.g when the histograms are not consistent,; they have different bins); Add in TH1::Add a check for the labels. If the histogram axes to be added have same bin labels no warning is produced. ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:138,Integrability,interface,interfaces,138,". Histogram Libraries; THn, THnBase, THNSparse. The new, non-sparse n-dimensional histogram THn has been introduced.; It follows the same interfaces as THnSparse, and thus also implements THnF THnD THnC THnS THnI THnL.; NOTE: the memory usage of this class increases with the number of bins, i.e. exponentially with the number of dimensions!; A 5-dimensional THnD with 100 bins per dimension uses more than 80GB of RAM!; Better use THnSparse if only a small fraction of the bins are filled.; Most algorithms are now implemented in THnBase, the new common base class of THnSparse and THn.; If a function does not care about the actual storage format on in incoming objects it might as well reference a THnBase.; The bins of THn are held by objects of the new type TNDArray: an n-dimensional array with lazy allocation (only when a bin is set) that implements an operator [].; THn and THnSparse can be created from histograms and from each other, allowing for easy conversion. There is currently no support for drawing a THnBase-derived object; project it into a TH1/2/3 first. THistPainter. When 1D histograms are painted with the options TEXT and BAR simultaneously, the text for; each bin is placed taking into account the bar offset and bar width attributes. Previously,; when several histogram were drawn that way, the texts overlapped. When a TF1 was clipped vertically, horizotal lines appeared at the maximum and minimum; when the function was draw with a line width greater than 1.; The follwoing macro reproduces the problem:. {; TCanvas *c1=new TCanvas(""c1"", ""A canvas"", 10,0, 800, 600);; c1->SetLogy();; histo_dummy=c1->DrawFrame(0,1e-4,27,10);; TF1 gaussian_func(""gaussian_func"",""gaus"",0,25.4);; gaussian_func.SetLineColor(kRed);; gaussian_func.SetParameters(1e-2,10,3);; gaussian_func.Draw(""same"");; }. When two histograms where painted on top of each other with the option BOX (the; 2nd one with BOX,SAME) the plot was wrong if the minimum of the first histogram; was not zero. Take into ",MatchSource.DOCS,hist/doc/v534/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html
https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html:574,Usability,simpl,simply,574,". Html; THtml is now using the leyout of the new ROOT web site. There is a number of other improvements:. The sources now show line numbers. Each line number is a link and an anchor, i.e. it can be jumped to.; The line number can be copy&pasted: mark the line number from the right and drag your mouse to the left until teh line number and a space next to it are marked. When you paste this you will get the file and line number in the GDB-format (MyFile.cxx:123), e.g. to set breakpoints.; THtml now uses short class names, e.g. map<A,B,less<A>,allocator<pair<A,B> > > now simply becomes map<A,B>. ",MatchSource.DOCS,html/doc/v524/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:55,Availability,down,download,55,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:163,Availability,down,download,163,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:470,Availability,down,download,470,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:705,Deployability,patch,patches,705,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:843,Deployability,patch,patches,843,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:1005,Deployability,install,install,1005,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:1186,Deployability,Install,Install,1186,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:1234,Deployability,Release,Release,1234,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:915,Modifiability,config,configure,915,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:1110,Modifiability,config,configure,1110,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:1226,Modifiability,config,config,1226,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:341,Testability,test,test,341,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,interpreter/cling/www/build.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1784,Availability,error,error,1784,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1790,Availability,recover,recovery,1790,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1858,Availability,error,error,1858,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1864,Availability,recover,recovery,1864,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1878,Availability,error,error,1878,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1884,Availability,recover,recovery,1884,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1948,Availability,error,error,1948,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:2308,Availability,error,error,2308,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:492,Deployability,release,release,492,". Cling. Collaborate With Us . Every contribution is considered a donation and its copyright and any other; related rights become exclusive ownership of the person who merged the code or; in any other case the main developers of the ""Cling Project"". We warmly welcome external contributions to the Cling! By providing code,; you agree to transfer your copyright on the code to the ""Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:710,Deployability,patch,patch,710,". Cling. Collaborate With Us . Every contribution is considered a donation and its copyright and any other; related rights become exclusive ownership of the person who merged the code or; in any other case the main developers of the ""Cling Project"". We warmly welcome external contributions to the Cling! By providing code,; you agree to transfer your copyright on the code to the ""Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1309,Modifiability,Extend,Extending,1309,"Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1714,Modifiability,extend,extended,1714,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1726,Safety,detect,detect,1726,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1790,Safety,recover,recovery,1790,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1864,Safety,recover,recovery,1864,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:1884,Safety,recover,recovery,1884,"source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match. Enabling clang's static analyzer - coming soon. Enabling ObjectiveC/ObjectiveC++ support - coming soon. ",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:895,Testability,test,tests,895,". Cling. Collaborate With Us . Every contribution is considered a donation and its copyright and any other; related rights become exclusive ownership of the person who merged the code or; in any other case the main developers of the ""Cling Project"". We warmly welcome external contributions to the Cling! By providing code,; you agree to transfer your copyright on the code to the ""Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:782,Usability,simpl,simple,782,". Cling. Collaborate With Us . Every contribution is considered a donation and its copyright and any other; related rights become exclusive ownership of the person who merged the code or; in any other case the main developers of the ""Cling Project"". We warmly welcome external contributions to the Cling! By providing code,; you agree to transfer your copyright on the code to the ""Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int",MatchSource.DOCS,interpreter/cling/www/contribute.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/header.html:30,Integrability,Interface,Interface,30,. Cling; Interactive Compiler Interface. Home; Use; Build; Contribute; Jupyter. ,MatchSource.DOCS,interpreter/cling/www/header.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/header.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:3037,Availability,Down,Download,3037,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:3148,Availability,avail,available,3148,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:3162,Availability,down,download,3162,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1538,Deployability,configurat,configuration,1538,"ses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumen",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:3102,Deployability,Release,Release,3102,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:3120,Deployability,release,release,3120,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:983,Energy Efficiency,power,power,983,"**************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1582,Integrability,interface,interface,1582," interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requir",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:2109,Integrability,depend,dependent,2109,"l snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling accor",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1538,Modifiability,config,configuration,1538,"ses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumen",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:2413,Modifiability,config,config,2413,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:650,Performance,perform,performance,650,". Cling. Cling interprets C++. ****************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compila",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:770,Usability,Learn,Learning,770,". Cling. Cling interprets C++. ****************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compila",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:827,Usability,learn,learning,827,". Cling. Cling interprets C++. ****************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compila",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:863,Usability,feedback,feedback,863,". Cling. Cling interprets C++. ****************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compila",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1386,Usability,feedback,feedback,1386,"<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclan",MatchSource.DOCS,interpreter/cling/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:39,Deployability,integrat,integrated,39,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:404,Deployability,Install,Install,404,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:417,Deployability,install,install,417,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:554,Deployability,install,install,554,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:579,Deployability,install,install,579,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:639,Deployability,install,install,639,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:688,Deployability,install,install,688,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:39,Integrability,integrat,integrated,39,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,interpreter/cling/www/jupyter.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:21,Deployability,release,release,21,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:74,Deployability,release,release,74,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:126,Deployability,release,release,126,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:178,Deployability,release,release,178,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:235,Deployability,release,release,235,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:291,Deployability,release,release,291,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:347,Deployability,release,release,347,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:405,Deployability,release,release,405,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:459,Deployability,release,release,459,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html:515,Deployability,release,release,515,". Latest News; Cling release 1.1 is out; Aug 28th, 2023; Read more. Cling release 1.0 is out; Dec 9th, 2023; Read more. Cling release 0.9 is out; May 4th, 2021; Read more. Cling release 0.8 is out; January 11th, 2021; Read more. Cling release 0.7 is out; August 21th, 2020; Read more. Cling release 0.6 is out; August 16th, 2019; Read more. Cling release 0.5 is out; November 02nd, 2017; Read more. Cling release 0.4 is out; June 06th, 2017; Read more. Cling release 0.3 is out; August 09th, 2016; Read more. Cling release 0.2 is out; July 06th, 2016; Read more. Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. ",MatchSource.DOCS,interpreter/cling/www/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:1127,Deployability,integrat,integrate,1127,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,interpreter/cling/www/use.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:1127,Integrability,integrat,integrate,1127,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,interpreter/cling/www/use.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:1179,Integrability,depend,depend,1179,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,interpreter/cling/www/use.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:295,Modifiability,extend,extend,295,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,interpreter/cling/www/use.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:577,Performance,Load,Loads,577,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,interpreter/cling/www/use.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:70,Availability,Down,Download,70,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:139,Availability,Error,Error,139,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:145,Availability,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:53,Integrability,Interface,Interface,53,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:453,Integrability,interface,interface,453,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:803,Integrability,depend,depends,803,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:145,Safety,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:569,Usability,learn,learn,569,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:990,Usability,feedback,feedback,990,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:1010,Usability,clear,clear,1010,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/ClingAnnouncement.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:70,Availability,Down,Download,70,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:139,Availability,Error,Error,139,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:145,Availability,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:53,Integrability,Interface,Interface,53,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:389,Integrability,interface,interface,389,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:145,Safety,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/news/NewWebsiteLaunched.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:85,Availability,Down,Download,85,". Cling Website - Get Involved. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input sho",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:154,Availability,Error,Error,154,". Cling Website - Get Involved. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input sho",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:160,Availability,Recover,Recovery,160,". Cling Website - Get Involved. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input sho",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1718,Availability,error,error,1718,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1724,Availability,recover,recovery,1724,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1792,Availability,error,error,1792,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1798,Availability,recover,recovery,1798,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1812,Availability,error,error,1812,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1818,Availability,recover,recovery,1818,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1882,Availability,error,error,1882,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:2242,Availability,error,error,2242,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:68,Integrability,Interface,Interface,68,". Cling Website - Get Involved. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input sho",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1601,Integrability,interface,interface,1601,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1092,Modifiability,Extend,Extending,1092,"cs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be trigge",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1497,Modifiability,extend,extended,1497,"t: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; .",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:160,Safety,Recover,Recovery,160,". Cling Website - Get Involved. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Get Involved; Where are we; You can find us at: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input sho",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1509,Safety,detect,detect,1509,"t: rootdev [at] root.cern.ch; File a bug; If there is something wrong please check our bug database here and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; .",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1724,Safety,recover,recovery,1724,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1798,Safety,recover,recovery,1798,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1818,Safety,recover,recovery,1818,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/contact.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:70,Availability,Down,Download,70,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:139,Availability,Error,Error,139,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:145,Availability,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:53,Integrability,Interface,Interface,53,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:523,Integrability,interface,interface,523,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:145,Safety,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/docs.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:8,Availability,Down,Download,8,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:71,Availability,Down,Download,71,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:140,Availability,Error,Error,140,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:146,Availability,Recover,Recovery,146,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:459,Availability,Down,Download,459,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:516,Availability,down,download,516,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:614,Availability,down,download,614,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:870,Availability,down,download,870,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1686,Availability,down,download,1686,"erequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program F",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1211,Deployability,patch,patches,1211," Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cma",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1228,Deployability,patch,patch,1228,"ed. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in t",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1373,Deployability,install,installed,1373,"aunched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj -",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1401,Deployability,install,install,1401,ite of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button an,MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1424,Deployability,install,install,1424,ite of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button an,MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1472,Deployability,install,installation,1472,nload & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio v,MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2125,Deployability,patch,patches,2125,"/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2154,Deployability,patch,patches,2154,"/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2989,Deployability,INSTALL,INSTALL,2989,"; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More information about cmake in LLVM and Clang could be found here and here.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:3032,Deployability,INSTALL,INSTALL,3032,"; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More information about cmake in LLVM and Clang could be found here and here.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:54,Integrability,Interface,Interface,54,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1239,Modifiability,Config,Configure,1239,"th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and th",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1342,Modifiability,config,configure,1342,"aunched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj -",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2389,Modifiability,Config,Configure,2389,"; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More information about cmake in LLVM and Clang could be found here and here.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2516,Modifiability,config,configuring,2516,"; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More information about cmake in LLVM and Clang could be found here and here.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:146,Safety,Recover,Recovery,146,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:825,Testability,test,test,825,". Cling Download. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ",MatchSource.DOCS,interpreter/cling/www/old/download.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:70,Availability,Down,Download,70,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:139,Availability,Error,Error,139,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:145,Availability,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4257,Availability,avail,available,4257,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2861,Deployability,integrat,integrate,2861,"ang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run th",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:53,Integrability,Interface,Interface,53,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2861,Integrability,integrat,integrate,2861,"ang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run th",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2913,Integrability,depend,depend,2913,"g is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should b",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3730,Integrability,wrap,wrapped,3730,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3979,Integrability,wrap,wrapped,3979,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2029,Modifiability,extend,extend,2029,"f the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3565,Modifiability,Variab,Variable,3565,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3869,Modifiability,variab,variables,3869,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3887,Modifiability,variab,variables,3887,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3967,Modifiability,variab,variable,3967,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4005,Modifiability,variab,variables,4005,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4070,Modifiability,variab,variables,4070,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4246,Modifiability,extend,extend,4246,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4280,Modifiability,extend,extending,4280,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:974,Performance,perform,performance,974,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2311,Performance,Load,Loads,2311,"or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). Thi",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4226,Performance,load,loaded,4226,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4322,Performance,load,loaded,4322,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:145,Safety,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Cling. Welcome to our interactive C++ interpreter, built on the top of LLVM and Clang libraries. Its advantages over the standard interpreters are that it has command line prompt and uses just-in-time (JIT) compiler for compilation. An interactive prompt is usually referred to as a read eval print loop or repl. Many of the developers (e.g. Mono in their project called CSharpRepl) of such kind of software applications name them interactive compilers.; . One of Cling's main goals is to provide contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward t",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3907,Security,access,accessed,3907,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:4024,Security,access,accessible,4024,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:70,Availability,Down,Download,70,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:139,Availability,Error,Error,139,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:145,Availability,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:53,Integrability,Interface,Interface,53,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:453,Integrability,interface,interface,453,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:740,Integrability,interface,interface,740,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:145,Safety,Recover,Recovery,145,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:569,Usability,learn,learn,569,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,interpreter/cling/www/old/news.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html:86,Availability,Down,Download,86,". Cling Documentation - Doxygen. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Doxygen. Doxygen is a software documentation generator system for multiple programming languages. It can generate documentation in different formats (such as HTML, Latex, RTF, PostScript). The documentation tool is useful for the developers, because the documentation is inlined in the source code, which makes it easy to keep in sync with the new revisions of the project. It walks up the source files and even there is no documentation provided it can generate description in terms of UML diagrams - particularly useful when dealing with large codebases.; . Cling has online doxygen documentation that could be found here. If you want to be able to browse offline the doxygen documentation you can build your own with:; cd CLING_BUILD_DIR/docs/; make regendoc. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/doxygen.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html:155,Availability,Error,Error,155,". Cling Documentation - Doxygen. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Doxygen. Doxygen is a software documentation generator system for multiple programming languages. It can generate documentation in different formats (such as HTML, Latex, RTF, PostScript). The documentation tool is useful for the developers, because the documentation is inlined in the source code, which makes it easy to keep in sync with the new revisions of the project. It walks up the source files and even there is no documentation provided it can generate description in terms of UML diagrams - particularly useful when dealing with large codebases.; . Cling has online doxygen documentation that could be found here. If you want to be able to browse offline the doxygen documentation you can build your own with:; cd CLING_BUILD_DIR/docs/; make regendoc. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/doxygen.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html:161,Availability,Recover,Recovery,161,". Cling Documentation - Doxygen. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Doxygen. Doxygen is a software documentation generator system for multiple programming languages. It can generate documentation in different formats (such as HTML, Latex, RTF, PostScript). The documentation tool is useful for the developers, because the documentation is inlined in the source code, which makes it easy to keep in sync with the new revisions of the project. It walks up the source files and even there is no documentation provided it can generate description in terms of UML diagrams - particularly useful when dealing with large codebases.; . Cling has online doxygen documentation that could be found here. If you want to be able to browse offline the doxygen documentation you can build your own with:; cd CLING_BUILD_DIR/docs/; make regendoc. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/doxygen.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html:69,Integrability,Interface,Interface,69,". Cling Documentation - Doxygen. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Doxygen. Doxygen is a software documentation generator system for multiple programming languages. It can generate documentation in different formats (such as HTML, Latex, RTF, PostScript). The documentation tool is useful for the developers, because the documentation is inlined in the source code, which makes it easy to keep in sync with the new revisions of the project. It walks up the source files and even there is no documentation provided it can generate description in terms of UML diagrams - particularly useful when dealing with large codebases.; . Cling has online doxygen documentation that could be found here. If you want to be able to browse offline the doxygen documentation you can build your own with:; cd CLING_BUILD_DIR/docs/; make regendoc. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/doxygen.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html:161,Safety,Recover,Recovery,161,". Cling Documentation - Doxygen. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Doxygen. Doxygen is a software documentation generator system for multiple programming languages. It can generate documentation in different formats (such as HTML, Latex, RTF, PostScript). The documentation tool is useful for the developers, because the documentation is inlined in the source code, which makes it easy to keep in sync with the new revisions of the project. It walks up the source files and even there is no documentation provided it can generate description in terms of UML diagrams - particularly useful when dealing with large codebases.; . Cling has online doxygen documentation that could be found here. If you want to be able to browse offline the doxygen documentation you can build your own with:; cd CLING_BUILD_DIR/docs/; make regendoc. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/doxygen.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/doxygen.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:89,Availability,Down,Download,89,". Cling Documentation - Extensions. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Desi",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:158,Availability,Error,Error,158,". Cling Documentation - Extensions. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Desi",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:164,Availability,Recover,Recovery,164,". Cling Documentation - Extensions. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Desi",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:72,Integrability,Interface,Interface,72,". Cling Documentation - Extensions. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Desi",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:164,Safety,Recover,Recovery,164,". Cling Documentation - Extensions. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Desi",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html:1633,Usability,simpl,simple,1633,"erface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjC[++] Support. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Extensions. Cling has several additional features. The main reason for their implementation is to improve the interactivity of the prompt. We call them language extensions.; ; For instance, language extensions are:; Execution of statements and expressions on the fly - From user's point of view it would make much sense if functions could be called by typing the function name at the prompt. This is true for other handy operations like creation of objects. However, the operations that do it are classified as statements and expressions, entered on the global scope. Statements and expressions on the global scope are not allowed by the C/C++/ObjC/ObjC++ grammar. Cling's prompt allows entering statements and expression on the global scope as transforming them into proper language constructs. ; Easy print out of the execution results - The way of signaling that the user wants to see the result of the entered and executed code is done by omitting the semicolon in the end. The standard doesn't allow statements (except those that change the control flow - such as if, for, while) without semicolon (;) in the end. However, this appears to be really simple and useful language extension that improves the user-cling interplay. Imagine if you had to write printf every time that you want to see the result of a function call. . See Also:; ; Statements and expression on the global scope in details; Easy printing of execution results in details. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev: 41615 $ by $Author: vvassilev $. ",MatchSource.DOCS,interpreter/cling/www/docs/internal/extensions.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/docs/internal/extensions.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:2250,Availability,error,error-prone,2250,")))))). Traverse Mode. The default mode of operation of AST Matchers visits all nodes in the AST,; even if they are not spelled in the source. This is; AsIs mode. This mode requires writing AST matchers; that explicitly traverse or ignore implicit nodes, such as parentheses; surrounding an expression or expressions with cleanups. These implicit; nodes are not always obvious from the syntax of the source code, and so this; mode requires careful consideration and testing to get the desired behavior; from an AST matcher. In addition, because template instantiations are matched in the default mode,; transformations can be accidentally made to template declarations. Finally,; because implicit nodes are matched by default, transformations can be made on; entirely incorrect places in the code.; For these reasons, it is possible to ignore AST nodes which are not spelled; in the source using the IgnoreUnlessSpelledInSource; mode. This is likely to be far less error-prone for users who are not already; very familiar with where implicit nodes appear in the AST. It is also likely; to be less error-prone for experienced AST users, as difficult cases do not; need to be encountered and matcher expressions adjusted for these cases.; In clang-query, the mode can be changed with. set traversal IgnoreUnlessSpelledInSource. This affects both matchers and AST dump output in results. When using the C++ API such as in clang-tidy checks, the; traverse() matcher is used to set the mode:. Finder->addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,; returnStmt(hasReturnValue(integerLiteral(equals(0)))); ), this);. The following table compares the AsIs mode with; the IgnoreUnlessSpelledInSource mode:. AsIs; IgnoreUnlessSpelledInSource. AST dump of func1:. struct B {; B(int);; };. B func1() { return 42; }. C++98 dialect:. FunctionDecl; `-CompoundStmt; `-ReturnStmt; `-ExprWithCleanups; `-CXXConstructExpr; `-MaterializeTemporaryExpr; `-ImplicitCastExpr; `-ImplicitCastExpr; `-CXXConstructExpr; `-I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:2382,Availability,error,error-prone,2382,"; AsIs mode. This mode requires writing AST matchers; that explicitly traverse or ignore implicit nodes, such as parentheses; surrounding an expression or expressions with cleanups. These implicit; nodes are not always obvious from the syntax of the source code, and so this; mode requires careful consideration and testing to get the desired behavior; from an AST matcher. In addition, because template instantiations are matched in the default mode,; transformations can be accidentally made to template declarations. Finally,; because implicit nodes are matched by default, transformations can be made on; entirely incorrect places in the code.; For these reasons, it is possible to ignore AST nodes which are not spelled; in the source using the IgnoreUnlessSpelledInSource; mode. This is likely to be far less error-prone for users who are not already; very familiar with where implicit nodes appear in the AST. It is also likely; to be less error-prone for experienced AST users, as difficult cases do not; need to be encountered and matcher expressions adjusted for these cases.; In clang-query, the mode can be changed with. set traversal IgnoreUnlessSpelledInSource. This affects both matchers and AST dump output in results. When using the C++ API such as in clang-tidy checks, the; traverse() matcher is used to set the mode:. Finder->addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,; returnStmt(hasReturnValue(integerLiteral(equals(0)))); ), this);. The following table compares the AsIs mode with; the IgnoreUnlessSpelledInSource mode:. AsIs; IgnoreUnlessSpelledInSource. AST dump of func1:. struct B {; B(int);; };. B func1() { return 42; }. C++98 dialect:. FunctionDecl; `-CompoundStmt; `-ReturnStmt; `-ExprWithCleanups; `-CXXConstructExpr; `-MaterializeTemporaryExpr; `-ImplicitCastExpr; `-ImplicitCastExpr; `-CXXConstructExpr; `-IntegerLiteral 'int' 42. C++11, C++14 dialect:. FunctionDecl; `-CompoundStmt; `-ReturnStmt; `-ExprWithCleanups; `-CXXConstructExpr; `-MaterializeTempora",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:8436,Availability,redundant,redundant,8436,"rdering operator<=>(const HasSpaceship&) const = default;; };. bool isLess(const HasSpaceship& a, const HasSpaceship& b) {; return a < b;; }. 1 match found. return a < b;; ^~~~~. No match found. Node Matchers. Node matchers are at the core of matcher expressions - they specify the type; of node that is expected. Every match expression starts with a node matcher,; which can then be further refined with a narrowing or traversal matcher. All; traversal matchers take node matchers as their arguments.; For convenience, all node matchers take an arbitrary number of arguments; and implicitly act as allOf matchers.; Node matchers are the only matchers that support the bind(""id"") call to; bind the matched node to the given string, to be later retrieved from the; match callback.; It is important to remember that the arguments to node matchers are; predicates on the same node, just with additional information about the type.; This is often useful to make matcher expression more readable by inlining bind; calls into redundant node matchers inside another node matcher:. // This binds the CXXRecordDecl to ""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53451,Availability,down,down,53451,"oid f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106560,Availability,error,error,106560,"; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<ObjCMessageExpr>hasAnySelectorStringRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47908,Energy Efficiency,Green,Green,47908,"pendentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType())));",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53622,Energy Efficiency,power,powerful,53622,"ypedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is eq",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15092,Integrability,interface,interface,15092,"<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCProp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15555,Integrability,interface,interface,15555,"eDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<Re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15601,Integrability,interface,interface,15601,"claration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and uni",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15962,Integrability,interface,interface,15962," not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16174,Integrability,interface,interface,16174,"ecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTempla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16299,Integrability,protocol,protocol,16299," @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16352,Integrability,protocol,protocol,16352,"bjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <template <typename> class Z, int N> struct C {};; te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:25809,Integrability,wrap,wrapper,25809,"acterLiteral>...; Matches character literals (also matches wchar_t). Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),; though. Example matches 'a', L'a'; char ch = 'a';; wchar_t chw = L'a';. Matcher<Stmt>chooseExprMatcher<ChooseExpr>...; Matches GNU __builtin_choose_expr. Matcher<Stmt>coawaitExprMatcher<CoawaitExpr>...; Matches co_await expressions. Given; co_await 1;; coawaitExpr(); matches 'co_await 1'. Matcher<Stmt>compoundLiteralExprMatcher<CompoundLiteralExpr>...; Matches compound (i.e. non-scalar) literals. Example match: {1}, (1, 2); int array[4] = {1};; vector int myvec = (vector int)(1, 2);. Matcher<Stmt>compoundStmtMatcher<CompoundStmt>...; Matches compound statements. Example matches '{}' and '{{}}' in 'for (;;) {{}}'; for (;;) {{}}. Matcher<Stmt>conditionalOperatorMatcher<ConditionalOperator>...; Matches conditional operator expressions. Example matches a ? b : c; (a ? b : c) + 42. Matcher<Stmt>constantExprMatcher<ConstantExpr>...; Matches a constant expression wrapper. Example matches the constant in the case statement:; (matcher = constantExpr()); switch (a) {; case 37: break;; }. Matcher<Stmt>continueStmtMatcher<ContinueStmt>...; Matches continue statements. Given; while (true) { continue; }; continueStmt(); matches 'continue'. Matcher<Stmt>convertVectorExprMatcher<ConvertVectorExpr>...; Matches builtin function __builtin_convertvector. Matcher<Stmt>coreturnStmtMatcher<CoreturnStmt>...; Matches co_return statements. Given; while (true) { co_return; }; coreturnStmt(); matches 'co_return'. Matcher<Stmt>coroutineBodyStmtMatcher<CoroutineBodyStmt>...; Matches coroutine body statements. coroutineBodyStmt() matches the coroutine below; generator<int> gen() {; co_return;; }. Matcher<Stmt>coyieldExprMatcher<CoyieldExpr>...; Matches co_yield expressions. Given; co_yield 1;; coyieldExpr(); matches 'co_yield 1'. Matcher<Stmt>cudaKernelCallExprMatcher<CUDAKernelCallExpr>...; Matches CUDA kernel call expression. Example matches,; kernel<<<i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:28534,Integrability,depend,dependent,28534,"_cast<int*>(&r) in; int n = 42;; const int &r(n);; int* p = const_cast<int*>(&r);. Matcher<Stmt>cxxConstructExprMatcher<CXXConstructExpr>...; Matches constructor call expressions (including implicit ones). Example matches string(ptr, n) and ptr within arguments of f; (matcher = cxxConstructExpr()); void f(const string &a, const string &b);; char *ptr;; int n;; f(string(ptr, n), ptr);. Matcher<Stmt>cxxDefaultArgExprMatcher<CXXDefaultArgExpr>...; Matches the value of a default argument at the call site. Example matches the CXXDefaultArgExpr placeholder inserted for the; default value of the second parameter in the call expression f(42); (matcher = cxxDefaultArgExpr()); void f(int x, int y = 0);; f(42);. Matcher<Stmt>cxxDeleteExprMatcher<CXXDeleteExpr>...; Matches delete expressions. Given; delete X;; cxxDeleteExpr(); matches 'delete X'. Matcher<Stmt>cxxDependentScopeMemberExprMatcher<CXXDependentScopeMemberExpr>...; Matches member expressions where the actual member referenced could not be; resolved because the base expression or the member name was dependent. Given; template <class T> void f() { T t; t.g(); }; cxxDependentScopeMemberExpr(); matches t.g. Matcher<Stmt>cxxDynamicCastExprMatcher<CXXDynamicCastExpr>...; Matches a dynamic_cast expression. Example:; cxxDynamicCastExpr(); matches; dynamic_cast<D*>(&b);; in; struct B { virtual ~B() {} }; struct D : B {};; B b;; D* p = dynamic_cast<D*>(&b);. Matcher<Stmt>cxxFoldExprMatcher<CXXFoldExpr>...; Matches C++17 fold expressions. Example matches `(0 + ... + args)`:; template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<Stmt>cxxForRangeStmtMatcher<CXXForRangeStmt>...; Matches range-based for statements. cxxForRangeStmt() matches 'for (auto a : i)'; int i[] = {1, 2, 3}; for (auto a : i);; for(int j = 0; j < 5; ++j);. Matcher<Stmt>cxxFunctionalCastExprMatcher<CXXFunctionalCastExpr>...; Matches functional cast expressions. Example: Matches Foo(bar);; Foo f = bar;; Foo g = (Foo) bar;; F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:33613,Integrability,depend,dependentCoawaitExprMatcher,33613,"rowExpr>...; Matches throw expressions. try { throw 5; } catch(int i) {}; cxxThrowExpr(); matches 'throw 5'. Matcher<Stmt>cxxTryStmtMatcher<CXXTryStmt>...; Matches try statements. try {} catch(int i) {}; cxxTryStmt(); matches 'try {}'. Matcher<Stmt>cxxUnresolvedConstructExprMatcher<CXXUnresolvedConstructExpr>...; Matches unresolved constructor call expressions. Example matches T(t) in return statement of f; (matcher = cxxUnresolvedConstructExpr()); template <typename T>; void f(const T& t) { return T(t); }. Matcher<Stmt>declRefExprMatcher<DeclRefExpr>...; Matches expressions that refer to declarations. Example matches x in if (x); bool x;; if (x) {}. Matcher<Stmt>declStmtMatcher<DeclStmt>...; Matches declaration statements. Given; int a;; declStmt(); matches 'int a'. Matcher<Stmt>defaultStmtMatcher<DefaultStmt>...; Matches default statements inside switch statements. Given; switch(a) { case 42: break; default: break; }; defaultStmt(); matches 'default:'. Matcher<Stmt>dependentCoawaitExprMatcher<DependentCoawaitExpr>...; Matches co_await expressions where the type of the promise is dependent. Matcher<Stmt>designatedInitExprMatcher<DesignatedInitExpr>...; Matches C99 designated initializer expressions [C99 6.7.8]. Example: Matches { [2].y = 1.0, [0].x = 1.0 }; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };. Matcher<Stmt>doStmtMatcher<DoStmt>...; Matches do statements. Given; do {} while (true);; doStmt(); matches 'do {} while(true)'. Matcher<Stmt>explicitCastExprMatcher<ExplicitCastExpr>...; Matches explicit cast expressions. Matches any cast expression written in user code, whether it be a; C-style cast, a functional-style cast, or a keyword cast. Does not match implicit conversions. Note: the name ""explicitCast"" is chosen to match Clang's terminology, as; Clang uses the term ""cast"" to apply to implicit conversions as well as to; actual cast expressions. See also: hasDestinationType. Example: matches all five of the casts in; int((int)(reinterpret_cast<int>(static",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:33641,Integrability,Depend,DependentCoawaitExpr,33641,"rowExpr>...; Matches throw expressions. try { throw 5; } catch(int i) {}; cxxThrowExpr(); matches 'throw 5'. Matcher<Stmt>cxxTryStmtMatcher<CXXTryStmt>...; Matches try statements. try {} catch(int i) {}; cxxTryStmt(); matches 'try {}'. Matcher<Stmt>cxxUnresolvedConstructExprMatcher<CXXUnresolvedConstructExpr>...; Matches unresolved constructor call expressions. Example matches T(t) in return statement of f; (matcher = cxxUnresolvedConstructExpr()); template <typename T>; void f(const T& t) { return T(t); }. Matcher<Stmt>declRefExprMatcher<DeclRefExpr>...; Matches expressions that refer to declarations. Example matches x in if (x); bool x;; if (x) {}. Matcher<Stmt>declStmtMatcher<DeclStmt>...; Matches declaration statements. Given; int a;; declStmt(); matches 'int a'. Matcher<Stmt>defaultStmtMatcher<DefaultStmt>...; Matches default statements inside switch statements. Given; switch(a) { case 42: break; default: break; }; defaultStmt(); matches 'default:'. Matcher<Stmt>dependentCoawaitExprMatcher<DependentCoawaitExpr>...; Matches co_await expressions where the type of the promise is dependent. Matcher<Stmt>designatedInitExprMatcher<DesignatedInitExpr>...; Matches C99 designated initializer expressions [C99 6.7.8]. Example: Matches { [2].y = 1.0, [0].x = 1.0 }; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };. Matcher<Stmt>doStmtMatcher<DoStmt>...; Matches do statements. Given; do {} while (true);; doStmt(); matches 'do {} while(true)'. Matcher<Stmt>explicitCastExprMatcher<ExplicitCastExpr>...; Matches explicit cast expressions. Matches any cast expression written in user code, whether it be a; C-style cast, a functional-style cast, or a keyword cast. Does not match implicit conversions. Note: the name ""explicitCast"" is chosen to match Clang's terminology, as; Clang uses the term ""cast"" to apply to implicit conversions as well as to; actual cast expressions. See also: hasDestinationType. Example: matches all five of the casts in; int((int)(reinterpret_cast<int>(static",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:33729,Integrability,depend,dependent,33729,"}; cxxThrowExpr(); matches 'throw 5'. Matcher<Stmt>cxxTryStmtMatcher<CXXTryStmt>...; Matches try statements. try {} catch(int i) {}; cxxTryStmt(); matches 'try {}'. Matcher<Stmt>cxxUnresolvedConstructExprMatcher<CXXUnresolvedConstructExpr>...; Matches unresolved constructor call expressions. Example matches T(t) in return statement of f; (matcher = cxxUnresolvedConstructExpr()); template <typename T>; void f(const T& t) { return T(t); }. Matcher<Stmt>declRefExprMatcher<DeclRefExpr>...; Matches expressions that refer to declarations. Example matches x in if (x); bool x;; if (x) {}. Matcher<Stmt>declStmtMatcher<DeclStmt>...; Matches declaration statements. Given; int a;; declStmt(); matches 'int a'. Matcher<Stmt>defaultStmtMatcher<DefaultStmt>...; Matches default statements inside switch statements. Given; switch(a) { case 42: break; default: break; }; defaultStmt(); matches 'default:'. Matcher<Stmt>dependentCoawaitExprMatcher<DependentCoawaitExpr>...; Matches co_await expressions where the type of the promise is dependent. Matcher<Stmt>designatedInitExprMatcher<DesignatedInitExpr>...; Matches C99 designated initializer expressions [C99 6.7.8]. Example: Matches { [2].y = 1.0, [0].x = 1.0 }; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };. Matcher<Stmt>doStmtMatcher<DoStmt>...; Matches do statements. Given; do {} while (true);; doStmt(); matches 'do {} while(true)'. Matcher<Stmt>explicitCastExprMatcher<ExplicitCastExpr>...; Matches explicit cast expressions. Matches any cast expression written in user code, whether it be a; C-style cast, a functional-style cast, or a keyword cast. Does not match implicit conversions. Note: the name ""explicitCast"" is chosen to match Clang's terminology, as; Clang uses the term ""cast"" to apply to implicit conversions as well as to; actual cast expressions. See also: hasDestinationType. Example: matches all five of the casts in; int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42))))); but does not match the implicit con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38412,Integrability,Message,Message,38412," these statements; T u(f());; g(f());; f().func();; but does not match; f();. Matcher<Stmt>memberExprMatcher<MemberExpr>...; Matches member expressions. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; int a; static int b;; };; memberExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38458,Integrability,message,message,38458," member expressions. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; int a; static int b;; };; memberExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel``,; ``omp parallel default(none)`` and ``omp taskyield``. Matcher<Stmt>opaqueValueExprMatcher<OpaqueValueExpr>...; Matches opaque va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38548,Integrability,message,message,38548," member expressions. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; int a; static int b;; };; memberExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel``,; ``omp parallel default(none)`` and ``omp taskyield``. Matcher<Stmt>opaqueValueExprMatcher<OpaqueValueExpr>...; Matches opaque va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38687,Integrability,message,message,38687,"erExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel``,; ``omp parallel default(none)`` and ``omp taskyield``. Matcher<Stmt>opaqueValueExprMatcher<OpaqueValueExpr>...; Matches opaque value expressions. They are used as helpers; to reference another expressions and can be met; in BinaryConditionalOperators, for ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:46913,Integrability,depend,dependentSizedArrayTypeMatcher,46913,";; int b[] = { 2, 3 };; int c[b[0]];; }; constantArrayType(); matches ""int a[2]"". Matcher<Type>decayedTypeMatcher<DecayedType>...; Matches decayed type; Example matches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:46944,Integrability,Depend,DependentSizedArrayType,46944,";; int b[] = { 2, 3 };; int c[b[0]];; }; constantArrayType(); matches ""int a[2]"". Matcher<Type>decayedTypeMatcher<DecayedType>...; Matches decayed type; Example matches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47014,Integrability,depend,dependent,47014," ""int a[2]"". Matcher<Type>decayedTypeMatcher<DecayedType>...; Matches decayed type; Example matches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47109,Integrability,depend,dependentSizedArrayType,47109,"tches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47173,Integrability,depend,dependentSizedExtVectorTypeMatcher,47173,"))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47208,Integrability,Depend,DependentSizedExtVectorType,47208,"))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47308,Integrability,depend,dependent,47308,"(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it doe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47434,Integrability,depend,dependentSizedExtVectorType,47434,"++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48729,Integrability,inject,injectedClassNameTypeMatcher,48729,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48758,Integrability,Inject,InjectedClassNameType,48758,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48793,Integrability,inject,injected,48793,"larations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,Integrability,inject,injectedClassNameType,48889,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:50036,Integrability,interface,interface,50036,"s. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C object pointer type, which is different from; a pointer type, despite being syntactically similar. Given; int *a;. @interface Foo; @end; Foo *f;; pointerType(); matches ""Foo *f"", but does not match ""int *a"". Matcher<Type>parenTypeMatcher<ParenType>...; Matches ParenType nodes. Given; int (*ptr_to_array)[4];; int *array_of_ptrs[4];. varDecl(hasType(pointsTo(parenType()))) matches ptr_to_array but not; array_of_ptrs. Matcher<Type>pointerTypeMatcher<PointerType>...; Matches pointer types, but does not match Objective-C object pointer; types. Given; int *a;; int &b = *a;; int c = 5;. @interface Foo; @end; Foo *f;; pointerType(); matches ""int *a"", but does not match ""Foo *f"". Matcher<Type>rValueReferenceTypeMatcher<RValueReferenceType>...; Matches rvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. rValueReferenceType() matches the types of c and f. e is not; matched as it is deduced to int& by reference collapsing rules. Matcher<Type>recordTypeMatcher<RecordType>...; Matches record types (e.g. structs, classes). Given; class C {};; struct S {};. C c;; S s;. recordType() match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:50508,Integrability,interface,interface,50508,"decl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C object pointer type, which is different from; a pointer type, despite being syntactically similar. Given; int *a;. @interface Foo; @end; Foo *f;; pointerType(); matches ""Foo *f"", but does not match ""int *a"". Matcher<Type>parenTypeMatcher<ParenType>...; Matches ParenType nodes. Given; int (*ptr_to_array)[4];; int *array_of_ptrs[4];. varDecl(hasType(pointsTo(parenType()))) matches ptr_to_array but not; array_of_ptrs. Matcher<Type>pointerTypeMatcher<PointerType>...; Matches pointer types, but does not match Objective-C object pointer; types. Given; int *a;; int &b = *a;; int c = 5;. @interface Foo; @end; Foo *f;; pointerType(); matches ""int *a"", but does not match ""Foo *f"". Matcher<Type>rValueReferenceTypeMatcher<RValueReferenceType>...; Matches rvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. rValueReferenceType() matches the types of c and f. e is not; matched as it is deduced to int& by reference collapsing rules. Matcher<Type>recordTypeMatcher<RecordType>...; Matches record types (e.g. structs, classes). Given; class C {};; struct S {};. C c;; S s;. recordType() matches the type of the variable declarations of both c; and s. Matcher<Type>referenceTypeMatcher<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:64623,Integrability,depend,dependent,64623,"explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:64685,Integrability,depend,dependent,64685," foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<CXXDependentScopeMemberExpr>memberHasSameNameAsBoundNodestd::string BindingID; Matches template-dependent",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:65710,Integrability,depend,dependent,65710,"dent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<CXXDependentScopeMemberExpr>memberHasSameNameAsBoundNodestd::string BindingID; Matches template-dependent, but known, member names against an already-bound; node. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the name of already-bound VarDecl, FieldDecl; and CXXMethodDecl nodes. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; The matcher; @code; cxxDependentScopeMemberExpr(; hasObjectExpression(declRefExpr(hasType(templateSpecializationType(; hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(; cxxMethodDecl(hasName(""mem"")).bind(""templMem""); ))))); )))),; memberHasSameNameAsBoundNode(""templMem""); ); @endcode; first matches and binds the @c mem member of the @c S template, then; compares its name to the usage in @c s.mem() in the @c x function template. Matcher<CXXFoldExpr>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:65803,Integrability,depend,dependent,65803,"s. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<CXXDependentScopeMemberExpr>memberHasSameNameAsBoundNodestd::string BindingID; Matches template-dependent, but known, member names against an already-bound; node. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the name of already-bound VarDecl, FieldDecl; and CXXMethodDecl nodes. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; The matcher; @code; cxxDependentScopeMemberExpr(; hasObjectExpression(declRefExpr(hasType(templateSpecializationType(; hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(; cxxMethodDecl(hasName(""mem"")).bind(""templMem""); ))))); )))),; memberHasSameNameAsBoundNode(""templMem""); ); @endcode; first matches and binds the @c mem member of the @c S template, then; compares its name to the usage in @c s.mem() in the @c x function template. Matcher<CXXFoldExpr>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxF",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86124,Integrability,depend,dependent,86124,"rived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86173,Integrability,depend,dependent,86173,"rived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86269,Integrability,depend,dependent,86269,") matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86355,Integrability,depend,dependent,86355,") matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86681,Integrability,depend,dependent,86681," = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86797,Integrability,depend,dependent,86797,"{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86851,Integrability,depend,dependent,86851,"{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:87024,Integrability,depend,dependent,87024,"; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;; };; fieldDecl(hasBitWidth(2)); matches 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:87162,Integrability,depend,dependent,87162,"dent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;; };; fieldDecl(hasBitWidth(2)); matches 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; class C {; int a : 2;; int b;; };; fieldDecl(isBitField()); matches 'int a;' but not 'int b;'. Matcher<Float",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91792,Integrability,interface,interface,91792,"onsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91835,Integrability,interface,interface,91835,"onsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106199,Integrability,message,message,106199,"uctor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<ObjCMessageExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<ObjCMessageExpr>hasAnySelectorStringRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106782,Integrability,message,message,106782,"gRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106826,Integrability,message,message,106826,"gRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107129,Integrability,message,message,107129,"bjCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTML",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107305,Integrability,message,message,107305,";; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107573,Integrability,message,message,107573,"present an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108024,Integrability,message,message,108024,"ssageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108068,Integrability,message,message,108068,"ssageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108900,Integrability,interface,interface,108900,"s; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument()));",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108941,Integrability,interface,interface,108941,"s; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument()));",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109284,Integrability,interface,interface,109284,"noreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109327,Integrability,interface,interface,109327,"noreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109678,Integrability,interface,interface,109678,"lf.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Matcher<ParmVarDecl>isAtPositionunsigned N; Matches the ParmVarDecl nodes that are at the N'th position in the parameter; list. The parameter list could be that of either a block, function, or; objc-method. Given. void f(int a, int b, int c) {; }. ``parmVarDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109719,Integrability,interface,interface,109719,"lf.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Matcher<ParmVarDecl>isAtPositionunsigned N; Matches the ParmVarDecl nodes that are at the N'th position in the parameter; list. The parameter list could be that of either a block, function, or; objc-method. Given. void f(int a, int b, int c) {; }. ``parmVarDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:112498,Integrability,interface,interface,112498,"qualsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<QualType>hasLocalQualifiers; Matches QualType nodes that have local CV-qualifiers attached to; the node, not hidden within a typedef. Given; typedef const int const_int;; const_int i;; int *const j;; int *volatile k;; int m;; varDecl(hasType(hasLocalQualifiers())) matches only j and k.; i is const-qualified but the qualifier is not local. Matcher<QualType>isAnyCharacter; Matches QualType nodes that are of character type. Given; void a(char);; void b(wchar_t);; void c(double);; functionDecl(hasAnyParameter(hasType(isAnyCharacter()))); matches ""a(char)"", ""b(wchar_t)"", but not ""c(double)"". Matcher<QualType>isAnyPointer; Matches QualType nodes that are of any pointer type; this includes; the Objective-C object pointer type, which is different despite being; syntactically similar. Given; int *i = nullptr;. @interface Foo; @end; Foo *f;. int j;; varDecl(hasType(isAnyPointer())); matches ""int *i"" and ""Foo *f"", but not ""int j"". Matcher<QualType>isConstQualified; Matches QualType nodes that are const-qualified, i.e., that; include ""top-level"" const. Given; void a(int);; void b(int const);; void c(const int);; void d(const int*);; void e(int const) {};; functionDecl(hasAnyParameter(hasType(isConstQualified()))); matches ""void b(int const)"", ""void c(const int)"" and; ""void e(int const) {}"". It does not match d as there; is no top-level const on the parameter type ""const int *"". Matcher<QualType>isInteger; Matches QualType nodes that are of integer type. Given; void a(int);; void b(long);; void c(double);; functionDecl(hasAnyParameter(hasType(isInteger()))); matches ""a(int)"", ""b(long)"", but not ""c(double)"". Matcher<QualType>isSignedInteger; Matches QualType nodes that are of signed integer type. Given; void a(int);; void b(unsigned long);; void c(double);; functionDecl(hasAnyParameter(hasType(isSignedInteger()",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:117903,Integrability,interface,interface,117903,"atches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the template argument's value is; an arbitrary precision integer. 'Value' must be euqal to the canonical; representation of that integral value in b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:117946,Integrability,interface,interface,117946,"atches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the template argument's value is; an arbitrary precision integer. 'Value' must be euqal to the canonical; representation of that integral value in b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126471,Integrability,interface,interface,126471,"cl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; ext",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126514,Integrability,interface,interface,126514,"cl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; ext",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:130183,Integrability,depend,depending,130183,"ss X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return typeNameParameters. Matcher<*>binaryOperationMatcher<*>...Matcher<*>; Matches nodes which can be used with binary operators. The code; var1 != var2;; might be represented in the clang AST as a binaryOperator, a; cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on. * whether the types of var1 and var2 are fundamental (binaryOperator) or at; least one is a class type (cxxOperatorCallExpr); * whether the code appears in a template declaration, if at least one of the; vars is a dependent-type (binaryOperator); * whether the code relies on a rewritten binary operator, such as a; spaceship operator or an inverted equality operator; (cxxRewrittenBinaryOperator). This matcher elides details in places where the matchers for the nodes are; compatible. Given; binaryOperation(; hasOperatorName(""!=""),; hasLHS(expr().bind(""lhs"")),; hasRHS(expr().bind(""rhs"")); ); matches each use of ""!="" in:; struct S{; bool operator!=(const S&) const;; };. void foo(); {; 1 != 2;; S() != S();; }. template<typename T>; void templ(); {; 1 != 2;; T() != S();; }; struct HasOpEq; {; bool operator==(const HasOpEq &) const;; };. void inverse(); {; HasOpEq s1;; HasOpEq s2;; if (s1 != s2); return;; }. struct ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:130411,Integrability,depend,dependent-type,130411,"X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return typeNameParameters. Matcher<*>binaryOperationMatcher<*>...Matcher<*>; Matches nodes which can be used with binary operators. The code; var1 != var2;; might be represented in the clang AST as a binaryOperator, a; cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on. * whether the types of var1 and var2 are fundamental (binaryOperator) or at; least one is a class type (cxxOperatorCallExpr); * whether the code appears in a template declaration, if at least one of the; vars is a dependent-type (binaryOperator); * whether the code relies on a rewritten binary operator, such as a; spaceship operator or an inverted equality operator; (cxxRewrittenBinaryOperator). This matcher elides details in places where the matchers for the nodes are; compatible. Given; binaryOperation(; hasOperatorName(""!=""),; hasLHS(expr().bind(""lhs"")),; hasRHS(expr().bind(""rhs"")); ); matches each use of ""!="" in:; struct S{; bool operator!=(const S&) const;; };. void foo(); {; 1 != 2;; S() != S();; }. template<typename T>; void templ(); {; 1 != 2;; T() != S();; }; struct HasOpEq; {; bool operator==(const HasOpEq &) const;; };. void inverse(); {; HasOpEq s1;; HasOpEq s2;; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132835,Integrability,inject,injected,132835,"Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Ma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138659,Integrability,Inject,InjectedClassNameType,138659,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:142522,Integrability,interface,interface,142522,"integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<BinaryOperator>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<BindingDecl>forDecompositionMatcher<ValueDecl> InnerMatcher; Matches the DecompositionDecl the binding belongs to. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; bindingDecl(hasName(""f""),; forDecomposition(decompositionDecl()); matches 'f' in 'auto &[f, s, t]'. Matcher<BlockDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<BlockDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:143200,Integrability,interface,interface,143200,"parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<BlockDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<Typede",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:148420,Integrability,message,message-send,148420,"gumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXConstructExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:148623,Integrability,interface,interface,148623,"eir respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXConstructExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150206,Integrability,Inject,InjectedClassNameType,150206,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163310,Integrability,Inject,InjectedClassNameType,163310,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:167770,Integrability,interface,interface,167770,"> InnerMatcher; Matches the first method of a class or struct that satisfies InnerMatcher. Given:; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<CXXRecordDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<CXXRecordDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<CXXRewrittenBinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:167796,Integrability,interface,interface,167796,"> InnerMatcher; Matches the first method of a class or struct that satisfies InnerMatcher. Given:; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<CXXRecordDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<CXXRecordDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<CXXRewrittenBinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170620,Integrability,message,message-send,170620,"r = binaryOperator(hasRHS())); a || b. Matcher<CXXTemporaryObjectExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170823,Integrability,interface,interface,170823,"hes int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:172274,Integrability,message,message,172274,"t y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CallExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<CallExpr>calleeMatcher<Stmt> InnerMatcher; Matches if the call or fold expression's callee expression matches. Given; class Y { void x() { this->x(); x(); Y y; y.x(); } };; void f() { f(); }; callExpr(callee(expr())); matches this->x(), x(), y.x(), f(); with callee(...); matching this->x, x, y.x, f respectively. Given; template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. template <typename... Args>; auto multiply(Args... args) {; return (args * ... * 1);; }; cxxFoldExpr(callee(expr())); matches (args * ... * 1); with callee(...); matching *. Note: Ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:172583,Integrability,interface,interface,172583,"(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CallExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<CallExpr>calleeMatcher<Stmt> InnerMatcher; Matches if the call or fold expression's callee expression matches. Given; class Y { void x() { this->x(); x(); Y y; y.x(); } };; void f() { f(); }; callExpr(callee(expr())); matches this->x(), x(), y.x(), f(); with callee(...); matching this->x, x, y.x, f respectively. Given; template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. template <typename... Args>; auto multiply(Args... args) {; return (args * ... * 1);; }; cxxFoldExpr(callee(expr())); matches (args * ... * 1); with callee(...); matching *. Note: Callee cannot take the more general internal::Matcher<Expr>; because this introduces ambiguous overloads with calls to Callee taking a; internal::Matcher<Decl>, as the matcher hierarchy is purely; implemented in terms of implicit casts. Matcher<CallExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:174735,Integrability,message,message-send,174735,"(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CallExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CallExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CallExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CallExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the ref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:174938,Integrability,interface,interface,174938,"s and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CallExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CallExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CallExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasTy",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176505,Integrability,Inject,InjectedClassNameType,176505,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184219,Integrability,Inject,InjectedClassNameType,184219,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191717,Integrability,Inject,InjectedClassNameType,191717,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:194861,Integrability,wrap,wrapped,194861," class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<Expr>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<Expr>ignoringElidableConstructorCallast_matchers::Matcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher that are possibly wrapped in an; elidable constructor and other corresponding bookkeeping nodes. In C++17, elidable copy constructors are no longer being generated in the; AST as it is not permitted by the standard. They are, however, part of the; AST in C++14 and earlier. So, a matcher must abstract over these differences; to work in all language modes. This matcher skips elidable constructor-call; AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and; various implicit nodes inside the constructor calls, all of which will not; appear in the C++17 AST. Given. struct H {};; H G();; void f() {; H D = G();; }. ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``; matches ``H D = G()`` in C++11 through C++17 (and beyond). Matcher<Expr>ignoringImpCastsMatcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher after any implicit casts; are stripped off. Parentheses and explicit casts are not discarded.; Given; int arr[5]",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:195282,Integrability,wrap,wrapping,195282,"ordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<Expr>ignoringElidableConstructorCallast_matchers::Matcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher that are possibly wrapped in an; elidable constructor and other corresponding bookkeeping nodes. In C++17, elidable copy constructors are no longer being generated in the; AST as it is not permitted by the standard. They are, however, part of the; AST in C++14 and earlier. So, a matcher must abstract over these differences; to work in all language modes. This matcher skips elidable constructor-call; AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and; various implicit nodes inside the constructor calls, all of which will not; appear in the C++17 AST. Given. struct H {};; H G();; void f() {; H D = G();; }. ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``; matches ``H D = G()`` in C++11 through C++17 (and beyond). Matcher<Expr>ignoringImpCastsMatcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher after any implicit casts; are stripped off. Parentheses and explicit casts are not discarded.; Given; int arr[5];; int a = 0;; char b = 0;; const int c = a;; int *d = arr;; long e = (long) 0l;; The matchers; varDecl(hasInitializer(ignoringImpCasts(integerLiteral()))); varDecl(hasInitializer(ignoringImpCasts(declRefExpr()))); would match the declarations for a, b, c, and d, but not e.; While; varDecl(hasInitializer(integerLiteral())); varDecl(hasInitializer(declRefExpr())); only match the declarations for a. Matcher<Expr>ignoringImplicitMatcher<Expr> InnerMatcher; Matches expressions that ma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:203026,Integrability,interface,interface,203026,"2' and 'R * 4'; functionDecl(forEachTemplateArgument(refersToType(builtinType()))); matches the specialization f<unsigned, bool> twice, for 'unsigned'; and 'bool'. Matcher<FunctionDecl>hasAnyBodyMatcher<Stmt> InnerMatcher; Matches a function declaration that has a given body present in the AST.; Note that this matcher matches all the declarations of a function whose; body is present in the AST. Given; void f();; void f() {}; void g();; functionDecl(hasAnyBody(compoundStmt())); matches both 'void f();'; and 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void g();'. Matcher<FunctionDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<FunctionDecl>hasAnyTemplateArgumentMatcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl that have at least one TemplateArgument matching the given; InnerMatcher. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;. template<typename T> f() {};; void func() { f<int>(); };. classTemplateSpecializationDecl(hasAnyTemplateArgument(; refersToType(asString(""int"")))); matches the specialization A<int>. functionDecl(hasAnyTemplateArgument(refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<FunctionDecl>hasBodyMatcher<Stmt> InnerMatche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:205629,Integrability,interface,interface,205629,"rMatcher; Matches the expression in an explicit specifier if present in the given; declaration. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.; cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.; cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6. Matcher<FunctionDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<FunctionDecl>hasReturnTypeLocMatcher<TypeLoc> ReturnMatcher; Matches a function declared with the specified return `TypeLoc`. Given; int f() { return 5; }; void g() {}; functionDecl(hasReturnTypeLoc(loc(asString(""int"")))); matches the declaration of `f`, but not `g`. Matcher<FunctionDecl>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToTyp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:208995,Integrability,Inject,InjectedClassNameType,208995,"(hasInitStatement(anything())); matches the switch statement in foo but not in bar.; cxxForRangeStmt(hasInitStatement(anything())); matches the range for statement in foo but not in bar. Matcher<IfStmt>hasThenMatcher<Stmt> InnerMatcher; Matches the then-statement of an if statement. Examples matches the if statement; (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true))))); if (false) true; else false;. Matcher<ImplicitCastExpr>hasImplicitDestinationTypeMatcher<QualType> InnerMatcher; Matches implicit casts whose destination type matches a given; matcher. Matcher<InitListExpr>hasInitunsigned N, ast_matchers::Matcher<Expr> InnerMatcher; Matches the n'th item of an initializer list expression. Example matches y.; (matcher = initListExpr(hasInit(0, expr()))); int x{y}. Matcher<InitListExpr>hasSyntacticFormMatcher<Expr> InnerMatcher; Matches the syntactic form of init list expressions; (if expression have it). Matcher<InjectedClassNameType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210160,Integrability,Inject,InjectedClassNameType,210160,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211568,Integrability,Inject,InjectedClassNameType,211568,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214167,Integrability,Inject,InjectedClassNameType,214167,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:219225,Integrability,interface,interface,219225,"uisite: the executable directive must not be standalone directive.; If it is, it will never match. Given. #pragma omp parallel; ;; #pragma omp parallel; {}. ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``. Matcher<ObjCInterfaceDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's cal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:219251,Integrability,interface,interface,219251,"uisite: the executable directive must not be standalone directive.; If it is, it will never match. Given. #pragma omp parallel; ;; #pragma omp parallel; {}. ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``. Matcher<ObjCInterfaceDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's cal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220280,Integrability,message,message,220280,"SObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220589,Integrability,interface,interface,220589,"X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220799,Integrability,message,message-send,220799,"def A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221002,Integrability,interface,interface,221002,"(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221506,Integrability,message,message,221506,"ample 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221867,Integrability,Message,Message,221867,"on. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221992,Integrability,message,message,221992," @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:222544,Integrability,interface,interface,222544,"er matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:223227,Integrability,interface,interface,223227,"eter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227551,Integrability,Inject,InjectedClassNameType,227551,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230434,Integrability,Inject,InjectedClassNameType,230434,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236306,Integrability,Inject,InjectedClassNameType,236306,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242851,Integrability,Inject,InjectedClassNameType,242851,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244907,Integrability,Inject,InjectedClassNameType,244907,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247886,Integrability,Inject,InjectedClassNameType,247886,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250658,Integrability,Inject,InjectedClassNameType,250658,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:12387,Modifiability,variab,variable,12387,"es the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-declarations. Examples matches the declaration node with foo and bar, but not; number.; (matcher = declStmt(has(decompositionDecl()))). int number = 42;; auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>enumConstantDeclMatcher<EnumConstantDecl>...; Matches enum constants. Example matches A, B, C; enum X {; A, B, C; };. Matcher<Decl>enumDeclMatcher<EnumDecl>...; Matches enum declarations. Example matches X; enum X {; A, B, C; };. Matcher<Decl>fieldDeclMatcher<FieldDecl>...; Matches field declarations. Given; class X { int m; };; fieldDecl(); matches 'm'. Matcher<Decl>friendDeclMatcher<FriendDecl>...; Matches friend declarations. Given; class X { friend void foo(); };; friendDecl(); matches 'friend void foo()'. Matcher<Decl>functionDeclMatcher<FunctionDecl>...; Matches function declara",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15702,Modifiability,variab,variable,15702,"ace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16447,Modifiability,variab,variable,16447,"implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <template <typename> class Z, int N> struct C {};; templateTypeParmDecl(); matches 'Z', but not 'N'. Matcher<Decl>templateTypeParmDeclMatcher<TemplateT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:19930,Modifiability,variab,variable,19930," matches using Base<T>::Foo ; Matcher<Decl>unresolvedUsingValueDeclMatcher<UnresolvedUsingValueDecl>...; Matches unresolved using value declarations. Given; template<typename X>; class C : private X {; using X::x;; };; unresolvedUsingValueDecl(); matches using X::x ; Matcher<Decl>usingDeclMatcher<UsingDecl>...; Matches using declarations. Given; namespace X { int x; }; using X::x;; usingDecl(); matches using X::x ; Matcher<Decl>usingDirectiveDeclMatcher<UsingDirectiveDecl>...; Matches using namespace declarations. Given; namespace X { int x; }; using namespace X;; usingDirectiveDecl(); matches using namespace X ; Matcher<Decl>usingEnumDeclMatcher<UsingEnumDecl>...; Matches using-enum declarations. Given; namespace X { enum x {...}; }; using enum X::x;; usingEnumDecl(); matches using enum X::x ; Matcher<Decl>valueDeclMatcher<ValueDecl>...; Matches any value declaration. Example matches A, B, C and F; enum X { A, B, C };; void F();. Matcher<Decl>varDeclMatcher<VarDecl>...; Matches variable declarations. Note: this does not match declarations of member variables, which are; ""field"" declarations in Clang parlance. Example matches a; int a;. Matcher<LambdaCapture>lambdaCaptureMatcher<LambdaCapture>...; Matches lambda captures. Given; int main() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,; `lambdaCapture()` matches `x` and `x=1`. Matcher<NestedNameSpecifierLoc>nestedNameSpecifierLocMatcher<NestedNameSpecifierLoc>...; Same as nestedNameSpecifier but matches NestedNameSpecifierLoc. Matcher<NestedNameSpecifier>nestedNameSpecifierMatcher<NestedNameSpecifier>...; Matches nested name specifiers. Given; namespace ns {; struct A { static void f(); };; void A::f() {}; void g() { A::f(); }; }; ns::A a;; nestedNameSpecifier(); matches ""ns::"" and both ""A::"". Matcher<OMPClause>ompDefaultClauseMatcher<OMPDefaultClause>...; Matches OpenMP ``default`` clause. Given. #pragma omp parallel default(none); #pragma omp pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:20002,Modifiability,variab,variables,20002,"her<UnresolvedUsingValueDecl>...; Matches unresolved using value declarations. Given; template<typename X>; class C : private X {; using X::x;; };; unresolvedUsingValueDecl(); matches using X::x ; Matcher<Decl>usingDeclMatcher<UsingDecl>...; Matches using declarations. Given; namespace X { int x; }; using X::x;; usingDecl(); matches using X::x ; Matcher<Decl>usingDirectiveDeclMatcher<UsingDirectiveDecl>...; Matches using namespace declarations. Given; namespace X { int x; }; using namespace X;; usingDirectiveDecl(); matches using namespace X ; Matcher<Decl>usingEnumDeclMatcher<UsingEnumDecl>...; Matches using-enum declarations. Given; namespace X { enum x {...}; }; using enum X::x;; usingEnumDecl(); matches using enum X::x ; Matcher<Decl>valueDeclMatcher<ValueDecl>...; Matches any value declaration. Example matches A, B, C and F; enum X { A, B, C };; void F();. Matcher<Decl>varDeclMatcher<VarDecl>...; Matches variable declarations. Note: this does not match declarations of member variables, which are; ""field"" declarations in Clang parlance. Example matches a; int a;. Matcher<LambdaCapture>lambdaCaptureMatcher<LambdaCapture>...; Matches lambda captures. Given; int main() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,; `lambdaCapture()` matches `x` and `x=1`. Matcher<NestedNameSpecifierLoc>nestedNameSpecifierLocMatcher<NestedNameSpecifierLoc>...; Same as nestedNameSpecifier but matches NestedNameSpecifierLoc. Matcher<NestedNameSpecifier>nestedNameSpecifierMatcher<NestedNameSpecifier>...; Matches nested name specifiers. Given; namespace ns {; struct A { static void f(); };; void A::f() {}; void g() { A::f(); }; }; ns::A a;; nestedNameSpecifier(); matches ""ns::"" and both ""A::"". Matcher<OMPClause>ompDefaultClauseMatcher<OMPDefaultClause>...; Matches OpenMP ``default`` clause. Given. #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:43858,Modifiability,variab,variable,43858,"er<UserDefinedLiteral>...; Matches user defined literal operator call. Example match: ""foo""_suffix. Matcher<Stmt>whileStmtMatcher<WhileStmt>...; Matches while statements. Given; while (true) {}; whileStmt(); matches 'while (true) {}'. Matcher<TemplateArgumentLoc>templateArgumentLocMatcher<TemplateArgumentLoc>...; Matches template arguments (with location info). Given; template <typename T> struct C {};; C<int> c;; templateArgumentLoc(); matches 'int' in C<int>. Matcher<TemplateArgument>templateArgumentMatcher<TemplateArgument>...; Matches template arguments. Given; template <typename T> struct C {};; C<int> c;; templateArgument(); matches 'int' in C<int>. Matcher<TemplateName>templateNameMatcher<TemplateName>...; Matches template name. Given; template <typename T> class X { };; X<int> xi;; templateName(); matches 'X' in X<int>. Matcher<TypeLoc>elaboratedTypeLocMatcher<ElaboratedTypeLoc>...; Matches C or C++ elaborated `TypeLoc`s. Given; struct s {};; struct s ss;; elaboratedTypeLoc(); matches the `TypeLoc` of the variable declaration of `ss`. Matcher<TypeLoc>pointerTypeLocMatcher<PointerTypeLoc>...; Matches pointer `TypeLoc`s. Given; int* x;; pointerTypeLoc(); matches `int*`. Matcher<TypeLoc>qualifiedTypeLocMatcher<QualifiedTypeLoc>...; Matches `QualifiedTypeLoc`s in the clang AST. Given; const int x = 0;; qualifiedTypeLoc(); matches `const int`. Matcher<TypeLoc>referenceTypeLocMatcher<ReferenceTypeLoc>...; Matches reference `TypeLoc`s. Given; int x = 3;; int& l = x;; int&& r = 3;; referenceTypeLoc(); matches `int&` and `int&&`. Matcher<TypeLoc>templateSpecializationTypeLocMatcher<TemplateSpecializationTypeLoc>...; Matches template specialization `TypeLoc`s. Given; template <typename T> class C {};; C<char> var;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(typeLoc()))); matches `C<char> var`. Matcher<TypeLoc>typeLocMatcher<TypeLoc>...; Matches TypeLocs in the clang AST. Matcher<Type>arrayTypeMatcher<ArrayType>...; Matches all kinds of arrays. Given; int a[] = { ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:46888,Modifiability,variab,variable,46888,"rayType>...; Matches C arrays with a specified constant size. Given; void() {; int a[2];; int b[] = { 2, 3 };; int c[b[0]];; }; constantArrayType(); matches ""int a[2]"". Matcher<Type>decayedTypeMatcher<DecayedType>...; Matches decayed type; Example matches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTy",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47253,Modifiability,extend,extended,47253,"(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it doe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47789,Modifiability,variab,variable,47789,"C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Mat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47988,Modifiability,variab,variable,47988,"ys whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:51100,Modifiability,variab,variable,51100,"ut does not match ""int *a"". Matcher<Type>parenTypeMatcher<ParenType>...; Matches ParenType nodes. Given; int (*ptr_to_array)[4];; int *array_of_ptrs[4];. varDecl(hasType(pointsTo(parenType()))) matches ptr_to_array but not; array_of_ptrs. Matcher<Type>pointerTypeMatcher<PointerType>...; Matches pointer types, but does not match Objective-C object pointer; types. Given; int *a;; int &b = *a;; int c = 5;. @interface Foo; @end; Foo *f;; pointerType(); matches ""int *a"", but does not match ""Foo *f"". Matcher<Type>rValueReferenceTypeMatcher<RValueReferenceType>...; Matches rvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. rValueReferenceType() matches the types of c and f. e is not; matched as it is deduced to int& by reference collapsing rules. Matcher<Type>recordTypeMatcher<RecordType>...; Matches record types (e.g. structs, classes). Given; class C {};; struct S {};. C c;; S s;. recordType() matches the type of the variable declarations of both c; and s. Matcher<Type>referenceTypeMatcher<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template type parameter. Given; template <typename T>; void F(T t) {; int i = 1 + t;; }. substTemplateTypeParmType() matches the type of 't' but not '1'. Matcher<Type>tagTypeMatcher<TagType>...; Matches tag types (record and enum types). Given; enum E {};; class C {};. E e;; C c;. tagType() matches the type of the variable declarations of both e; and c. Matcher<Type>templateSpecializationTypeMatcher<TemplateSpecializationType>...; Matches template specialization types. Given; template <typename T>; class C { };. template class C<int>; // A; C<char> va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:51860,Modifiability,variab,variable,51860,"tched as it is deduced to int& by reference collapsing rules. Matcher<Type>recordTypeMatcher<RecordType>...; Matches record types (e.g. structs, classes). Given; class C {};; struct S {};. C c;; S s;. recordType() matches the type of the variable declarations of both c; and s. Matcher<Type>referenceTypeMatcher<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template type parameter. Given; template <typename T>; void F(T t) {; int i = 1 + t;; }. substTemplateTypeParmType() matches the type of 't' but not '1'. Matcher<Type>tagTypeMatcher<TagType>...; Matches tag types (record and enum types). Given; enum E {};; class C {};. E e;; C c;. tagType() matches the type of the variable declarations of both e; and c. Matcher<Type>templateSpecializationTypeMatcher<TemplateSpecializationType>...; Matches template specialization types. Given; template <typename T>; class C { };. template class C<int>; // A; C<char> var; // B. templateSpecializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underly",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:52212,Modifiability,variab,variable,52212,"<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template type parameter. Given; template <typename T>; void F(T t) {; int i = 1 + t;; }. substTemplateTypeParmType() matches the type of 't' but not '1'. Matcher<Type>tagTypeMatcher<TagType>...; Matches tag types (record and enum types). Given; enum E {};; class C {};. E e;; C c;. tagType() matches the type of the variable declarations of both e; and c. Matcher<Type>templateSpecializationTypeMatcher<TemplateSpecializationType>...; Matches template specialization types. Given; template <typename T>; class C { };. template class C<int>; // A; C<char> var; // B. templateSpecializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays wit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53066,Modifiability,variab,variable,53066,". template class C<int>; // A; C<char> var; // B. templateSpecializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53106,Modifiability,variab,variableArrayTypeMatcher,53106,"cializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as Ty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53131,Modifiability,Variab,VariableArrayType,53131,"cializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as Ty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53306,Modifiability,variab,variableArrayType,53306,"armType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:56674,Modifiability,inherit,inheritance,56674,"atches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<BinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<BinaryOperator>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57039,Modifiability,inherit,inheritance,57039,"her = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<BinaryOperator>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57351,Modifiability,inherit,inheritance,57351,"es a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57714,Modifiability,inherit,inheritance,57714,"ecify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:70041,Modifiability,inherit,inheritance,70041,"nd C::f, but not B, C, or B::f. Matcher<CXXMethodDecl>isMoveAssignmentOperator; Matches if the given method declaration declares a move assignment; operator. Given; struct A {; A &operator=(const A &);; A &operator=(A &&);; };. cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not; the first one. Matcher<CXXMethodDecl>isOverride; Matches if the given method declaration overrides another method. Given; class A {; public:; virtual void x();; };; class B : public A {; public:; virtual void x();; };; matches B::x. Matcher<CXXMethodDecl>isPure; Matches if the given method declaration is pure. Given; class A {; public:; virtual void x() = 0;; };; matches A::x. Matcher<CXXMethodDecl>isUserProvided; Matches method declarations that are user-provided. Given; struct S {; S(); // #1; S(const S &) = default; // #2; S(S &&) = delete; // #3; };; cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3. Matcher<CXXMethodDecl>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXMethodDecl>isVirtualAsWritten; Matches if the given method declaration has an explicit ""virtual"". Given; class A {; public:; virtual void x();; };; class B : public A {; public:; void x();; };; matches A::x but not B::x. Matcher<CXXNewExpr>isArray; Matches array new expressions. Given:; MyClass *p1 = new MyClass[10];; cxxNewExpr(isArray()); matches the expression 'new MyClass[10]'. Matcher<CXXOperatorCallExpr>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")).",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:73563,Modifiability,variab,variable,73563,"s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<CXXOperatorCallExpr>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXRecordDecl>hasDefinition; Matches a class declaration that is defined. Example matches x (matcher = cxxRecordDecl(hasDefinition())); class x {};; class y;. Matcher<CXXRecordDecl>isDerivedFromstd::string BaseName; Overloaded method as shortcut for isDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isDirectlyDerivedFromstd::string BaseName; Overloaded method as shortcut for isDirectlyDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRecordDecl>isFinal; Matches if the given method or class declaration is final. Given:; class A final {};. struct B {; virtual void f();; };. struct C : B {; void f() final;; };; matches A and C::f, but not B, C, or B::f. Matcher<CXXRecordDecl>isLambda; Matches the generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member varia",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:74506,Modifiability,variab,variable,74506,"lateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRecordDecl>isFinal; Matches if the given method or class declaration is final. Given:; class A final {};. struct B {; virtual void f();; };. struct C : B {; void f() final;; };; matches A and C::f, but not B, C, or B::f. Matcher<CXXRecordDecl>isLambda; Matches the generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRewrittenBinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXRewrittenBinaryOperator>hasOperatorNamest",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:81294,Modifiability,variab,variable,81294,"e(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<DeclStmt>declCountIsunsigned N; Matches declaration statements that contain a specific number of; declarations. Example: Given; int a, b;; int c;; int d = 2, e;; declCountIs(2); matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'. Matcher<Decl>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Decl>equalsNodeconst Decl* Other; Matches if a node equals another node. Decl has pointer identity in the AST. Matcher<Decl>hasAttrattr::Kind AttrKind; Matches declaration that has a given attribute. Given; __attribute__((device)) void f() { ... }; decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of; f. If the matcher is used from clang-query, attr::Kind parameter should be; passed as a quoted string. e.g., hasAttr(""attr::CUDADevice""). Matcher<Decl>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:81338,Modifiability,variab,variable,81338,"e(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<DeclStmt>declCountIsunsigned N; Matches declaration statements that contain a specific number of; declarations. Example: Given; int a, b;; int c;; int d = 2, e;; declCountIs(2); matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'. Matcher<Decl>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Decl>equalsNodeconst Decl* Other; Matches if a node equals another node. Decl has pointer identity in the AST. Matcher<Decl>hasAttrattr::Kind AttrKind; Matches declaration that has a given attribute. Given; __attribute__((device)) void f() { ... }; decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of; f. If the matcher is used from clang-query, attr::Kind parameter should be; passed as a quoted string. e.g., hasAttr(""attr::CUDADevice""). Matcher<Decl>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:84604,Modifiability,inherit,inheritance,84604,"ace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiations or are inside; template instantiations. Given; template<typename T> void A(T t) { T i; }; A(0);; A(0U);; functionDecl(isInstantiated()); matches 'A(int) {...};' and 'A(unsigned) {...}'. Matcher<Decl>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<Decl>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:84957,Modifiability,inherit,inheritance,84957,"`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiations or are inside; template instantiations. Given; template<typename T> void A(T t) { T i; }; A(0);; A(0U);; functionDecl(isInstantiated()); matches 'A(int) {...};' and 'A(unsigned) {...}'. Matcher<Decl>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<Decl>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:85257,Modifiability,inherit,inheritance,85257,"will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiations or are inside; template instantiations. Given; template<typename T> void A(T t) { T i; }; A(0);; A(0U);; functionDecl(isInstantiated()); matches 'A(int) {...};' and 'A(unsigned) {...}'. Matcher<Decl>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<Decl>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:90953,Modifiability,variab,variable,90953,"lass A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<FunctionDecl>hasTrailingReturn; Matches a function declared with a trailing return type. Example matches Y (matcher = functionDecl(hasTrailingReturn())); int X() {}; auto Y() -> int {}. Matcher<FunctionDecl>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91717,Modifiability,variab,variable,91717," ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:92343,Modifiability,variab,variable,92343,"onDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:92678,Modifiability,variab,variable,92678,"; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:93064,Modifiability,variab,variables,93064,"ven:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:94140,Modifiability,variab,variable,94140," g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:94447,Modifiability,variab,variable,94447,""", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isVariadic; Matches if a function declaration is variadic. Example matches f, but not g or h. The function i will not match, even when; compiled in C mode.; void f(...);; void g(int);; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:94587,Modifiability,variab,variable,94587,"s that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isVariadic; Matches if a function declaration is variadic. Example matches f, but not g or h. The function i will not match, even when; compiled in C mode.; void f(...);; void g(int);; template <typename... Ts> void h(Ts...);; void i();. Matcher<FunctionDecl>isWeak; Matches weak function declara",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:97733,Modifiability,variab,variable,97733,"cept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionProtoType>parameterCountIsunsigned N; Matches FunctionDecls and FunctionProtoTypes that have a; specific parameter count. Given; void f(int i) {}; void g(int i, int j) {}; void h(int i, int j);; void j(int i);; void k(int x, int y, int z, ...);; functionDecl(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(3)); matches k. Matcher<IfStmt>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<IfStmt>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<IntegerLiteral>equalsbool Value. Matcher<IntegerLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOpe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:102066,Modifiability,variab,variables,102066,":b::X"", ""b::X"", ""X""); namespace a { namespace b { class X; } }. Matcher<NamedDecl>matchesNameStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches NamedDecl nodes whose fully qualified names contain; a substring matched by the given RegExp. Supports specifying enclosing namespaces or classes by; prefixing the name with '<enclosing>::'. Does not match typedefs; of an underlying type with the given name. Example matches X (regexp == ""::X""); class X;. Example matches X (regexp is one of ""::X"", ""^foo::.*X"", among others); namespace foo { namespace bar { class X; } }. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<NamespaceDecl>isAnonymous; Matches anonymous namespace declarations. Given; namespace n {; namespace {} // #1; }; namespaceDecl(isAnonymous()) will match #1 but not ::n. Matcher<NamespaceDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<OMPDefaultClause>isFirstPrivateKind; Matches if the OpenMP ``default`` clause has ``firstprivate`` kind; specified. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma omp parallel default(firstprivate). ``ompDefaultClause(isFirstPrivateKind())`` matches only; ``default(firstprivate)``. Matcher<OMPDefaultClause>isNoneKind; Matches if the OpenMP ``default`` clause has ``none`` kind specified. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma omp parallel default(firstprivate). ``ompDefaultClause(isNon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109209,Modifiability,variab,variable,109209,"ed in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:111582,Modifiability,variab,variable,111582,"arDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>asStringstd::string Name; Matches if the matched type is represented by the given string. Given; class Y { public: void x(); };; void z() { Y* y; y->x(); }; cxxMemberCallExpr(on(hasType(asString(""class Y *"")))); matches y->x(). Matcher<QualType>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<QualType>hasLocalQualifiers; Matches QualType nodes that have local CV-qualifiers attached to; the node, not hidden within a typedef. Given; typedef const int const_int;; const_int i;; int *const j;; int *volatile k;; int m;; varDecl(hasType(hasLocalQualifiers())) matches only j and k.; i is const-qualified but the qualifier is not local. Matcher<QualType>isAnyCharacter; Matches QualType nodes that are of character type. Given; void a(char);; void b(wchar_t);; void c(double);; functionDecl(hasAnyParameter(hasType(isAnyCharacter()))); matches ""a(char)"", ""b(wchar_t)"", but not ""c(double)"". Matcher<QualType>isAnyPointer; Matches QualType nodes that are of any pointer type; this includes; the Objective-C object pointer type, which is different despite being; syntactically similar. Given; int *i = nullptr;. @interface Foo; @end; Foo *f;. int j;; varDecl(hasType(isAnyPointer())",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:111626,Modifiability,variab,variable,111626,"arDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>asStringstd::string Name; Matches if the matched type is represented by the given string. Given; class Y { public: void x(); };; void z() { Y* y; y->x(); }; cxxMemberCallExpr(on(hasType(asString(""class Y *"")))); matches y->x(). Matcher<QualType>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<QualType>hasLocalQualifiers; Matches QualType nodes that have local CV-qualifiers attached to; the node, not hidden within a typedef. Given; typedef const int const_int;; const_int i;; int *const j;; int *volatile k;; int m;; varDecl(hasType(hasLocalQualifiers())) matches only j and k.; i is const-qualified but the qualifier is not local. Matcher<QualType>isAnyCharacter; Matches QualType nodes that are of character type. Given; void a(char);; void b(wchar_t);; void c(double);; functionDecl(hasAnyParameter(hasType(isAnyCharacter()))); matches ""a(char)"", ""b(wchar_t)"", but not ""c(double)"". Matcher<QualType>isAnyPointer; Matches QualType nodes that are of any pointer type; this includes; the Objective-C object pointer type, which is different despite being; syntactically similar. Given; int *i = nullptr;. @interface Foo; @end; Foo *f;. int j;; varDecl(hasType(isAnyPointer())",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:115021,Modifiability,variab,variable,115021,"t);; void b(int volatile);; void c(volatile int);; void d(volatile int*);; void e(int volatile) {};; functionDecl(hasAnyParameter(hasType(isVolatileQualified()))); matches ""void b(int volatile)"", ""void c(volatile int)"" and; ""void e(int volatile) {}"". It does not match d as there; is no top-level volatile on the parameter type ""volatile int *"". Matcher<Stmt>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Stmt>equalsNodeconst Stmt* Other; Matches if a node equals another node. Stmt has pointer identity in the AST. Matcher<Stmt>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Stmt>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:115065,Modifiability,variab,variable,115065,"t);; void b(int volatile);; void c(volatile int);; void d(volatile int*);; void e(int volatile) {};; functionDecl(hasAnyParameter(hasType(isVolatileQualified()))); matches ""void b(int volatile)"", ""void c(volatile int)"" and; ""void e(int volatile) {}"". It does not match d as there; is no top-level volatile on the parameter type ""volatile int *"". Matcher<Stmt>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Stmt>equalsNodeconst Stmt* Other; Matches if a node equals another node. Stmt has pointer identity in the AST. Matcher<Stmt>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Stmt>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:117828,Modifiability,variab,variable,117828," instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the templa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:121981,Modifiability,variab,variable,121981,"atches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Type>equalsNodeconst Type* Other; Matches if a node equals another node. Type has pointer identity in the AST. Matcher<Type>realFloatingPointType; Matches any real floating-point type (float, double, long double). Given; int i;; float f;; realFloatingPointType(); matches ""float f"" but not ""int i"". Matcher<Type>voidType; Matches type void. Given; struct S { void func(); };; functionDecl(returns(voidType())); matches ""void func();"". Matcher<UnaryExprOrTypeTraitExpr>ofKindUnaryExprOrTypeTrait Kind; Matches unary expressions of a certain kind. Given; int x;; int s = sizeof(x) + alignof(x); unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf)); matches sizeof(x). If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter; should be passed as a quoted string. e.g., ofKind(""UETT_SizeOf""). Matcher<UnaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:122025,Modifiability,variab,variable,122025,"atches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Type>equalsNodeconst Type* Other; Matches if a node equals another node. Type has pointer identity in the AST. Matcher<Type>realFloatingPointType; Matches any real floating-point type (float, double, long double). Given; int i;; float f;; realFloatingPointType(); matches ""float f"" but not ""int i"". Matcher<Type>voidType; Matches type void. Given; struct S { void func(); };; functionDecl(returns(voidType())); matches ""void func();"". Matcher<UnaryExprOrTypeTraitExpr>ofKindUnaryExprOrTypeTrait Kind; Matches unary expressions of a certain kind. Given; int x;; int s = sizeof(x) + alignof(x); unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf)); matches sizeof(x). If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter; should be passed as a quoted string. e.g., ofKind(""UETT_SizeOf""). Matcher<UnaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124159,Modifiability,variab,variable,124159,"eratorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<UnresolvedMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStatic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124419,Modifiability,variab,variable,124419,"asOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<UnresolvedMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124627,Modifiability,variab,variable,124627,"er calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124699,Modifiability,variab,variable,124699,"er calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124864,Modifiability,variab,variable,124864,"; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124936,Modifiability,variab,variable,124936,"is->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const ch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:125280,Modifiability,variab,variable,125280,"utomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:125537,Modifiability,variab,variable,125537,"id f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:125908,Modifiability,variab,variable,125908,"tatic storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable());",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126396,Modifiability,variab,variable,126396,", or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isE",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126730,Modifiability,variab,variable,126730,"Constexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126772,Modifiability,variab,variable,126772,"Constexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127075,Modifiability,variab,variable,127075,"quire_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127405,Modifiability,variab,variable,127405,"efine the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127782,Modifiability,variab,variable,127782,"ch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127815,Modifiability,variab,variable,127815,"ch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127987,Modifiability,variab,variables,127987,"explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128337,Modifiability,variab,variable,128337,"tcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; templ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128519,Modifiability,variab,variable,128519,"= 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionD",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128826,Modifiability,variab,variable,128826," variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forE",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128961,Modifiability,variab,variable,128961,"3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:136640,Modifiability,variab,variable,136640,"nt(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is no data; member named ""bar"" in that class. Usable as: Any Matcher. Matcher<*>traverseTraversalKind TK, Matcher<*> InnerMatcher; Causes all nested matchers to be matched with the specified traversal kind. Given; void foo(); {; int i = 3.0;; }; The matcher; traverse(TK_IgnoreUnlessSpelledInSource,; varDecl(hasInitializer(floatLiteral().bind(""init""))); ); matches the variable declaration with ""init"" bound to the ""3.0"". Matcher<AbstractConditionalOperator>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<AbstractConditionalOperator>hasFalseExpressionMatcher<Expr> InnerMatcher; Matches the false branch expression of a conditional operator; (binary or ternary). Example matches b; condition ? a : b; condition ?: b. Matcher<AbstractConditionalOperator>hasTrueExpressionMatcher<Expr> InnerMatcher; Matches the true branch expression of a conditional operator. Example 1 (conditional ternary operator): matches a; condition ? a : b. Example 2 (conditional binary operator): matches opaqueValueExpr(condition); condition ?: b. Matcher<AddrLabelExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:145654,Modifiability,variab,variable,145654,"tches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXBaseSpecifier>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<CXXBaseSpecifier>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:160840,Modifiability,inherit,inheritance,160840,"ession's implicit object argument either; matches the InnerMatcher, or is a pointer to a type that matches the; InnerMatcher. Given; class Y { public: void m(); };; class X : public Y { void g(); };; void z() { Y y; y.m(); Y *p; p->m(); X x; x.m(); x.g(); }; cxxMemberCallExpr(thisPointerType(hasDeclaration(; cxxRecordDecl(hasName(""Y""))))); matches `y.m()`, `p->m()` and `x.m()`.; cxxMemberCallExpr(thisPointerType(hasDeclaration(; cxxRecordDecl(hasName(""X""))))); matches `x.g()`. Matcher<CXXMethodDecl>forEachOverriddenMatcher<CXXMethodDecl> InnerMatcher; Matches each method overridden by the given method. This matcher may; produce multiple matches. Given; class A { virtual void f(); };; class B : public A { void f(); };; class C : public B { void f(); };; cxxMethodDecl(ofClass(hasName(""C"")),; forEachOverridden(cxxMethodDecl().bind(""b""))).bind(""d""); matches once, with ""b"" binding ""A::f"" and ""d"" binding ""C::f"" (Note; that B::f is not overridden by C::f). The check can produce multiple matches in case of multiple inheritance, e.g.; class A1 { virtual void f(); };; class A2 { virtual void f(); };; class C : public A1, public A2 { void f(); };; cxxMethodDecl(ofClass(hasName(""C"")),; forEachOverridden(cxxMethodDecl().bind(""b""))).bind(""d""); matches twice, once with ""b"" binding ""A1::f"" and ""d"" binding ""C::f"", and; once with ""b"" binding ""A2::f"" and ""d"" binding ""C::f"". Matcher<CXXMethodDecl>ofClassMatcher<CXXRecordDecl> InnerMatcher; Matches the class declaration that the given method declaration; belongs to. FIXME: Generalize this for other kinds of declarations.; FIXME: What other kind of declarations would we need to generalize; this to?. Example matches A() in the last line; (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl(; ofClass(hasName(""A"")))))); class A {; public:; A();; };; A a = A();. Matcher<CXXNewExpr>hasAnyPlacementArgMatcher<Expr> InnerMatcher; Matches any placement new expression arguments. Given:; MyClass *p1 = new (Storage) MyClass();; cxxNewExpr(hasAnyP",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:166246,Modifiability,Refactor,Refactor,166246,"aryOperator(hasOperands(integerLiteral(equals(1),; integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<CXXOperatorCallExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<CXXOperatorCallExpr>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !true. Matcher<CXXRecordDecl>hasAnyBaseMatcher<CXXBaseSpecifier> BaseSpecMatcher; Matches C++ classes that have a direct or indirect base matching BaseSpecMatcher. Example:; matcher hasAnyBase(hasType(cxxRecordDecl(hasName(""SpecialBase"")))); class Foo;; class Bar : Foo {};; class Baz : Bar {};; class SpecialBase;; class Proxy : SpecialBase {}; // matches Proxy; class IndirectlyDerived : Proxy {}; //matches IndirectlyDerived. FIXME: Refactor this and isDerivedFrom to reuse implementation. Matcher<CXXRecordDecl>hasDirectBaseMatcher<CXXBaseSpecifier> BaseSpecMatcher; Matches C++ classes that have a direct base matching BaseSpecMatcher. Example:; matcher hasDirectBase(hasType(cxxRecordDecl(hasName(""SpecialBase"")))); class Foo;; class Bar : Foo {};; class Baz : Bar {};; class SpecialBase;; class Proxy : SpecialBase {}; // matches Proxy; class IndirectlyDerived : Proxy {}; // doesn't match. Matcher<CXXRecordDecl>hasMethodMatcher<CXXMethodDecl> InnerMatcher; Matches the first method of a class or struct that satisfies InnerMatcher. Given:; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:189805,Modifiability,variab,variable,189805," a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<DoStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ElaboratedTypeLoc>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the decla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:190202,Modifiability,variab,variable,190202," matching '{}'; but does not match 'void f();'. Matcher<DoStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ElaboratedTypeLoc>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; clas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:190529,Modifiability,variab,variable,190529,"c>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:193249,Modifiability,variab,variable,193249,"c> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Expr>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<Expr>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; mat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:199943,Modifiability,variab,variable,199943,"nctionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<ForStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ForStmt>hasIncrementMatcher<Stmt> InnerMatcher; Matches the increment statement of a for loop. Example:; forStmt(hasIncrement(unaryOperator(hasOperatorName(""++"")))); matches '++x' in; for (x; x < N; ++x) { }. Matcher<ForStmt>hasLoopInitMatcher<Stmt> InnerMatcher; Matches the initialization statement of a for loop. Example:; forStmt(hasLoopInit(declStmt())); matches 'int x = 0' in; for (int x = 0; x < N; ++x) { }. Matcher<FriendDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<FriendDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:207269,Modifiability,variab,variable,207269,"nDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<FunctionDecl>returnsMatcher<QualType> InnerMatcher; Matches the return type of a function declaration. Given:; class X { int f() { return 1; } };; cxxMethodDecl(returns(asString(""int""))); matches int f() { return 1; }. Matcher<IfStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<IfStmt>hasConditionVariableStatementMatcher<DeclStmt> InnerMatcher; Matches the condition variable statement in an if statement. Given; if (A* a = GetAPointer()) {}; hasConditionVariableStatement(...); matches 'A* a = GetAPointer()'. Matcher<IfStmt>hasElseMatcher<Stmt> InnerMatcher; Matches the else-statement of an if statement. Examples matches the if statement; (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true))))); if (false) false; else true;. Matcher<IfStmt>hasInitStatementMatcher<Stmt> InnerMatcher; Matches selection statements with initializer. Given:; void foo() {; if (int i = foobar(); i > 0) {}; switch (int i = foobar(); i) {}; for (auto& a = get_range(); auto& x : a) {}; }; void bar() {; if (foobar() > 0) {}; switch (foobar()) {}; for (auto& x : get_range()) {}; }; ifStmt(hasInitStatement(anything())); matches the if statement in foo but not in bar.; switchStmt(hasInitStatement(anything())); matches the switch statement in foo but not in bar.; cxxForRangeStmt(hasInitStatement(anything())); matches the range for statement in foo bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211980,Modifiability,variab,variable,211980," X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will trigger two matches, binding for 'x' and 'y' respectively. Matcher<LambdaExpr>hasAnyCaptureMatcher<LambdaCapture> InnerMatcher; Matches any capture in a lambda expression. Given; void foo() {; int t = 5;; auto f = [=](){ return t; };; }; lambdaExpr(hasAnyCapture(lambdaCapture())) and; lambdaExpr(hasAnyCapture(lambdaCapture(refersToVarDecl(hasName(""t""))))); both match `[=](){ return t; }`. Matcher<Membe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:212047,Modifiability,variab,variable,212047," X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will trigger two matches, binding for 'x' and 'y' respectively. Matcher<LambdaExpr>hasAnyCaptureMatcher<LambdaCapture> InnerMatcher; Matches any capture in a lambda expression. Given; void foo() {; int t = 5;; auto f = [=](){ return t; };; }; lambdaExpr(hasAnyCapture(lambdaCapture())) and; lambdaExpr(hasAnyCapture(lambdaCapture(refersToVarDecl(hasName(""t""))))); both match `[=](){ return t; }`. Matcher<Membe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:229230,Modifiability,variab,variable,229230,"QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced type's declaration. Matcher<QualType>referencesMatcher<QualType> InnerMatcher; Matches if the matched type is a reference type and the referenced; type matches the specified matcher. Example matches X &x and const X &y; (matcher = varDecl(hasType(references(cxxRecordDecl(hasName(""X"")))))); class X {; void a(X b) {; X &x = b;; const X &y = b;; }; };. Matcher<QualifiedTypeLoc>hasUnqualifiedLocMatcher<TypeLoc> InnerMatcher; Matches `QualifiedTypeLoc`s that have an unqualified `TypeLoc` matching; `InnerMatcher`. Given; int* const x;; const int y;; qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc())); matches the `TypeLoc` of the variable declaration of `x`, but not `y`. Matcher<RecordType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasD",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:252163,Modifiability,variab,variable,252163,"(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:253700,Modifiability,variab,variable,253700,"{};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that have a specific size; expression. Given; void f(int b) {; int a[b];; }; variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(; varDecl(hasName(""b""))))))); matches ""int a[b]"". Matcher<WhileStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:253906,Modifiability,Variab,VariableArrayType,253906," Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that have a specific size; expression. Given; void f(int b) {; int a[b];; }; variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(; varDecl(hasName(""b""))))))); matches ""int a[b]"". Matcher<WhileStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<WhileStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:253971,Modifiability,Variab,VariableArrayType,253971," Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that have a specific size; expression. Given; void f(int b) {; int a[b];; }; variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(; varDecl(hasName(""b""))))))); matches ""int a[b]"". Matcher<WhileStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<WhileStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:254072,Modifiability,variab,variableArrayType,254072,"XBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that have a specific size; expression. Given; void f(int b) {; int a[b];; }; variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(; varDecl(hasName(""b""))))))); matches ""int a[b]"". Matcher<WhileStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<WhileStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:100149,Performance,perform,performance,100149,"= [this]() { return cc; };; return l();; }; };; lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis()))); matches `[this]() { return cc; }`. Matcher<LambdaCapture>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<MemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<NamedDecl>hasAnyNameStringRef, ..., StringRef; Matches NamedDecl nodes that have any of the specified names. This matcher is only provided as a performance optimization of hasName.; hasAnyName(a, b, c); is equivalent to, but faster than; anyOf(hasName(a), hasName(b), hasName(c)). Matcher<NamedDecl>hasExternalFormalLinkage; Matches a declaration that has external formal linkage. Example matches only z (matcher = varDecl(hasExternalFormalLinkage())); void f() {; int x;; static int y;; }; int z;. Example matches f() because it has external formal linkage despite being; unique to the translation unit as though it has internal likage; (matcher = functionDecl(hasExternalFormalLinkage())). namespace {; void f() {}; }. Matcher<NamedDecl>hasNameStringRef Name; Matches NamedDecl nodes that have the specified name. Supports specifying enclosing namespaces or classes by prefixing the name; with '<enclosing>::'.; Does not match typedefs of an underlying type with the given name. Example matches X (Name == ""X""); class X;. Example matches X (Name is one of ""::a::b::X"", ""a::b::X"", ""b::X"", ""X""); namespace a { namespace b { class X; } }. Matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:100161,Performance,optimiz,optimization,100161,"= [this]() { return cc; };; return l();; }; };; lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis()))); matches `[this]() { return cc; }`. Matcher<LambdaCapture>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<MemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<NamedDecl>hasAnyNameStringRef, ..., StringRef; Matches NamedDecl nodes that have any of the specified names. This matcher is only provided as a performance optimization of hasName.; hasAnyName(a, b, c); is equivalent to, but faster than; anyOf(hasName(a), hasName(b), hasName(c)). Matcher<NamedDecl>hasExternalFormalLinkage; Matches a declaration that has external formal linkage. Example matches only z (matcher = varDecl(hasExternalFormalLinkage())); void f() {; int x;; static int y;; }; int z;. Example matches f() because it has external formal linkage despite being; unique to the translation unit as though it has internal likage; (matcher = functionDecl(hasExternalFormalLinkage())). namespace {; void f() {}; }. Matcher<NamedDecl>hasNameStringRef Name; Matches NamedDecl nodes that have the specified name. Supports specifying enclosing namespaces or classes by prefixing the name; with '<enclosing>::'.; Does not match typedefs of an underlying type with the given name. Example matches X (Name == ""X""); class X;. Example matches X (Name is one of ""::a::b::X"", ""a::b::X"", ""b::X"", ""X""); namespace a { namespace b { class X; } }. Matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106735,Performance,load,loadHTMLString,106735,"gRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106881,Performance,load,loadHTMLString,106881," objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107153,Performance,load,loadHTMLString,107153,"bjCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTML",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107195,Performance,load,loadHTMLString,107195,"xpression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107992,Performance,load,loadHTMLStringmatches,107992,"ssageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108123,Performance,load,loadHTMLString,108123,"; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108620,Performance,load,loadHTMLString,108620,"Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:108692,Performance,load,loadHTMLString,108692,"nsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:232455,Performance,queue,queue,232455,"Operator()); matches 'return a + b'; with binaryOperator(); matching 'a + b'. Matcher<StmtExpr>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least one substatement matches; a given matcher. Also matches StmtExprs that have CompoundStmt as children. Given; { {}; 1+2; }; hasAnySubstatement(compoundStmt()); matches '{ {}; 1+2; }'; with compoundStmt(); matching '{}'. Matcher<Stmt>alignOfExprMatcher<UnaryExprOrTypeTraitExpr> InnerMatcher; Same as unaryExprOrTypeTraitExpr, but only matching; alignof. Matcher<Stmt>forCallableMatcher<Decl> InnerMatcher; Matches declaration of the function, method, or block the statement; belongs to. Given:; F& operator=(const F& o) {; std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });; return *this;; }; returnStmt(forCallable(functionDecl(hasName(""operator="")))); matches 'return *this'; but does not match 'return v > 0'. Given:; -(void) foo {; int x = 1;; dispatch_sync(queue, ^{ int y = 2; });; }; declStmt(forCallable(objcMethodDecl())); matches 'int x = 1'; but does not match 'int y = 2'.; whereas declStmt(forCallable(blockDecl())); matches 'int y = 2'; but does not match 'int x = 1'. Matcher<Stmt>forFunctionMatcher<FunctionDecl> InnerMatcher; Matches declaration of the function the statement belongs to. Deprecated. Use forCallable() to correctly handle the situation when; the declaration is not a function (but a block or an Objective-C method).; forFunction() not only fails to take non-functions into account but also; may match the wrong declaration in their presence. Given:; F& operator=(const F& o) {; std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });; return *this;; }; returnStmt(forFunction(hasName(""operator=""))); matches 'return *this'; but does not match 'return v > 0'. Matcher<Stmt>sizeOfExprMatcher<UnaryExprOrTypeTraitExpr> InnerMatcher; Same as unaryExprOrTypeTraitExpr, but only matching; sizeof. Matcher<SubstTemplateTypeParmType>hasReplacementTypeMatcher<",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:8436,Safety,redund,redundant,8436,"rdering operator<=>(const HasSpaceship&) const = default;; };. bool isLess(const HasSpaceship& a, const HasSpaceship& b) {; return a < b;; }. 1 match found. return a < b;; ^~~~~. No match found. Node Matchers. Node matchers are at the core of matcher expressions - they specify the type; of node that is expected. Every match expression starts with a node matcher,; which can then be further refined with a narrowing or traversal matcher. All; traversal matchers take node matchers as their arguments.; For convenience, all node matchers take an arbitrary number of arguments; and implicitly act as allOf matchers.; Node matchers are the only matchers that support the bind(""id"") call to; bind the matched node to the given string, to be later retrieved from the; match callback.; It is important to remember that the arguments to node matchers are; predicates on the same node, just with additional information about the type.; This is often useful to make matcher expression more readable by inlining bind; calls into redundant node matchers inside another node matcher:. // This binds the CXXRecordDecl to ""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:9513,Security,access,accessSpecDeclMatcher,9513,"""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constructor initializers. Examples matches i(42).; class C {; C() : i(42) {}; int i;; };. Matcher<Decl>accessSpecDeclMatcher<AccessSpecDecl>...; Matches C++ access specifier declarations. Given; class C {; public:; int a;; };; accessSpecDecl(); matches 'public:'. Matcher<Decl>bindingDeclMatcher<BindingDecl>...; Matches binding declarations; Example matches foo and bar; (matcher = bindingDecl(). auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>blockDeclMatcher<BlockDecl>...; Matches block declarations. Example matches the declaration of the nameless block printing an input; integer. myFunc(^(int p) {; printf(""%d"", p);; }). Matcher<Decl>classTemplateDeclMatcher<ClassTemplateDecl>...; Matches C++ class template declarations. Example matches Z; template<class T> class Z {};. Matcher<Decl>classTemplatePartialSpecializationDeclMatcher<ClassTemplatePartialSpecializationDecl>...; Matches C++ class template partial specializations. Given; template<class T1, class T2, int I>; class A {};. template<class T, int I>; class A<T, T*, I> {};. template<>; class A<int, int, 1> {};; classTemplatePartialSpecial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:9535,Security,Access,AccessSpecDecl,9535,"""id"", as the decl() matcher will stay on; // the same node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constructor initializers. Examples matches i(42).; class C {; C() : i(42) {}; int i;; };. Matcher<Decl>accessSpecDeclMatcher<AccessSpecDecl>...; Matches C++ access specifier declarations. Given; class C {; public:; int a;; };; accessSpecDecl(); matches 'public:'. Matcher<Decl>bindingDeclMatcher<BindingDecl>...; Matches binding declarations; Example matches foo and bar; (matcher = bindingDecl(). auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>blockDeclMatcher<BlockDecl>...; Matches block declarations. Example matches the declaration of the nameless block printing an input; integer. myFunc(^(int p) {; printf(""%d"", p);; }). Matcher<Decl>classTemplateDeclMatcher<ClassTemplateDecl>...; Matches C++ class template declarations. Example matches Z; template<class T> class Z {};. Matcher<Decl>classTemplatePartialSpecializationDeclMatcher<ClassTemplatePartialSpecializationDecl>...; Matches C++ class template partial specializations. Given; template<class T1, class T2, int I>; class A {};. template<class T, int I>; class A<T, T*, I> {};. template<>; class A<int, int, 1> {};; classTemplatePartialSpecial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:9567,Security,access,access,9567,"ame node.; recordDecl(decl().bind(""id""), hasName(""::MyClass"")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constructor initializers. Examples matches i(42).; class C {; C() : i(42) {}; int i;; };. Matcher<Decl>accessSpecDeclMatcher<AccessSpecDecl>...; Matches C++ access specifier declarations. Given; class C {; public:; int a;; };; accessSpecDecl(); matches 'public:'. Matcher<Decl>bindingDeclMatcher<BindingDecl>...; Matches binding declarations; Example matches foo and bar; (matcher = bindingDecl(). auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>blockDeclMatcher<BlockDecl>...; Matches block declarations. Example matches the declaration of the nameless block printing an input; integer. myFunc(^(int p) {; printf(""%d"", p);; }). Matcher<Decl>classTemplateDeclMatcher<ClassTemplateDecl>...; Matches C++ class template declarations. Example matches Z; template<class T> class Z {};. Matcher<Decl>classTemplatePartialSpecializationDeclMatcher<ClassTemplatePartialSpecializationDecl>...; Matches C++ class template partial specializations. Given; template<class T1, class T2, int I>; class A {};. template<class T, int I>; class A<T, T*, I> {};. template<>; class A<int, int, 1> {};; classTemplatePartialSpecializationDecl(); matches the specialization A<T,T*,I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:9637,Security,access,accessSpecDecl,9637,")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constructor initializers. Examples matches i(42).; class C {; C() : i(42) {}; int i;; };. Matcher<Decl>accessSpecDeclMatcher<AccessSpecDecl>...; Matches C++ access specifier declarations. Given; class C {; public:; int a;; };; accessSpecDecl(); matches 'public:'. Matcher<Decl>bindingDeclMatcher<BindingDecl>...; Matches binding declarations; Example matches foo and bar; (matcher = bindingDecl(). auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>blockDeclMatcher<BlockDecl>...; Matches block declarations. Example matches the declaration of the nameless block printing an input; integer. myFunc(^(int p) {; printf(""%d"", p);; }). Matcher<Decl>classTemplateDeclMatcher<ClassTemplateDecl>...; Matches C++ class template declarations. Example matches Z; template<class T> class Z {};. Matcher<Decl>classTemplatePartialSpecializationDeclMatcher<ClassTemplatePartialSpecializationDecl>...; Matches C++ class template partial specializations. Given; template<class T1, class T2, int I>; class A {};. template<class T, int I>; class A<T, T*, I> {};. template<>; class A<int, int, 1> {};; classTemplatePartialSpecializationDecl(); matches the specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48729,Security,inject,injectedClassNameTypeMatcher,48729,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48758,Security,Inject,InjectedClassNameType,48758,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48793,Security,inject,injected,48793,"larations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,Security,inject,injectedClassNameType,48889,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132835,Security,inject,injected,132835,"Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Ma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:135264,Security,access,accessing,135264,"hat match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138659,Security,Inject,InjectedClassNameType,138659,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:147903,Security,access,access,147903,"iendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<CXXConstructExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a construct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150206,Security,Inject,InjectedClassNameType,150206,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163310,Security,Inject,InjectedClassNameType,163310,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:174226,Security,access,access,174226,": Callee cannot take the more general internal::Matcher<Expr>; because this introduces ambiguous overloads with calls to Callee taking a; internal::Matcher<Decl>, as the matcher hierarchy is purely; implemented in terms of implicit casts. Matcher<CallExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CallExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CallExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CallExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call express",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176505,Security,Inject,InjectedClassNameType,176505,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184219,Security,Inject,InjectedClassNameType,184219,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191717,Security,Inject,InjectedClassNameType,191717,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:208995,Security,Inject,InjectedClassNameType,208995,"(hasInitStatement(anything())); matches the switch statement in foo but not in bar.; cxxForRangeStmt(hasInitStatement(anything())); matches the range for statement in foo but not in bar. Matcher<IfStmt>hasThenMatcher<Stmt> InnerMatcher; Matches the then-statement of an if statement. Examples matches the if statement; (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true))))); if (false) true; else false;. Matcher<ImplicitCastExpr>hasImplicitDestinationTypeMatcher<QualType> InnerMatcher; Matches implicit casts whose destination type matches a given; matcher. Matcher<InitListExpr>hasInitunsigned N, ast_matchers::Matcher<Expr> InnerMatcher; Matches the n'th item of an initializer list expression. Example matches y.; (matcher = initListExpr(hasInit(0, expr()))); int x{y}. Matcher<InitListExpr>hasSyntacticFormMatcher<Expr> InnerMatcher; Matches the syntactic form of init list expressions; (if expression have it). Matcher<InjectedClassNameType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210160,Security,Inject,InjectedClassNameType,210160,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211568,Security,Inject,InjectedClassNameType,211568,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214167,Security,Inject,InjectedClassNameType,214167,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227551,Security,Inject,InjectedClassNameType,227551,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230434,Security,Inject,InjectedClassNameType,230434,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236306,Security,Inject,InjectedClassNameType,236306,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242851,Security,Inject,InjectedClassNameType,242851,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244907,Security,Inject,InjectedClassNameType,244907,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247886,Security,Inject,InjectedClassNameType,247886,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250658,Security,Inject,InjectedClassNameType,250658,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:1751,Testability,test,testing,1751,"u can; find all matchers that can be used to match on Stmt nodes.; The exception to that rule are matchers that can match on any node. Those; are marked with a * and are listed in the beginning of each category.; Note that the categorization of matchers is a great help when you combine; them into matcher expressions. You will usually want to form matcher expressions; that read like english sentences by alternating between node matchers and; narrowing or traversal matchers, like this:. recordDecl(hasDescendant(; ifStmt(hasTrueExpression(; expr(hasDescendant(; ifStmt())))))). Traverse Mode. The default mode of operation of AST Matchers visits all nodes in the AST,; even if they are not spelled in the source. This is; AsIs mode. This mode requires writing AST matchers; that explicitly traverse or ignore implicit nodes, such as parentheses; surrounding an expression or expressions with cleanups. These implicit; nodes are not always obvious from the syntax of the source code, and so this; mode requires careful consideration and testing to get the desired behavior; from an AST matcher. In addition, because template instantiations are matched in the default mode,; transformations can be accidentally made to template declarations. Finally,; because implicit nodes are matched by default, transformations can be made on; entirely incorrect places in the code.; For these reasons, it is possible to ignore AST nodes which are not spelled; in the source using the IgnoreUnlessSpelledInSource; mode. This is likely to be far less error-prone for users who are not already; very familiar with where implicit nodes appear in the AST. It is also likely; to be less error-prone for experienced AST users, as difficult cases do not; need to be encountered and matcher expressions adjusted for these cases.; In clang-query, the mode can be changed with. set traversal IgnoreUnlessSpelledInSource. This affects both matchers and AST dump output in results. When using the C++ API such as in clang-ti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14424,Testability,test,test,14424,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14453,Testability,test,test,14453,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14527,Testability,test,test,14527,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14656,Testability,test,test,14656,"t field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14720,Testability,test,test,14720,"t field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:21836,Testability,test,testStructBinding,21836,"efault(private); #pragma omp parallel default(firstprivate); #pragma omp parallel. ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,; `` default(private)`` and ``default(firstprivate)``. Matcher<QualType>qualTypeMatcher<QualType>...; Matches QualTypes in the clang AST. Matcher<Stmt>addrLabelExprMatcher<AddrLabelExpr>...; Matches address of label statements (GNU extension). Given; FOO: bar();; void *ptr = &&FOO;; goto *bar;; addrLabelExpr(); matches '&&FOO'. Matcher<Stmt>arrayInitIndexExprMatcher<ArrayInitIndexExpr>...; The arrayInitIndexExpr consists of two subexpressions: a common expression; (the source array) that is evaluated once up-front, and a per-element initializer; that runs once for each array element. Within the per-element initializer,; the current index may be obtained via an ArrayInitIndexExpr. Given; void testStructBinding() {; int a[2] = {1, 2};; auto [x, y] = a;; }; arrayInitIndexExpr() matches the array index that implicitly iterates; over the array `a` to copy each element to the anonymous array; that backs the structured binding `[x, y]` elements of which are; referred to by their aliases `x` and `y`. Matcher<Stmt>arrayInitLoopExprMatcher<ArrayInitLoopExpr>...; Matches a loop initializing the elements of an array in a number of contexts:; * in the implicit copy/move constructor for a class with an array member; * when a lambda-expression captures an array by value; * when a decomposition declaration decomposes an array. Given; void testLambdaCapture() {; int a[10];; auto Lam1 = [a]() {; return;; };; }; arrayInitLoopExpr() matches the implicit loop that initializes each element of; the implicit array field inside the lambda object, that represents the array `a`; captured by value. Matcher<Stmt>arraySubscriptExprMatcher<ArraySubscriptExpr>...; Matches array subscript expressions. Given; int i = a[1];; arraySubscriptExpr(); matches ""a[1]"". Matcher<Stmt>asmStmtMatcher<AsmStmt>...; Matches asm statements. int i = 100;; __asm(""mov ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:22480,Testability,test,testLambdaCapture,22480,"ion; (the source array) that is evaluated once up-front, and a per-element initializer; that runs once for each array element. Within the per-element initializer,; the current index may be obtained via an ArrayInitIndexExpr. Given; void testStructBinding() {; int a[2] = {1, 2};; auto [x, y] = a;; }; arrayInitIndexExpr() matches the array index that implicitly iterates; over the array `a` to copy each element to the anonymous array; that backs the structured binding `[x, y]` elements of which are; referred to by their aliases `x` and `y`. Matcher<Stmt>arrayInitLoopExprMatcher<ArrayInitLoopExpr>...; Matches a loop initializing the elements of an array in a number of contexts:; * in the implicit copy/move constructor for a class with an array member; * when a lambda-expression captures an array by value; * when a decomposition declaration decomposes an array. Given; void testLambdaCapture() {; int a[10];; auto Lam1 = [a]() {; return;; };; }; arrayInitLoopExpr() matches the implicit loop that initializes each element of; the implicit array field inside the lambda object, that represents the array `a`; captured by value. Matcher<Stmt>arraySubscriptExprMatcher<ArraySubscriptExpr>...; Matches array subscript expressions. Given; int i = a[1];; arraySubscriptExpr(); matches ""a[1]"". Matcher<Stmt>asmStmtMatcher<AsmStmt>...; Matches asm statements. int i = 100;; __asm(""mov al, 2"");; asmStmt(); matches '__asm(""mov al, 2"")'. Matcher<Stmt>atomicExprMatcher<AtomicExpr>...; Matches atomic builtins.; Example matches __atomic_load_n(ptr, 1); void foo() { int *ptr; __atomic_load_n(ptr, 1); }. Matcher<Stmt>autoreleasePoolStmtMatcher<ObjCAutoreleasePoolStmt>...; Matches an Objective-C autorelease pool statement. Given; @autoreleasepool {; int x = 0;; }; autoreleasePoolStmt(stmt()) matches the declaration of ""x""; inside the autorelease pool. Matcher<Stmt>binaryConditionalOperatorMatcher<BinaryConditionalOperator>...; Matches binary conditional operator expressions (GNU extension). Example ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53525,Testability,log,logical,53525,"ypedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is eq",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:78055,Testability,test,test,78055,"0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<CallExpr>argumentCountAtLeastunsigned N; Checks that a call expression or a constructor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<CallExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<CallExpr>usesADL; Matches call expressions which were resolved using ADL. Example matches y(x) but not y(42) or NS::y(x).; namespace NS {; struct X {};; void y(X);; }. void y(...);. void test() {; NS::X x;; y(x); // Matches; NS::y(x); // Doesn't match; y(42); // Doesn't match; using NS::y;; y(x); // Found by both unqualified lookup and ADL, doesn't match; }. Matcher<CastExpr>hasCastKindCastKind Kind; Matches casts that has a given cast kind. Example: matches the implicit cast around 0; (matcher = castExpr(hasCastKind(CK_NullToPointer))); int *p = 0;. If the matcher is use from clang-query, CastKind parameter; should be passed as a quoted string. e.g., hasCastKind(""CK_NullToPointer""). Matcher<CharacterLiteral>equalsbool Value. Matcher<CharacterLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the pos",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:5956,Usability,Simpl,Simple,5956,"tch found. Replacement produces correct output:. void foo() {; const Container c;; c.cbegin();. for (auto i : c) {; }; }. Replacement of int member; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6024,Usability,Simpl,Simple,6024,"t:. void foo() {; const Container c;; c.cbegin();. for (auto i : c) {; }; }. Replacement of int member; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6103,Usability,Simpl,Simple,6103,"; with safe_int:. fieldDecl(; hasType(asString(""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6175,Usability,Simpl,Simple,6175,"""int"")); ).bind(""use_safe_int""). given:. struct S {; int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(4",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6250,Usability,Simpl,Simple,6250,"lStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. Rewritten binary operators. binaryOperator(; hasOperatorName(""<""),; hasRHS(hasDescendant(int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:6320,Usability,Simpl,Simple,6320,". private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; safe_int m_t;; };. void instantiate() { TemplStruct<int> ti; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. template <typename T> struct TemplStruct {; TemplStruct() {}; ~TemplStruct() {}. private:; T m_t;; };. void instantiate() { TemplStruct<int> ti; }. Add prefix to member initializer. cxxCtorInitializer(; forField(fieldDecl()); ).bind(""add_prefix""). given:. struct Simple {};. struct Record {; Record() : i(42) {}; private:; int i;; Simple s;; };. 2 matches found. Replacement produces incorrect output:. struct Simple {};. struct Record {; m_Record() : m_i(42) {}; private:; int i;; Simple s;; };. 1 match found. Replacement produces correct output:. struct Simple {};. struct Record {; Record() : m_i(42) {}; private:; int i;; Simple s;; };. Ignored default arguments. callExpr(; callee(functionDecl(; hasName(""hasDefaultArg""); )),; argumentCountIs(1); ).bind(""add_prefix""). given:. void hasDefaultArg(int i, int j = 0) {}; void callDefaultArg() { hasDefaultArg(42); }. No match. 1 match found. Lambda fields. fieldDecl(; hasType(asString(""int"")); ).bind(""make_safe""). given:. struct S {; int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. 2 matches found. Replacement produces incorrect output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [safe_a, safe_b = c](int d) { int e = d; };; l(43);; }. 1 match found. Replacement produces correct output:. struct S {; safe_int m_i;; };. void func() {; int a = 0;; int c = 0;. auto l = [a, b = c](int d) { int e = d; };; l(43);; }. Rewritten binary operators. binaryOperator(; hasOperatorName(""<""),; hasRHS(hasDescendant(integerLiteral(equals(0)))); ). given:. #include ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11578,Usability,guid,guide,11578,"specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11615,Usability,guid,guide,11615,"cher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-decla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53758,Usability,Usab,Usable,53758,"mations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53872,Usability,Usab,Usable,53872,"<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:54253,Usability,Usab,Usable,54253," = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matcher. Matcher<*>unlessMatcher<*>; Matches if the provided matcher does not match. Example matches Y (matcher = cxxRecordDecl(unless(hasName(""X"")))); class X {};; class Y {};. Usable as: Any Matcher. Matcher<Attr>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<BinaryOperator>hasAnyOperatorNameStringRef,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:54862,Usability,Usab,Usable,54862,"Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matcher. Matcher<*>unlessMatcher<*>; Matches if the provided matcher does not match. Example matches Y (matcher = cxxRecordDecl(unless(hasName(""X"")))); class X {};; class Y {};. Usable as: Any Matcher. Matcher<Attr>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<BinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<BinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:55055,Usability,Usab,Usable,55055,"t conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is equivalent to:; auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));; anyOf(; ifStmt(trueCond).bind(""trueCond""),; forStmt(trueCond).bind(""trueCond""); );. The with() chain-call accepts zero or more matchers which are combined; as-if with allOf() in each of the node matchers.; Usable as: Any Matcher. Matcher<*>unlessMatcher<*>; Matches if the provided matcher does not match. Example matches Y (matcher = cxxRecordDecl(unless(hasName(""X"")))); class X {};; class Y {};. Usable as: Any Matcher. Matcher<Attr>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<BinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<BinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<BinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: ma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57946,Usability,Usab,Usable,57946,"++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<CXXBoolLiteralExpr>equalsdouble Value. Matcher<CXXBoolLiteralExpr>equalsunsign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:58771,Usability,Usab,Usable,58771,"ctlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<CXXBoolLiteralExpr>equalsdouble Value. Matcher<CXXBoolLiteralExpr>equalsunsigned Value. Matcher<CXXCatchStmt>isCatchAll; Matches a C++ catch statement that has a catch-all handler. Given; try {; // ...; } catch (int) {; // ...; } catch (...) {; // ...; }; cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int). Matcher<CXXConstructExpr>argumentCountAtLeastunsigned N; Checks that a call expression or a constructor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<CXXConstructExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:61238,Usability,guid,guide,61238,"nstructExpr(requiresZeroInitialization())); will match the implicit array filler for pt[1]. Matcher<CXXConstructorDecl>isCopyConstructor; Matches constructor declarations that are copy constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3. Matcher<CXXConstructorDecl>isDefaultConstructor; Matches constructor declarations that are default constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3. Matcher<CXXConstructorDecl>isDelegatingConstructor; Matches constructors that delegate to another constructor. Given; struct S {; S(); // #1; S(int) {} // #2; S(S &&) : S() {} // #3; };; S::S() : S(0) {} // #4; cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not; #1 or #2. Matcher<CXXConstructorDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:62228,Usability,guid,guide,62228,"duction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXCtorInitializer>isBaseInitializer; Matches a constructor initializer if it is initializing a base, as; opposed to a member. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:63950,Usability,guid,guide,63950,"ber. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constructor initializer if it is initializing a member, as; opposed to a base. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())); will match D(int), but not match E(). Matcher<CXXCtorInitializer>isWritten; Matches a constructor initializer if it is explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:70273,Usability,Usab,Usable,70273,"ne. Matcher<CXXMethodDecl>isOverride; Matches if the given method declaration overrides another method. Given; class A {; public:; virtual void x();; };; class B : public A {; public:; virtual void x();; };; matches B::x. Matcher<CXXMethodDecl>isPure; Matches if the given method declaration is pure. Given; class A {; public:; virtual void x() = 0;; };; matches A::x. Matcher<CXXMethodDecl>isUserProvided; Matches method declarations that are user-provided. Given; struct S {; S(); // #1; S(const S &) = default; // #2; S(S &&) = delete; // #3; };; cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3. Matcher<CXXMethodDecl>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXMethodDecl>isVirtualAsWritten; Matches if the given method declaration has an explicit ""virtual"". Given; class A {; public:; virtual void x();; };; class B : public A {; public:; void x();; };; matches A::x but not B::x. Matcher<CXXNewExpr>isArray; Matches array new expressions. Given:; MyClass *p1 = new MyClass[10];; cxxNewExpr(isArray()); matches the expression 'new MyClass[10]'. Matcher<CXXOperatorCallExpr>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXOperatorCallExpr>hasAnyOverloadedOperatorNameStringRef, ..., StringRef; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". hasAnyOverloadedOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOverloadedOperatorName(""+""), ha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:72235,Usability,Usab,Usable,72235,"Of(hasOverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<CXXOperatorCallExpr>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<CXXOperatorCallExpr>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". Given:; class A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<CXXOperatorCallExpr>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<CXXOperatorCallExpr>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXRecordDecl>hasDefinition; Matches a class declaration that is defined. Example matches x (matcher = cxxRecordDecl(hasDefinition())); class x {};; class y;. Matcher<CXXRecordDecl>isDerivedFromstd::string BaseName; Overloaded method as shortcut for isDe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:73759,Usability,Usab,Usable,73759,"rator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXRecordDecl>hasDefinition; Matches a class declaration that is defined. Example matches x (matcher = cxxRecordDecl(hasDefinition())); class x {};; class y;. Matcher<CXXRecordDecl>isDerivedFromstd::string BaseName; Overloaded method as shortcut for isDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isDirectlyDerivedFromstd::string BaseName; Overloaded method as shortcut for isDirectlyDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRecordDecl>isFinal; Matches if the given method or class declaration is final. Given:; class A final {};. struct B {; virtual void f();; };. struct C : B {; void f() final;; };; matches A and C::f, but not B, C, or B::f. Matcher<CXXRecordDecl>isLambda; Matches the generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateIns",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:75071,Usability,Usab,Usable,75071,"he generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRewrittenBinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXRewrittenBinaryOperator>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<CXXRewrittenBinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:79320,Usability,Usab,Usable,79320,"(hasCastKind(CK_NullToPointer))); int *p = 0;. If the matcher is use from clang-query, CastKind parameter; should be passed as a quoted string. e.g., hasCastKind(""CK_NullToPointer""). Matcher<CharacterLiteral>equalsbool Value. Matcher<CharacterLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<CharacterLiteral>equalsdouble Value. Matcher<CharacterLiteral>equalsunsigned Value. Matcher<ClassTemplateSpecializationDecl>templateArgumentCountIsunsigned N; Matches if the number of template arguments equals N. Given; template<typename T> struct C {};; C<int> c;; classTemplateSpecializationDecl(templateArgumentCountIs(1)); matches C<int>. Matcher<CompoundStmt>statementCountIsunsigned N; Checks that a compound statement contains a specific number of; child statements. Example: Given; { for (;;) {} }; compoundStmt(statementCountIs(0))); matches '{}'; but does not match the outer compound statement. Matcher<ConstantArrayType>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"".",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:82504,Usability,Usab,Usable,82504,":Kind AttrKind; Matches declaration that has a given attribute. Given; __attribute__((device)) void f() { ... }; decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of; f. If the matcher is used from clang-query, attr::Kind parameter should be; passed as a quoted string. e.g., hasAttr(""attr::CUDADevice""). Matcher<Decl>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declaratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:82967,Usability,Usab,Usable,82967,"ot match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declarations in an anonymous namespace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:83285,Usability,Usab,Usable,83285,"partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Decl>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Decl>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<Decl>isInAnonymousNamespace; Matches declarations in an anonymous namespace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiation",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:88831,Usability,Usab,Usable,88831,"s 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; class C {; int a : 2;; int b;; };; fieldDecl(isBitField()); matches 'int a;' but not 'int b;'. Matcher<FloatingLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<FloatingLiteral>equalsdouble Value. Matcher<FunctionDecl>hasAnyOverloadedOperatorNameStringRef, ..., StringRef; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". hasAnyOverloadedOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<FunctionDecl>hasDynamicExceptionSpec; Matches functions that have a dynamic exception specification. Given:; void f();; void g() noexcept;; void h() noexcept(true);; void i() noexcept(false);; void j() throw();; void k() throw(int);; void l() throw(...);; functionDecl(hasDynamicExceptionSpec()) and; functionProtoType(hasDynamicExceptionSpec()); match the declarations of j, k, and l, but not f, g, h, or i. Matcher<FunctionDecl>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:90239,Usability,Usab,Usable,90239,"OverloadedOperatorName(""+""), hasOverloadedOperatorName(""-"")). Matcher<FunctionDecl>hasDynamicExceptionSpec; Matches functions that have a dynamic exception specification. Given:; void f();; void g() noexcept;; void h() noexcept(true);; void i() noexcept(false);; void j() throw();; void k() throw(int);; void l() throw(...);; functionDecl(hasDynamicExceptionSpec()) and; functionProtoType(hasDynamicExceptionSpec()); match the declarations of j, k, and l, but not f, g, h, or i. Matcher<FunctionDecl>hasOverloadedOperatorNameStringRef Name; Matches overloaded operator names. Matches overloaded operator names specified in strings without the; ""operator"" prefix: e.g. ""<<"". Given:; class A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<FunctionDecl>hasTrailingReturn; Matches a function declared with a trailing return type. Example matches Y (matcher = functionDecl(hasTrailingReturn())); int X() {}; auto Y() -> int {}. Matcher<FunctionDecl>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91908,Usability,Usab,Usable,91908,"riable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:92539,Usability,Usab,Usable,92539,"es A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribut",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:95152,Usability,Usab,Usable,95152," storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isVariadic; Matches if a function declaration is variadic. Example matches f, but not g or h. The function i will not match, even when; compiled in C mode.; void f(...);; void g(int);; template <typename... Ts> void h(Ts...);; void i();. Matcher<FunctionDecl>isWeak; Matches weak function declarations. Given:; void foo() __attribute__((__weakref__(""__foo"")));; void bar();; functionDecl(isWeak()); matches the weak declaration ""foo"", but not ""bar"". Matcher<FunctionDecl>parameterCountIsunsigned N; Matches FunctionDecls and FunctionProtoTypes that have a; specific parameter count. Given; void f(int i) {}; void g(int i, int j) {}; void h(int i, int j);; void j(int i);; void k(int x, int y, int z, ...);; functionDecl(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(3)); matches k. Matcher<FunctionProtoType>hasDynamicExceptionSpec; Matches functions that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:98812,Usability,Usab,Usable,98812," > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<IntegerLiteral>equalsbool Value. Matcher<IntegerLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOperator(hasOperatorName(""-""),; hasUnaryOperand(integerLiteral(equals(13)))). Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,; Matcher<FloatingLiteral>, Matcher<IntegerLiteral>. Matcher<IntegerLiteral>equalsdouble Value. Matcher<IntegerLiteral>equalsunsigned Value. Matcher<LambdaCapture>capturesThis; Matches a `LambdaCapture` that refers to 'this'. Given; class C {; int cc;; int f() {; auto l = [this]() { return cc; };; return l();; }; };; lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis()))); matches `[this]() { return cc; }`. Matcher<LambdaCapture>isImplicit; Matches an entity that has been implicitly added by the compiler (e.g.; implicit default/copy constructors). Matcher<MemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109400,Usability,Usab,Usable,109400,"guments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Matcher<ParmVarDecl>isAtPositionunsigned N; Matches the ParmVarDecl nodes that are at the N'th position in the parameter; list. The par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:115879,Usability,Usab,Usable,115879,"),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Stmt>equalsNodeconst Stmt* Other; Matches if a node equals another node. Stmt has pointer identity in the AST. Matcher<Stmt>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Stmt>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Stmt>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isInTemplateInstantiation; Matches statements inside of a template instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isIn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:116342,Usability,Usab,Usable,116342,"ot match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Stmt>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Stmt>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isInTemplateInstantiation; Matches statements inside of a template instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:116660,Usability,Usab,Usable,116660,"partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<Stmt>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Stmt>isInTemplateInstantiation; Matches statements inside of a template instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:118019,Usability,Usab,Usable,118019,"mplate definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the template argument's value is; an arbitrary precision integer. 'Value' must be euqal to the canonical; representation of that integral value in base 10. Given; template<int T> struct C {};; C<42> c;; classTemplateSpecializationDecl(; hasAnyTemplateArgument(equalsIntegralValu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:120324,Usability,Usab,Usable,120324,"plicit instantiation of C in C<42>; with isIntegral() matching 42. Matcher<TemplateSpecializationType>templateArgumentCountIsunsigned N; Matches if the number of template arguments equals N. Given; template<typename T> struct C {};; C<int> c;; classTemplateSpecializationDecl(templateArgumentCountIs(1)); matches C<int>. Matcher<TypeLoc>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<TypeLoc>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:120790,Usability,Usab,Usable,120790,"ch if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<TypeLoc>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were expanded within files whose name is; partially matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:121111,Usability,Usab,Usable,121111,"lly matching a given regex. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInFileMatching(""AST.*"")); #include ""ASTMatcher.h""; class X {};; ASTMatcher.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<TypeLoc>isExpansionInMainFile; Matches AST nodes that were expanded within the main-file. Example matches X but not Y; (matcher = cxxRecordDecl(isExpansionInMainFile()); #include <Y.h>; class X {};; Y.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<TypeLoc>isExpansionInSystemHeader; Matches AST nodes that were expanded within system-header-files. Example matches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Type>equalsNodeconst Type* Other; Matches if a node equal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126587,Usability,Usab,Usable,126587," int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127271,Usability,Usab,Usable,127271," as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isS",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:129526,Usability,Usab,Usable,129526,"atic"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return typeNameParameters. Matcher<*>binaryOperationMatcher<*>...Matcher<*>; Matches nodes which can be used with binary operators. The code; var1 != var2;; might be represented in the clang AST as a binaryOperator, a; cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on. * whether the types of var1 and var2 are fundamental (binaryOperator) or at; least one is a class type (cxxOperatorCallExpr); * whether the code appears in a template declaration, if at least one of the; vars is a dependent-type (binaryOperator); * whether the code relies on a rewritten binary operator, such as a; spaceship operator or an inverted equality operato",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:131739,Usability,Usab,Usable,131739,"d(""lhs"")),; hasRHS(expr().bind(""rhs"")); ); matches each use of ""!="" in:; struct S{; bool operator!=(const S&) const;; };. void foo(); {; 1 != 2;; S() != S();; }. template<typename T>; void templ(); {; 1 != 2;; T() != S();; }; struct HasOpEq; {; bool operator==(const HasOpEq &) const;; };. void inverse(); {; HasOpEq s1;; HasOpEq s2;; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate a match result for each; matching submatcher. For example, in:; class A { int a; int b; };; The matcher:; cxxRecordDecl(eachOf(has(fieldDecl(hasName(""a"")).bind(""v"")),; has(fieldDecl(hasName(""b"")).bind(""v"")))); will generate two results binding ""v"", the first of which binds; the field declaration of a, the second the field declaration of; b. Usable as: Any Matcher. Matcher<*>findAllMatcher<*> Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132071,Usability,Usab,Usable,132071,";; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate a match result for each; matching submatcher. For example, in:; class A { int a; int b; };; The matcher:; cxxRecordDecl(eachOf(has(fieldDecl(hasName(""a"")).bind(""v"")),; has(fieldDecl(hasName(""b"")).bind(""v"")))); will generate two results binding ""v"", the first of which binds; the field declaration of a, the second the field declaration of; b. Usable as: Any Matcher. Matcher<*>findAllMatcher<*> Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132934,Usability,Usab,Usable,132934,"her:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cx",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:133478,Usability,Usab,Usable,133478," must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:133765,Usability,Usab,Usable,133765,"escendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringPa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:134177,Usability,Usab,Usable,134177,"s Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Becau",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:134574,Usability,Usab,Usable,134574,"true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Matcher<*>hasDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, Y, Z; (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(""X""))))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invoc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:135068,Usability,Usab,Usable,135068," Y { class X {}; };; class Z { class Y { class X {}; }; };. DescendantT must be an AST base type. Usable as: Any Matcher. Matcher<*>hasMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optiona",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:136316,Usability,Usab,Usable,136316,"tch both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is no data; member named ""bar"" in that class. Usable as: Any Matcher. Matcher<*>traverseTraversalKind TK, Matcher<*> InnerMatcher; Causes all nested matchers to be matched with the specified traversal kind. Given; void foo(); {; int i = 3.0;; }; The matcher; traverse(TK_IgnoreUnlessSpelledInSource,; varDecl(hasInitializer(floatLiteral().bind(""init""))); ); matches the variable declaration with ""init"" bound to the ""3.0"". Matcher<AbstractConditionalOperator>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<AbstractConditionalOperator>hasFalseExpressionMatcher<Expr> InnerMatcher; Matches the false branch expression of a conditional operator; (binary or ternary). Example matches b; condition ? a : b; condition ?: b. Matcher<AbstractConditionalOperator>hasTrueExpressionMatcher<Expr> InnerMatcher; Matches the true branch expression of a conditional operator",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138506,Usability,Usab,Usable,138506,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:140078,Usability,Usab,Usable,140078,"se(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<ArrayType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<AtomicType>hasValueTypeMatcher<Type>; Matches atomic types with a specific value type. Given; _Atomic(int) i;; _Atomic(float) f;; atomicType(hasValueType(isInteger())); matches ""_Atomic(int) i"". Usable as: Matcher<AtomicType>. Matcher<AutoType>hasDeducedTypeMatcher<Type>; Matches AutoType nodes where the deduced type is a specific type. Note: There is no TypeLoc for the deduced type and thus no; getDeducedLoc() matcher. Given; auto a = 1;; auto b = 2.0;; autoType(hasDeducedType(isInteger())); matches ""auto a"". Usable as: Matcher<AutoType>. Matcher<BaseUsingDecl>hasAnyUsingShadowDeclMatcher<UsingShadowDecl> InnerMatcher; Matches any using shadow declaration. Given; namespace X { void b(); }; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasName(""b"")))); matches using X::b ; Matcher<BinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:140334,Usability,Usab,Usable,140334,"i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<ArrayType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<AtomicType>hasValueTypeMatcher<Type>; Matches atomic types with a specific value type. Given; _Atomic(int) i;; _Atomic(float) f;; atomicType(hasValueType(isInteger())); matches ""_Atomic(int) i"". Usable as: Matcher<AtomicType>. Matcher<AutoType>hasDeducedTypeMatcher<Type>; Matches AutoType nodes where the deduced type is a specific type. Note: There is no TypeLoc for the deduced type and thus no; getDeducedLoc() matcher. Given; auto a = 1;; auto b = 2.0;; autoType(hasDeducedType(isInteger())); matches ""auto a"". Usable as: Matcher<AutoType>. Matcher<BaseUsingDecl>hasAnyUsingShadowDeclMatcher<UsingShadowDecl> InnerMatcher; Matches any using shadow declaration. Given; namespace X { void b(); }; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasName(""b"")))); matches using X::b ; Matcher<BinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<BinaryOperator>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<BinaryOperator>hasOperandsMatcher<Expr> Matcher1, Matcher<Expr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:140655,Usability,Usab,Usable,140655," Matcher<ArraySubscriptExpr>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<ArrayType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<AtomicType>hasValueTypeMatcher<Type>; Matches atomic types with a specific value type. Given; _Atomic(int) i;; _Atomic(float) f;; atomicType(hasValueType(isInteger())); matches ""_Atomic(int) i"". Usable as: Matcher<AtomicType>. Matcher<AutoType>hasDeducedTypeMatcher<Type>; Matches AutoType nodes where the deduced type is a specific type. Note: There is no TypeLoc for the deduced type and thus no; getDeducedLoc() matcher. Given; auto a = 1;; auto b = 2.0;; autoType(hasDeducedType(isInteger())); matches ""auto a"". Usable as: Matcher<AutoType>. Matcher<BaseUsingDecl>hasAnyUsingShadowDeclMatcher<UsingShadowDecl> InnerMatcher; Matches any using shadow declaration. Given; namespace X { void b(); }; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasName(""b"")))); matches using X::b ; Matcher<BinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<BinaryOperator>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<BinaryOperator>hasOperandsMatcher<Expr> Matcher1, Matcher<Expr> Matcher2; Matches if both matchers match with opposite sides of the binary operator; or fold expression. Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1),; integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<BinaryOperator>hasRHSMatcher<Expr> ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:143794,Usability,Usab,Usable,143794,"aration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<BlockPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""str",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:144488,Usability,Usab,Usable,144488,"t"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<BlockPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXBaseSpecifier>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:145038,Usability,Usab,Usable,145038,"eMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<CXXBaseSpecifier>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXBaseSpecifier>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:146446,Usability,Usab,Usable,146446,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<CXXBaseSpecifier>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<CXXConstructExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); mat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150053,Usability,Usab,Usable,150053,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:151927,Usability,Usab,Usable,151927,"alizer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field declaration of a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(; forField(hasName(""foo_"")))))); matches Foo; with forField matching foo_. Matcher<CXXCtorInitializer>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXCtorInitializer>withInitializerMatcher<Expr> InnerMatcher; Matches the initializer expression of a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(; withInitializer(integerLiteral(equals(1))))))); matches Foo; with withInitializer matching (1). Matcher<CXXDependentScopeMemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; me",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:157943,Usability,Usab,Usable,157943,"; Matches the initialization statement of a for loop. Example:; forStmt(hasLoopVariable(anything())); matches 'int x' in; for (int x : a) { }. Matcher<CXXForRangeStmt>hasRangeInitMatcher<Expr> InnerMatcher; Matches the range initialization statement of a for loop. Example:; forStmt(hasRangeInit(anything())); matches 'a' in; for (int x : a) { }. Matcher<CXXFunctionalCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXMemberCallExpr>onImplicitObjectArgumentMatcher<Expr> InnerMatcher; Matches on the implicit object argument of a member call expression. Unlike; `on`, matches the argument directly without stripping away anything. Given; class Y { public: void m(); };; Y g();; class X : public Y { void g(); };; void z(Y y, X x) { y.m(); x.m(); x.g(); (g()).m(); }; cxxMemberCallExpr(onImplicitObjectArgument(hasType(; cxxRecordDecl(hasName(""Y""))))); matches `y.m()`, `x.m()` and (g()).m(), but not `x.g()`.; cxxMemberCallExpr(on(callExpr())); does not match `(g()).m()`, because the parens are not ignored. FIXME: Overload to allow directly matching types?. Matcher<CXXMemberCallExpr>onMatcher<Expr> InnerMatcher; Matches on the implicit object argument of a member call expression, after; st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163157,Usability,Usab,Usable,163157,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:164276,Usability,Usab,Usable,164276,"teTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXOperatorCallExpr>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<CXXOperatorCallExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<CXXOperatorCallExpr>hasOperandsMatcher<Expr> Matcher1, Matcher<Expr> Matcher2; Matches if both matchers match with opposite sides of the binary operator; or fold expression. Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1),; integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<CXXOperatorCallExpr>hasRHSMatcher<Expr> InnerMatcher; Matche",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:167827,Usability,Usab,Usable,167827,"; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<CXXRecordDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<CXXRecordDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<CXXRewrittenBinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left hand side or the right hand side of a; binary operator or fold expression matches. Matcher<CXXRew",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170031,Usability,Usab,Usable,170031," binaryOperator(hasOperands(integerLiteral(equals(1),; integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<CXXRewrittenBinaryOperator>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<CXXTemporaryObjectExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:171695,Usability,Usab,Usable,171695,"(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CallExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<CallExpr>calleeMatcher<Stmt> InnerMatcher; Matches if the call or fold expression's callee expression matches. Given; class Y { void x() { this->x(); x(); Y y; y.x(); } };; void f() { f(); }; callExpr(callee(expr())); matches this->x(), x(), y.x(), f(); with ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176352,Usability,Usab,Usable,176352,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:180429,Usability,Usab,Usable,180429," {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<ClassTemplateSpecializationDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<ComplexType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<CompoundLiteralExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CX",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:181078,Usability,Usab,Usable,181078,"nner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<ComplexType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<CompoundLiteralExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CompoundStmt>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:181571,Usability,Usab,Usable,181571,"ropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<ComplexType>hasElementTypeMatcher<Type>; Matches arrays and C99 complex types that have a specific element; type. Given; struct A {};; A a[7];; int b[7];; arrayType(hasElementType(builtinType())); matches ""int b[7]"". Usable as: Matcher<ArrayType>, Matcher<ComplexType>. Matcher<CompoundLiteralExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CompoundStmt>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least one substatement matches; a given matcher. Also matches StmtExprs that have CompoundStmt as children. Given; { {}; 1+2; }; hasAnySubstatement(compoundStmt()); matches '{ {}; 1+2; }'; with compoundStmt(); matching '{}'. Matcher<CoroutineBodyStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184066,Usability,Usab,Usable,184066,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:185333,Usability,Usab,Usable,185333,"teSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<DeclRefExpr>toMatcher<Decl> InnerMatcher; Matches a DeclRefExpr that refers to a declaration that matches the; specified matcher. Example matches x in if(x); (matcher = declRefExpr(to(varDecl(hasName(""x""))))); bool x;; if (x) {}. Matcher<DeclStmt>containsDeclarationunsigned N, Matcher<Decl> InnerMatcher; Matches the n'th declaration of a declaration statement. Note that this does not work for global declarations because the AST; breaks up multiple-declaration DeclStmt's into multiple single-declaration; DeclStmt's.; Example: Given non-global declarations; int a, b = 0;; int c;; int d = 2, e;; declStmt(containsDeclaration(; 0, varDecl(hasInitializer(anything())))); matches only 'int d = 2, e;', and; declStmt(containsDeclaration(1, varDecl())); matches 'int a, b = 0' as well as 'int d = 2, e;'; but 'int c;' is not matched. Matcher<DeclStmt>hasSingleDeclMatcher<Decl> InnerMatcher; Matches the Decl of a DeclStmt which has a single declaration. Given; int ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:186884,Usability,Usab,Usable,186884,", and; declStmt(containsDeclaration(1, varDecl())); matches 'int a, b = 0' as well as 'int d = 2, e;'; but 'int c;' is not matched. Matcher<DeclStmt>hasSingleDeclMatcher<Decl> InnerMatcher; Matches the Decl of a DeclStmt which has a single declaration. Given; int a, b;; int c;; declStmt(hasSingleDecl(anything())); matches 'int c;' but not 'int a, b;'. Matcher<DeclaratorDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Decl>hasDeclContextMatcher<Decl> InnerMatcher; Matches declarations whose declaration context, interpreted as a; Decl, matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }. cxxRcordDecl(hasDeclContext(namedDecl(hasName(""M"")))) matches the; declaration of class D. Matcher<DecltypeType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<DecompositionDecl>hasAnyBindingMatcher<BindingDecl> InnerMatcher; Matches any binding of a DecompositionDecl. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 4",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:187848,Usability,Usab,Usable,187848,"oo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Decl>hasDeclContextMatcher<Decl> InnerMatcher; Matches declarations whose declaration context, interpreted as a; Decl, matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }. cxxRcordDecl(hasDeclContext(namedDecl(hasName(""M"")))) matches the; declaration of class D. Matcher<DecltypeType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<DecompositionDecl>hasAnyBindingMatcher<BindingDecl> InnerMatcher; Matches any binding of a DecompositionDecl. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; decompositionDecl(hasAnyBinding(bindingDecl(hasName(""f"").bind(""fBinding"")))); matches the decomposition decl with 'f' bound to ""fBinding"". Matcher<DecompositionDecl>hasBindingunsigned N, Matcher<BindingDecl> InnerMatcher; Matches the Nth binding of a DecompositionDecl. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; decompositionDecl(hasBinding(0,; bindingDecl(hasName(""f"").bind(""fBinding"")))); matches the decomposition decl with 'f' bound to ""fBinding"". Matcher<DoStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191564,Usability,Usab,Usable,191564,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:192645,Usability,Usab,Usable,192645,"teSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Expr>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:194041,Usability,Usab,Usable,194041,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<Expr>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<Expr>ignoringElidableConstructorCallast_matchers::Matcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher that are possibly wrapped in an; elidable constructor and other corresponding bookkeeping nodes. In C++17, elidable copy constructors are no longer being generated in the; AST as it is not permitted by the standard. They are, however, part of th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:200735,Usability,Usab,Usable,200735,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<FriendDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<FunctionDecl>forEachTemplateArgumentclang::ast_matchers::Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecialization, templateSpecializationType and; functionDecl nodes where the template argument matches the inner matcher.; This matcher may produce multiple matches. Given; template <typename T, unsigned N, unsigned M>; struct Matrix {};. cons",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210007,Usability,Usab,Usable,210007,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211415,Usability,Usab,Usable,211415,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214014,Usability,Usab,Usable,214014,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:215583,Usability,Usab,Usable,215583,"implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""first""))); matches second.first; but not first.second (because the member name there is ""second""). Matcher<MemberPointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<NamedDecl>hasUnderlyingDeclMatcher<NamedDecl> InnerMatcher; Matches a NamedDecl whose underlying declaration matches the given; matcher. Given; namespace N { template<class T> void f(T t); }; template <class T> void g() { using N::f; f(T()); }; unresolvedLookupExpr(hasAnyDeclaration(; namedDecl(hasUnderlyingDecl(hasName(""::N::f""))))); matches the use of f in g() . Matcher<NestedNameSpecifierLoc>hasPrefixMatcher<NestedNameSpecifierLoc> InnerMatcher; Matches on the prefix of a NestedNameSpecifierLoc. Given; struct A { struct B { struct C {}; }; };; A::B::C c;; nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(""struct A""))))); matches ""A::"". Matcher<NestedNameSpecifierLoc>locMatcher<NestedNameSpecifier> InnerMatcher; Matches NestedNameSpecifierLocs for which the given inner; NestedNameSpecifier-matcher matches. Matcher<NestedNameSpecifierLoc>specifiesTypeLocMatcher<TypeLoc> InnerMatcher; Matches nested name specifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:219282,Usability,Usab,Usable,219282,". Given. #pragma omp parallel; ;; #pragma omp parallel; {}. ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``. Matcher<ObjCInterfaceDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's met",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:223828,Usability,Usab,Usable,223828," or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<OpaqueValueExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<OverloadExpr>hasAnyDeclarationMatcher<Decl> InnerMatcher; Matches an OverloadExpr if any of the declarations in the set of; overloads matches the given matcher. Given; template <typename T> void foo(T);; template <typename T> void bar(T);; template <typename T> void baz(T t) {; foo(t);; bar(t);; }; unresolvedLookupExpr(hasAnyDeclarat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:225405,Usability,Usab,Usable,225405,"atcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<OverloadExpr>hasAnyDeclarationMatcher<Decl> InnerMatcher; Matches an OverloadExpr if any of the declarations in the set of; overloads matches the given matcher. Given; template <typename T> void foo(T);; template <typename T> void bar(T);; template <typename T> void baz(T t) {; foo(t);; bar(t);; }; unresolvedLookupExpr(hasAnyDeclaration(; functionTemplateDecl(hasName(""foo"")))); matches foo in foo(t); but not bar in bar(t);. Matcher<ParenType>innerTypeMatcher<Type>; Matches ParenType nodes where the inner type is a specific type. Given; int (*ptr_to_array)[4];; int (*ptr_to_func)(int);. varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches; ptr_to_func but not ptr_to_array. Usable as: Matcher<ParenType>. Matcher<PointerTypeLoc>hasPointeeLocMatcher<TypeLoc> PointeeMatcher; Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching; `PointeeMatcher`. Given; int* x;; pointerTypeLoc(hasPointeeLoc(loc(asString(""int"")))); matches `int*`. Matcher<PointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<QualType>hasCanonicalTypeMatcher<QualType> InnerMatcher; Matches QualTypes whose canonical type matches InnerMatcher. Given:; typedef int &int_ref;; int a;; int_ref b = a;. varDecl(hasType(qualType(referenceType()))))) will not match the; declaration of b but varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does. Matcher<QualType>hasDeclarati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:225940,Usability,Usab,Usable,225940,"(t);; }; unresolvedLookupExpr(hasAnyDeclaration(; functionTemplateDecl(hasName(""foo"")))); matches foo in foo(t); but not bar in bar(t);. Matcher<ParenType>innerTypeMatcher<Type>; Matches ParenType nodes where the inner type is a specific type. Given; int (*ptr_to_array)[4];; int (*ptr_to_func)(int);. varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches; ptr_to_func but not ptr_to_array. Usable as: Matcher<ParenType>. Matcher<PointerTypeLoc>hasPointeeLocMatcher<TypeLoc> PointeeMatcher; Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching; `PointeeMatcher`. Given; int* x;; pointerTypeLoc(hasPointeeLoc(loc(asString(""int"")))); matches `int*`. Matcher<PointerType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<QualType>hasCanonicalTypeMatcher<QualType> InnerMatcher; Matches QualTypes whose canonical type matches InnerMatcher. Given:; typedef int &int_ref;; int a;; int_ref b = a;. varDecl(hasType(qualType(referenceType()))))) will not match the; declaration of b but varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does. Matcher<QualType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227398,Usability,Usab,Usable,227398,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230281,Usability,Usab,Usable,230281,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:231215,Usability,Usab,Usable,231215,"f class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnValue(binaryOperator()); matches 'return a + b'; with binaryOperator(); matching 'a + b'. Matcher<StmtExpr>hasAnySubstatementMatcher<Stmt> InnerMatcher; Matches compound statements where at least one substatement matches; a given matcher. Also matches StmtExprs that have CompoundStmt as children. Given; { {}; 1+2; }; hasAnySubstatement(compoundStmt()); matches '{ {}; 1+2; }'; with compoundStmt(); matching '{}'. Matcher<Stmt>alignOfExprMatcher<UnaryExprOrTypeTraitExpr> InnerMatcher; Same as unaryExprOrTypeTraitExpr, but only matching; alignof. Matcher<Stmt>forCallableMatcher<Decl> InnerMatcher; Matches declaration of the function, method, or block the statement; belongs to. Given:; F& operator=(const F& o) {; std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });; ret",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236153,Usability,Usab,Usable,236153,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236993,Usability,Usab,Usable,236993,">,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<TemplateArgument>isExprMatcher<Expr> InnerMatcher; Matches a sugar TemplateArgument that refers to a certain expression. Given; struct B { int next; };; template<int(B::*next_ptr)> struct A {};; A<&B::next> a;; templateSpecializationType(hasAnyTemplateArgument(; isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName(""next"")))))))); matches the specialization A<&B::next> with fieldDecl(...) matching; B::next. Matcher<TemplateArgument>refersToDeclarationMatcher<Decl> InnerMatcher; Matches a canonical TemplateArgument that refers to a certain; declaration. Given; struct B { int next; };; template<int(B::*next_ptr)> struct A {};; A<&B::next> a;; classTemplateSpecializationDecl(hasAnyTemplateArgument(; refersToDeclaration(fieldDecl(hasName(""next""))))); matches the specializa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242698,Usability,Usab,Usable,242698,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244754,Usability,Usab,Usable,244754,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:245711,Usability,Usab,Usable,245711,"meType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<TypedefNameDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<TypedefType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247733,Usability,Usab,Usable,247733,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250505,Usability,Usab,Usable,250505,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:251486,Usability,Usab,Usable,251486,"as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:251925,Usability,Usab,Usable,251925,"NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:252955,Usability,Usab,Usable,252955,"peMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that ha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:183,Availability,avail,available,183,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:557,Availability,error,error,557,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:1313,Availability,down,downcasts,1313," than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2170,Availability,error,error,2170,"res user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add som",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4380,Availability,error,errors,4380,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5120,Availability,error,error,5120,"ions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undete",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5164,Availability,error,error,5164,". These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5789,Availability,error,error,5789,"; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; retu",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5883,Availability,error,error,5883,"tory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program whi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5908,Availability,error,error,5908,"tory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program whi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6249,Availability,error,error,6249,"orted; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely br",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6266,Availability,error,error,6266,"move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6305,Availability,error,error,6305,"move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8509,Availability,error,error,8509,"r (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Obje",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8543,Availability,error,error,8543,"assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArra",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9075,Availability,error,error,9075,"l register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Cla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9535,Availability,error,error,9535," suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10253,Availability,error,error,10253,"ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werro",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12012,Availability,error,error,12012,"ted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a clas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14084,Availability,error,error,14084,"the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was decla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16272,Availability,error,errors,16272,"x this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16341,Availability,error,error,16341,"call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16548,Availability,error,error,16548,"ration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18227,Availability,error,error,18227,"at we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19737,Availability,down,downside,19737,"essor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:20366,Availability,Error,Error,20366,"diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly la",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:20976,Availability,error,error,20976,"lass type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows imp",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21702,Availability,error,error,21702,"member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; alre",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21877,Availability,avail,available,21877,"ion parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21931,Availability,down,downcasts,21931," void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, meth",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21998,Availability,down,downcasts,21998,"edeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22394,Availability,error,error,22394,"ion process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22402,Availability,down,downcast,22402,"mplementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22419,Availability,error,error,22419,"before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22474,Availability,down,downcast,22474,"before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22642,Availability,down,downcast,22642,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7464,Deployability,integrat,integrated,7464,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7549,Deployability,integrat,integrated,7549,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7665,Deployability,integrat,integrated,7665," __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instructio",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4522,Energy Efficiency,Power,PowerPC,4522,"; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __blo",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11652,Energy Efficiency,allocate,allocate,11652,"e or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where th",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:563,Integrability,message,message,563,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:811,Integrability,interface,interfaces,811,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:877,Integrability,protocol,protocol,877,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:987,Integrability,depend,dependent,987,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4030,Integrability,interface,interfaces,4030,"Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue cas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6924,Integrability,depend,depends,6924," return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. as",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7464,Integrability,integrat,integrated,7464,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7549,Integrability,integrat,integrated,7549,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7665,Integrability,integrat,integrated,7665," __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instructio",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8515,Integrability,message,message,8515,"r (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Obje",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9235,Integrability,interface,interfaces,9235,"; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9577,Integrability,interface,interface,9577," suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10558,Integrability,interface,interface,10558," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10572,Integrability,protocol,protocol,10572," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10632,Integrability,interface,interface,10632,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10646,Integrability,protocol,protocol,10646,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10837,Integrability,interface,interface,10837,"tanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12120,Integrability,depend,dependent,12120,"ted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a clas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12868,Integrability,depend,dependent,12868,"ate <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& valu",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:13376,Integrability,depend,dependent,13376,"{; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14194,Integrability,depend,dependent,14194,"the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was decla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14952,Integrability,depend,dependent,14952,"(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typena",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15752,Integrability,depend,dependent,15752," type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15913,Integrability,depend,dependent,15913," of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16485,Integrability,depend,dependent,16485," by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the me",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16693,Integrability,depend,dependent,16693,"arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed t",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17036,Integrability,depend,depends,17036," void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they a",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17958,Integrability,depend,depend,17958," the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18995,Integrability,depend,dependent,18995,"ich don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Defa",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22262,Integrability,interface,interface,22262,"nstructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code wi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22284,Integrability,interface,interface,22284,"nstructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code wi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23307,Integrability,interface,interface,23307,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23428,Integrability,message,message-send,23428,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:450,Modifiability,portab,portability,450,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:687,Modifiability,variab,variable,687,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:733,Modifiability,variab,variables,733,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:853,Modifiability,variab,variables,853,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:906,Modifiability,Variab,Variable-length,906,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:1127,Modifiability,variab,variable,1127,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4296,Modifiability,portab,portable,4296," set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem,",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4721,Modifiability,rewrite,rewrite,4721,"vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4866,Modifiability,rewrite,rewrite,4866,"ve leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; ret",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5406,Modifiability,variab,variable,5406,"ese, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5473,Modifiability,variab,variable,5473,"functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5483,Modifiability,Variab,Variables,5483," and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5590,Modifiability,variab,variable,5590,".h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initial",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5641,Modifiability,variab,variable,5641,".h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initial",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6363,Modifiability,variab,variable,6363,":. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allo",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6411,Modifiability,rewrite,rewrite,6411,"ps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6467,Modifiability,variab,variable,6467,"ps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6638,Modifiability,variab,variables,6638,", leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6686,Modifiability,variab,variable,6686,"ider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6886,Modifiability,variab,variables,6886,"^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific exam",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7048,Modifiability,variab,variables,7048,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7101,Modifiability,variab,variables,7101,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7156,Modifiability,variab,variables,7156,".e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The s",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9367,Modifiability,variab,variables,9367,"en though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p)",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10544,Modifiability,variab,variables,10544," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10614,Modifiability,variab,variables,10614,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10690,Modifiability,variab,variable,10690,"o; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10781,Modifiability,Variab,Variables,10781,"lem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the f",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10970,Modifiability,Variab,Variable-length,10970,"rnal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11138,Modifiability,variab,variable,11138," Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11349,Modifiability,variab,variable,11349," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19976,Modifiability,variab,variable,19976," ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23112,Modifiability,extend,extend,23112,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2041,Performance,optimiz,optimization,2041,"mplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2484,Performance,optimiz,optimizer,2484,"U C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-s",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22121,Safety,unsafe,unsafe,22121,"laration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In parti",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:3749,Security,access,accessing,3749," unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source f",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4417,Usability,simpl,simple,4417,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8146,Usability,clear,clear,8146,"ocal variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'su",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8768,Usability,clear,clear,8768,"le of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyw",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11481,Usability,simpl,simple,11481," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19629,Usability,clear,clearer,19629,"typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19894,Usability,simpl,simple,19894,"s soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function protot",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:214,Availability,Avail,Available,214,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:2453,Availability,Error,Errors,2453," dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Synt",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9774,Availability,Error,Error,9774,s; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9972,Availability,error,errors,9972,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:12035,Availability,Error,Errors,12035,"cription of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent na",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:15840,Availability,Error,Error,15840,d fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templates; Yes. 229; NAD; Partial specialization of function templates; Clang 2.9. 230; NAD; Calls to pure virtual functions; Clang 3.0. 231; NAD; Visibility of names after using-directives; Yes. 232; NAD; Is indirection through a null pointer undefined behavior?; Unknown. 233; drafting; References vs pointers in UDC overload resolution; Not resolved. 234; NAD; Reuse of base class subobjects; N/A. 235; TC1; Assignment vs initialization; N/A. 236; NAD; Explicit temporaries and integral constant expressions; Clang 3.2. 237; CD1; Explicit instantiation and base class members; Duplicate of 470. 238; CD4; Precision and accuracy constraints on floating point; Unknown. 239; CD1; Footnote 116 and Koenig lookup; Yes. 240; CD3; Uninitialized values and undefined behavior; Duplicate of 616. 241; TC1; Error in example in 14.8.1; Yes. 242; CD4; Interpretation of old-style casts; Unknown. 243; NAD; Weighting of conversion functions in direct-initialization; Yes. 244; CD1; Destructor lookup; Clang 11. 245; CD1; Name lookup in elaborated-type-specifiers; Yes. 246; CD1; Jumps in function-try-block handlers; Clang 3.2. 247; NAD; Pointer-to-member casts and function overload resolution; Yes. 248; C++11; Identifier characters; Superseded by P1949. 249; TC1; What is a member function template?; Yes. 250; TC1; Address of function template specialization with non-deduced template arguments; Yes. 251; open; How many signed integer types are there?; Not resolved. 252; CD1; Looking up deallocation functions in virtual destructors; Clang 3.1. 253; C++17; Why must empty or fully-initialized const objects be initialized?; Unknown. 254; CD1; Definitional problems with elaborated-type-specifiers; Clang 2.9. 255; CD6; Placement deallocation functions and lookup ambiguity; Yes. 256; CD1; Overflow in size calc,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:23465,Availability,error,error,23465,"type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator all",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24876,Availability,avail,available,24876,"ignature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:25960,Availability,Error,Errors,25960,"ed name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386; CD6; Friend declaration of name brought in by using-declaration; Unknown. 387; CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1823. 398; CD1; Ambiguous wording on naming a type in deduction; Yes. 399; CD6; Destructor lookup redux; Clang 11. 400; CD1; Using-declarations and the ""struct hack""; Yes. 401; CD1; When is access for template parameter defaul",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:28153,Availability,error,error,28153,"on with non-trivial constructor; N/A. 405; CD6; Unqualified function name lookup; Yes. 406; CD1; Static data member in class with name for linkage purposes; Clang 2.9. 407; C++11; Named class with associated typedef: two names or one?; Clang 3.8. 408; CD2; sizeof applied to unknown-bound array static data member of template; Clang 3.4. 409; CD1; Obsolete paragraph missed by changes for issue 224; Yes. 410; CD1; Paragraph missed in changes for issue 166; No. 411; CD6; Use of universal-character-name in character versus string literals; Unknown. 412; NAD; Can a replacement allocation function be inline?; Clang 3.4. 413; CD1; Definition of ""empty class""; Yes. 414; CD1; Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instantiation; Yes. 416; CD1; Class must be complete to allow operator lookup?; Yes. 417; CD1; Using derived-class qualified name in out-of-class nested class definition; No. 418; CD6; Imperfect wording on error on multiple default arguments on a called function; No. 419; open; Can cast to virtual base class be done on partially-constructed object?; Not resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression eval",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38340,Availability,error,error,38340, overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:39405,Availability,failure,failure,39405,the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference init,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:47713,Availability,error,errors,47713, Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/definitions in type-specifier-seqs and type-ids; Clang 3.0. 687; NAD; template keyword with unqualified-ids; Unknown. 688; CD1; Constexpr constructors and static initialization; Unknown. 689; CD5; Maximum values of signed and unsigned integers; Unknown. 690; CD2; The dynamic type of an rvalue reference; Unknown. 691; C++11; Template parameter packs in class template partial specializations; Unknown. 692; C++11; Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resol,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:48789,Availability,failure,failure,48789,"1; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic o",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:51124,Availability,error,error,51124,alification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57030,Availability,Error,Error,57030,29; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating exception specifications; Unknown. 831; CD2; Limit on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74328,Availability,error,error,74328,d resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; Unknown. 1134; C++11; When is an explicitly-defaulted function defined?; Unknown. 1135; C++11; Explicitly-defaulted non-public specia,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74512,Availability,Error,Error,74512,lete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; Unknown. 1134; C++11; When is an explicitly-defaulted function defined?; Unknown. 1135; C++11; Explicitly-defaulted non-public special member functions; Unknown. 1136; C++11; Explicitly-defaulted explicit constructors; Unknown. 1137; C++11; Explicitly-defaulted virtual special member functions; Unknown. 1138; C++11; Rvalue-ness check for rval,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78382,Availability,failure,failure,78382, inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:81720,Availability,failure,failure,81720,tion-call xvalues and decltype; Unknown. 1213; CD3; Array subscripting and xvalues; Clang 7. 1214; C++11; Kinds of initializers; Unknown. 1215; C++11; Definition of POD struct; Unknown. 1216; C++11; Exceptions “allowed” by a noexcept-specification; Unknown. 1217; NAD; Are deleted functions implicitly noexcept?; Unknown. 1218; C++11; What is the “currently-handled exception” in a multi-threaded program?; Unknown. 1219; C++11; Non-static data member initializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creation of array temporaries using a braced-init-list; Unknown. 1233; C++11; Pack expansions and dependent calls; Unknown. 1234; C++11; abstract-declarator does not permit ... after ptr-operator; Unknown. 1235; C++11; “Unused” ellipsis and default arguments in partial ordering; Unknown. 1236; C++11; Inconsistently-interrelated examples; Unknown. 1237; C++11; Deprecated implicit copy assignment in example; Unknown. 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:84270,Availability,failure,failure,84270,d lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:88181,Availability,Error,Error,88181, of unknown size; Clang 3.0. 1306; CD3; Modifying an object within a const member function; Unknown. 1307; C++14; Overload resolution based on size of array initializer-list; Clang 14. 1308; CD3; Completeness of class type within an exception-specification; Superseded by 1330. 1309; CD4; Incorrect note regarding lookup of a member of the current instantiation; Unknown. 1310; CD3; What is an “acceptable lookup result?”; Clang 5. 1311; CD3; Volatile lvalues in constant expressions; Unknown. 1312; CD3; Simulated reinterpret_cast in constant expressions; Unknown. 1313; CD3; Undefined pointer arithmetic in constant expressions; Unknown. 1314; NAD; Pointer arithmetic within standard-layout objects; Unknown. 1315; CD4; Restrictions on non-type template arguments in partial specializations; Partial. 1316; NAD; constexpr function requirements and class scope; Unknown. 1317; NAD; Unnamed scoped enumerations; Unknown. 1318; CD3; Syntactic ambiguities with final; Unknown. 1319; NAD; Error in pack expansion example; Unknown. 1320; CD3; Converting scoped enumerations to bool; Unknown. 1321; CD3; Equivalency of dependent calls; Unknown. 1322; drafting; Function parameter type decay in templates; Not resolved. 1323; NAD; Nonexistent nonterminal in alignment-specifier grammar; Unknown. 1324; CD3; Value initialization and defaulted constructors; Unknown. 1325; NAD; Omitted declarator in friend declarations; Unknown. 1326; dup; Deducing an array bound from an initializer-list; Unknown. 1327; CD3; virt-specifier in a defaulted definition; Unknown. 1328; CD3; Conflict in reference binding vs overload resolution; Unknown. 1329; CD3; Recursive deduction substitutions; Unknown. 1330; CD3; Delayed instantiation of noexcept specifiers; Clang 4 (C++11 onwards). 1331; CD5; const mismatch with defaulted copy constructor; Unknown. 1332; CD5; Handling of invalid universal-character-names; Unknown. 1333; CD3; Omission of const in a defaulted copy constructor; Unknown. 1334; NAD; Layout compatibilit,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98247,Availability,failure,failure,98247,"; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,Availability,redundant,redundant,98536,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99068,Availability,Error,Errors,99068,"erload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initial",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101777,Availability,failure,failure,101777,afting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignm,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:104032,Availability,Error,Errors,104032,ccess” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defined in class templates; Unknown. 1546; NAD; Errors in function template default arguments; Unknown. 1547; NAD; typename keyword in alias-declarations; Unknown. 1548; drafting; Copy/move construction and conversion functions; Not resolved. 1549; open; Overloaded comma operator with void operand; Not resolved. 1550; CD3; Parenthesized throw-expression operand of conditional-expression; Clang 3.4. 1551; C++14; Wording problems in using-declaration specification; Unknown. 1552; CD4; exception-specifications and defaulted special member functions; Unknown. 1553; CD3; sizeof and xvalue bit-fields; Unknown. 1554; drafting; Access and alias templates; Not resolved. 1555; NAD; Language linkage and function type compatibility; Unknown. 1556; CD3; Constructors and explicit conversion functions in direct initialization; Unknown. 1557; CD3; Language linkage of converted lambda function pointer; Unknown. 1558; CD4; Unused arguments in alias template specializations; Clang 12. 1559; CD3; String too long in initializer list of new-expression; Unknown. 1560; CD3; Gra,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106747,Availability,failure,failure,106747,rvening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as ar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:107598,Availability,error,errors,107598,ments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as array[1]; Unknown. 1597; CD3; Misleading constexpr example; Unknown. 1598; C++14; Criterion for equality of pointers to members; Unknown. 1599; CD4; Lifetime of initializer_list underlying array; Unknown. 1600; CD4; Erroneous reference initialization in example; Unknown. 1601; C++14; Promotion of enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:108174,Availability,Error,Errors,108174,"ist-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as array[1]; Unknown. 1597; CD3; Misleading constexpr example; Unknown. 1598; C++14; Criterion for equality of pointers to members; Unknown. 1599; CD4; Lifetime of initializer_list underlying array; Unknown. 1600; CD4; Erroneous reference initialization in example; Unknown. 1601; C++14; Promotion of enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; G",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:111258,Availability,failure,failure,111258,"33; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member initializer; Unknown. 1642; DRWP; Missing requirements for prvalue operands; Unknown. 1643; NAD; Default arguments for template parameter packs; Unknown. 1644; NAD; Equivalent exception-specifications in function template declarations; Unknown. 1645; CD4; Identical inheriting constructors via default arguments; Clang 3.9. 1646; CD5; decltype-specifiers, abstract classes, and deduction failure; Unknown. 1647; drafting; Type agreement of non-type template arguments in partial specializations; Not resolved. 1648; C++14; thread_local vs block extern declarations; Unknown. 1649; C++14; Error in the syntax of mem-initializer-list; Unknown. 1650; NAD; Class prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not reso",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:111458,Availability,Error,Error,111458,"required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member initializer; Unknown. 1642; DRWP; Missing requirements for prvalue operands; Unknown. 1643; NAD; Default arguments for template parameter packs; Unknown. 1644; NAD; Equivalent exception-specifications in function template declarations; Unknown. 1645; CD4; Identical inheriting constructors via default arguments; Clang 3.9. 1646; CD5; decltype-specifiers, abstract classes, and deduction failure; Unknown. 1647; drafting; Type agreement of non-type template arguments in partial specializations; Not resolved. 1648; C++14; thread_local vs block extern declarations; Unknown. 1649; C++14; Error in the syntax of mem-initializer-list; Unknown. 1650; NAD; Class prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unkn",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116806,Availability,failure,failure,116806,7; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134045,Availability,Redundant,Redundant,134045,structor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-de,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134329,Availability,Redundant,Redundant,134329,wn. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138210,Availability,Redundant,Redundant,138210, description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs stati,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:139894,Availability,error,errors,139894,and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory fo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142293,Availability,failure,failure,142293,e lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:150932,Availability,Redundant,Redundant,150932,"onversions in template argument deduction; Unknown. 2201; C++17; Cv-qualification of array types; Unknown. 2202; drafting; When does default argument instantiation occur?; Not resolved. 2203; drafting; Defaulted copy/move constructors and UDCs; Not resolved. 2204; NAD; Naming delegated constructors; Unknown. 2205; C++17; Restrictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed names",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156640,Availability,failure,failures,156640,allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:158489,Availability,failure,failure,158489,bda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:171279,Availability,failure,failure,171279,"wn. 2485; DRWP; Bit-fields in integral promotions; Unknown. 2486; CD6; Call to noexcept function via noexcept(false) pointer/lvalue; Unknown. 2487; drafting; Type dependence of function-style cast to incomplete array type; Not resolved. 2488; open; Overloading virtual functions and functions with trailing requires-clauses; Not resolved. 2489; C++23; Storage provided by array of char; Unknown. 2490; CD6; Restrictions on destruction in constant expressions; Unknown. 2491; CD6; Export of typedef after its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expressions; Extension. 2501; drafting; Explicit instantiation and trailing requires-clauses; Not resolved. 2502; CD6; Unintended declaration conflicts in nested statement scopes; Unknown. 2503; drafting; Unclear relationship among name, qualified name, and unqualified name; Not resolved. 2504; DR; Inheriting constructors from virtual base classes; Unknown. 2505; drafting; Nested unnamed namespace of inline unnamed namespace; Not resolved. 2506; CD6; Structured bindings and array cv-qualifiers; Unknown. 2507; CD6; Default arguments for operator[]; Unknown. 2508; C++23; Restrictions on uses of template parameter names; Unknown. 2509; CD6; decl-specifier-seq in lambda-specifiers; Unknown. 2510; NAD; noexcept-specifier of friend function vs class completeness; Unknown. 2511; CD6; cv-qualified bit-fields; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:172738,Availability,error,error,172738,ified name; Not resolved. 2504; DR; Inheriting constructors from virtual base classes; Unknown. 2505; drafting; Nested unnamed namespace of inline unnamed namespace; Not resolved. 2506; CD6; Structured bindings and array cv-qualifiers; Unknown. 2507; CD6; Default arguments for operator[]; Unknown. 2508; C++23; Restrictions on uses of template parameter names; Unknown. 2509; CD6; decl-specifier-seq in lambda-specifiers; Unknown. 2510; NAD; noexcept-specifier of friend function vs class completeness; Unknown. 2511; CD6; cv-qualified bit-fields; Unknown. 2512; NAD; typeid and incomplete class types; Unknown. 2513; open; Ambiguity with requires-clause and operator-function-id; Not resolved. 2514; open; Modifying const subobjects; Not resolved. 2515; open; Result of a function call; Not resolved. 2516; C++23; Locus of enum-specifier or opaque-enum-declaration; Clang 3.0. 2517; C++23; Useless restriction on use of parameter in constraint-expression; Unknown. 2518; C++23; Conformance requirements and #error/#warning; Clang 17. 2519; DRWP; Object representation of a bit-field; Unknown. 2520; C++23; Template signature and default template arguments; Unknown. 2521; C++23; User-defined literals and reserved identifiers; Clang 17. 2522; open; Removing placemarker tokens and retention of whitespace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180801,Availability,failure,failure,180801,C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Inject,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:182046,Availability,Redundant,Redundant,182046,"owing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183802,Availability,failure,failure,183802,"on of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-declared spaceship vs. built-in operators; Unknown. 2674; C++23; Prohibit explicit object parameters for constructors; Unknown. 2675; open; start_lifetime_as, placement-new, and active union members; Not resolved. 2676; open; Replacing a complete object having base subobjects; Not resolved. 2677; review; Replacing union subobjects; Not resolved. 2678; C++23; std::source_location::current is unimplementa",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186440,Availability,error,error,186440,"Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,Availability,redundant,redundant,187787,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192407,Availability,failure,failure,192407,s between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functio,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196379,Availability,Redundant,Redundant,196379,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78270,Deployability,release,release,78270,wn. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:143999,Deployability,release,release,143999, Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and con,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181696,Deployability,Update,Update,181696,"-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24035,Energy Efficiency,reduce,reduces,24035," 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit sp",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125862,Energy Efficiency,allocate,allocated,125862,lock-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer arithmetic and multi-level qualification conversions; Unknown. 1866; CD4; Initializing variant members with non-trivial destructors; Unknown. 1867; NAD; Function/expression ambiguity with qualified parameter name; Unknown. 1868; drafting; Meaning of “plac,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175231,Energy Efficiency,allocate,allocated,175231,"ay comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafti",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:387,Integrability,depend,dependent,387,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3017,Integrability,depend,dependent,3017,"Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete t",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3087,Integrability,depend,dependent,3087,"1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7960,Integrability,depend,dependent,7960,"essions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class ar",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:8725,Integrability,Depend,Dependent,8725,"unction""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:8755,Integrability,depend,dependent,8755,"unction""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9954,Integrability,Inject,Injection-related,9954,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,Integrability,inject,injection,11726,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,Integrability,inject,injection,11784,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13043,Integrability,depend,dependent,13043,"1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lo",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13579,Integrability,depend,dependent,13579,"d punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14040,Integrability,depend,dependent,14040,"dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14793,Integrability,depend,dependent,14793,1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templates; Yes. 229; NAD; Partial specialization of function templates; Clang 2.9. 230; NAD; Calls to pure virtual functions; Clang 3.0. 231; NAD; Visibility of names after using-directives; Yes. 232; NAD; Is indirection through a null pointer undefined behavior?; Unknown. 233; drafting; References vs pointers in UDC overload resolution; Not resolved. 234; NAD; Reuse of base class subobjects; N/A. 235; TC1; Assignment vs initialization; N/A. 236; NAD; Explicit temporaries and integral constant expressions; Clang 3.2. 237; CD1; Explicit instantiation and base class members; Duplicate of 470. 238; CD4; Precision and accuracy constraints on floating point; Unknown. 239; CD1; Footnote 116 and Koenig lookup; Yes. 240; CD3; Uninitialized values and un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18892,Integrability,depend,dependencies,18892,"nt deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. 290; NAD; Should memcpy be allowed into a POD with a const member?; N/A. 291; CD1; Overload resolution needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,Integrability,inject,injection,20182,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20956,Integrability,Inject,Injected-class-name,20956,"303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:21404,Integrability,depend,dependent,21404,"ot simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization ex",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:22242,Integrability,depend,dependent,22242," in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization examples are still incorrect; Yes. 337; CD1; Attempt to create array of abtract type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocat",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:23572,Integrability,rout,routine,23572," unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:25729,Integrability,depend,dependent,25729,"rd C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386; CD6; Friend declaration of name brought in by using-declaration; Unknown. 387; CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,Integrability,inject,injected,29274,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29397,Integrability,inject,inject,29397,"; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording is",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30557,Integrability,depend,dependent,30557,"435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30625,Integrability,depend,dependent,30625,"/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to co",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34327,Integrability,Depend,Dependency,34327,wards). 489; NAD; Must member function templates be instantiated during overload resolution?; N/A. 490; CD2; Name lookup in friend declarations; Clang 2.8. 491; CD1; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35291,Integrability,depend,dependent,35291,502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” clas,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35992,Integrability,depend,dependent,35992,"n of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” class templates; Not resolved. 530; CD1; Nontype template arguments in constant expressions; Yes. 531; C++11; Defining members of explicit specializations; Partial. 532; C++11; Member/nonmember operator template partial ordering; Clang 3.5. 533; NAD; Special treatment for C-style header names; N/A. 534; CD1; template-names and operator-function-ids; Clang 2.9. 535; CD3; Copy construction without a copy constructor; Yes. 536; CD6; Problems in the description of id-expressions; N/A. 537; CD1; Definition of “signature”; N/A. 538; CD1; Definition and usage; of structure, POD-struct, POD-union,; and POD class; N/A. 539; CD3; Constraints on type-specifier",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:37069,Integrability,Depend,Dependent,37069,"he specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” class templates; Not resolved. 530; CD1; Nontype template arguments in constant expressions; Yes. 531; C++11; Defining members of explicit specializations; Partial. 532; C++11; Member/nonmember operator template partial ordering; Clang 3.5. 533; NAD; Special treatment for C-style header names; N/A. 534; CD1; template-names and operator-function-ids; Clang 2.9. 535; CD3; Copy construction without a copy constructor; Yes. 536; CD6; Problems in the description of id-expressions; N/A. 537; CD1; Definition of “signature”; N/A. 538; CD1; Definition and usage; of structure, POD-struct, POD-union,; and POD class; N/A. 539; CD3; Constraints on type-specifier-seq; Yes. 540; CD1; Propagation of cv-qualifiers in reference-to-reference collapse; Yes. 541; CD2; Dependent function types; Yes. 542; CD2; Value initialization of arrays of POD-structs; Yes. 543; CD1; Value initialization and default constructors; Clang 3.0. 544; NAD; Base class lookup in explicit specialization; Yes. 545; open; User-defined conversions and built-in operator overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructo",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38192,Integrability,depend,dependent,38192,nstructors; Clang 3.0. 544; NAD; Base class lookup in explicit specialization; Yes. 545; open; User-defined conversions and built-in operator overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard convers,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38480,Integrability,depend,dependent,38480,ecialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40264,Integrability,depend,dependent,40264,pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40493,Integrability,depend,dependent,40493,list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of e,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,Integrability,inject,injected-class-name,41297,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:45458,Integrability,Depend,Dependent,45458,ction; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Conversions to and from nullptr_t; Superseded by 1423. 655; C++11; Initialization not specified for forwarding constructors; Yes. 656; CD2; Direct binding to the result of a conversion operator; Yes. 657; CD2; Abstract class parameter in synthesized declaration; Partial. 658; CD2; Defining reinterpret_cast for pointer types; Unknown. 659; CD1; Alignment of function types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue references; Yes. 665; CD2; Problems in the specification of dynamic_cast; Clang 2.8. 666; CD1; Dependent qualified-ids without the typename keyword; Clang 2.8. 667; CD2; Trivial special member functions that cannot be implicitly defined; Clang 8. 668; CD2; Throwing an exception from the destructor of a local static object; Unknown. 669; NAD; Confusing specification of the meaning of decltype; Yes. 670; CD4; Copy initialization via derived-to-base conversion in the second step; Unknown. 671; CD1; Explicit conversion from a scoped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types an,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:46022,Integrability,Inject,Injection,46022, types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue references; Yes. 665; CD2; Problems in the specification of dynamic_cast; Clang 2.8. 666; CD1; Dependent qualified-ids without the typename keyword; Clang 2.8. 667; CD2; Trivial special member functions that cannot be implicitly defined; Clang 8. 668; CD2; Throwing an exception from the destructor of a local static object; Unknown. 669; NAD; Confusing specification of the meaning of decltype; Yes. 670; CD4; Copy initialization via derived-to-base conversion in the second step; Unknown. 671; CD1; Explicit conversion from a scoped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types and the ODR; Unknown. 679; CD1; Equivalence of template-ids and operator function templates; Yes. 680; CD2; What is a move constructor?; N/A. 681; CD1; Restrictions on declarators with late-specified return types; Partial. 682; CD5; Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/defin,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:48463,Integrability,depend,dependent,48463,"Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:53357,Integrability,depend,dependent,53357,"765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknown. 782; CD2; Lambda expressions and argument-dependent lookup; Unknown. 783; open; Definition of “argument”; Not resolved. 784; C++11; List of incompatibilities with the previous Standard; Unknown. 785; CD2; “Execution sequence” is inappropriate phraseology; Unknown. 786; CD2; Definition of “thread”; Unknown. 787; CD2; Unnecessary lexical undefined behavior; Unknown. 788; CD2; Relationship between locale and values of the execution character set; Unknown. 789; CD2; Deprecating trigraphs; Unknown. 790; CD2; Concatenation of raw and non-raw string literals; Unknown. 792; CD2; Effects of std::quick_exit; Unknown. 793; CD2; Use of class members during destruction; Unknown. 794; NAD; Base-derived conversion in member type of pointer-to-member conversion; Unknown. 795; NAD; Dependency of lambdas on <functional>; Unknown. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in c",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:54091,Integrability,Depend,Dependency,54091,. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknown. 782; CD2; Lambda expressions and argument-dependent lookup; Unknown. 783; open; Definition of “argument”; Not resolved. 784; C++11; List of incompatibilities with the previous Standard; Unknown. 785; CD2; “Execution sequence” is inappropriate phraseology; Unknown. 786; CD2; Definition of “thread”; Unknown. 787; CD2; Unnecessary lexical undefined behavior; Unknown. 788; CD2; Relationship between locale and values of the execution character set; Unknown. 789; CD2; Deprecating trigraphs; Unknown. 790; CD2; Concatenation of raw and non-raw string literals; Unknown. 792; CD2; Effects of std::quick_exit; Unknown. 793; CD2; Use of class members during destruction; Unknown. 794; NAD; Base-derived conversion in member type of pointer-to-member conversion; Unknown. 795; NAD; Dependency of lambdas on <functional>; Unknown. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-s,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55350,Integrability,depend,dependent,55350,scribed in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating exception specifications; Unknown. 831; CD2; Limit on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enum,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57184,Integrability,depend,dependent,57184, on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59543,Integrability,depend,dependent,59543,alized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functions; Unknown. 914; open; Value-initialization of array types; Not resolved. 915; CD2; Deleted specializations of member function templates; Unknown. 919; CD2; Contradictions regarding inline namespaces; Unknown. 920; CD2; Interaction of inline namespaces and using-declarations; Unknown. 921; CD2; Unclear specification of inline namespaces; Unknown. 922; CD2; Implicit default constructor definitions an,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65598,Integrability,depend,dependent,65598,ant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65619,Integrability,depend,dependent,65619,ant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65931,Integrability,depend,dependent,65931, Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent loo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66096,Integrability,Inject,Injected-class-names,66096,"3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity b",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66915,Integrability,depend,dependent,66915,"ameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defin",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67200,Integrability,Depend,Dependent,67200,"class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67877,Integrability,Depend,Dependent,67877,"nts and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete-expressions and deallocation functions; Unknown. 1038; DR; Overload resolution of &x.static_func; Unknown. 1039; dup; Coordinating C and C++ alignment specifications; Unknown. 1040; NAD; Memory model issues; Unknown. 1041; dup; alias-declarations as class members; Unknown. 1042; C++11; Attributes in alias-declarations; Clang 3.5. 1043; C++11; Qualified name lookup in the current instantiation; Unknown. 1044; C++1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:69128,Integrability,depend,dependent,69128," Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete-expressions and deallocation functions; Unknown. 1038; DR; Overload resolution of &x.static_func; Unknown. 1039; dup; Coordinating C and C++ alignment specifications; Unknown. 1040; NAD; Memory model issues; Unknown. 1041; dup; alias-declarations as class members; Unknown. 1042; C++11; Attributes in alias-declarations; Clang 3.5. 1043; C++11; Qualified name lookup in the current instantiation; Unknown. 1044; C++11; Point of declaration for an alias-declaration; Unknown. 1045; NAD; Requiring explicit instantiation declarations; Unknown. 1046; open; What is a “use” of a class specialization?; Not resolved. 1047; C++11; When is typeid value-dependent?; Unknown. 1048; CD3; auto deduction and lambda return type deduction.; Clang 3.6. 1049; open; Copy elision through reference parameters of inline functions; Not resolved. 1050; NAD; Effects of thread support on object lifetime; Unknown. 1051; C++11; Reference members and generated copy constructors; Unknown. 1052; dup; const non-static data member and PODness; Unknown. 1053; NAD; Terminate vs undefined behavior for noexcept violation; Unknown. 1054; C++11; Lvalue-to-rvalue conversions in expression statements; No. 1055; C++11; Permissible uses of void; Unknown. 1056; C++11; Template aliases, member definitions, and the current instantiation; Unknown. 1057; C++11; decltype and the current instantiation; Unknown. 1058; NAD; Reference binding of incompatible array types; Unknown. 1059; CD3; Cv-qualified array types (with rvalues); Unknown. 1060; C++11; Scoped enumerators in integral constant expressions; Unknown. 1061; C++11; Negative array bounds in a new-expression; Un",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:71051,Integrability,depend,dependent,71051,". 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between templates and copy constructors; Unknown. 1081; C++11; Defaulted destructor and unusable operator delete; Unknown. 1082; C++11; Implicit copy function if subobject has none?; Unknown. 1083; C++11; Passing an object to ellipsis with non-trivial move constructor; Unknown. 1084; NAD; Conditions for a deleted move function; Unknown. 1085; NAD; Move assignment operators and virtual bases; Unknown. 1086; C++11; const_cast to rvalue reference to function type; Unknown. 1087; C++11; Additional applications of issue 899; Unknown. 1088; C++11; Dependent non-type template a",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:72032,Integrability,Depend,Dependent,72032,ue-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between templates and copy constructors; Unknown. 1081; C++11; Defaulted destructor and unusable operator delete; Unknown. 1082; C++11; Implicit copy function if subobject has none?; Unknown. 1083; C++11; Passing an object to ellipsis with non-trivial move constructor; Unknown. 1084; NAD; Conditions for a deleted move function; Unknown. 1085; NAD; Move assignment operators and virtual bases; Unknown. 1086; C++11; const_cast to rvalue reference to function type; Unknown. 1087; C++11; Additional applications of issue 899; Unknown. 1088; C++11; Dependent non-type template arguments; Unknown. 1089; open; Template parameters in member selections; Not resolved. 1090; C++11; Alignment of subobjects; Unknown. 1091; C++11; Inconsistent use of the term “object expression”; Unknown. 1092; drafting; Cycles in overload resolution during instantiation; Not resolved. 1093; CD3; Value-initializing non-objects; Unknown. 1094; C++11; Converting floating-point values to scoped enumeration types; Unknown. 1095; C++11; List-initialization of references; Unknown. 1096; C++11; Missing requirement for template definitions; Unknown. 1097; NAD; Aggregate initialization of function parameters; Unknown. 1098; C++11; Pointer conversions in constant expressions; Unknown. 1099; C++11; Infinite recursion in constexpr functions; Unknown. 1100; C++11; constexpr conversion functions and non-type template arguments; Unknown. 1101; C++11; Non-integral initialized static data members; Unknown. 1102; C++11; Better example of undefined behavior; Unknown. 1103; C++11; Reversion o,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77197,Integrability,Depend,Dependent,77197,f function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined lite,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77284,Integrability,Depend,Dependent,77284,bjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Int,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78008,Integrability,depend,dependent,78008,e; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initializat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78323,Integrability,depend,dependency-ordered-before,78323,-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Ina,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78911,Integrability,depend,dependent,78911,unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use of address-constant pointers in constant expressions; Unknown. 1194; C++11; Constexpr references; Unknown. 1195; C++11; References to non-literal types in constexpr functions; Unknown. 1196; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:80553,Integrability,Inject,Injection,80553,; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions definitions?; Unknown. 1202; C++11; Calling virtual functions during destruction; Unknown. 1203; dup; Misleading note regarding initialized static data members; Unknown. 1204; C++11; Specifiers in a for-range-declaration; Unknown. 1205; dup; Lvalue reference binding and function viability; Unknown. 1206; C++11; Defining opaque enumeration members of class templates; Unknown. 1207; C++11; Type of class member in trailing-return-type; Unknown. 1208; C++11; Explicit noexcept in defaulted definition; Unknown. 1209; open; Is a potentially-evaluated expression in a template definition a “use?”; Not resolved. 1210; C++11; Injection of elaborated-type-specifier in enumeration scope; Unknown. 1211; drafting; Misaligned lvalues; Not resolved. 1212; C++11; Non-function-call xvalues and decltype; Unknown. 1213; CD3; Array subscripting and xvalues; Clang 7. 1214; C++11; Kinds of initializers; Unknown. 1215; C++11; Definition of POD struct; Unknown. 1216; C++11; Exceptions “allowed” by a noexcept-specification; Unknown. 1217; NAD; Are deleted functions implicitly noexcept?; Unknown. 1218; C++11; What is the “currently-handled exception” in a multi-threaded program?; Unknown. 1219; C++11; Non-static data member initializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknow,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:82154,Integrability,depend,dependent,82154,tializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creation of array temporaries using a braced-init-list; Unknown. 1233; C++11; Pack expansions and dependent calls; Unknown. 1234; C++11; abstract-declarator does not permit ... after ptr-operator; Unknown. 1235; C++11; “Unused” ellipsis and default arguments in partial ordering; Unknown. 1236; C++11; Inconsistently-interrelated examples; Unknown. 1237; C++11; Deprecated implicit copy assignment in example; Unknown. 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241; C++11; Which members does a destructor destroy?; Unknown. 1242; C++11; Initializing variant class members; Unknown. 1243; C++11; Misleading footnote regarding multiple-declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in typ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83488,Integrability,depend,dependent,83488, 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241; C++11; Which members does a destructor destroy?; Unknown. 1242; C++11; Initializing variant class members; Unknown. 1243; C++11; Misleading footnote regarding multiple-declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifie,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83850,Integrability,depend,dependent,83850,declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83962,Integrability,depend,dependent,83962,emplates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:84845,Integrability,depend,dependent,84845,tion via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of intmax_t and uintmax_t; Unknown. 1278; drafting; Incorrect treatment of contrived object; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Tri,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:85526,Integrability,depend,dependent,85526,rflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of intmax_t and uintmax_t; Unknown. 1278; drafting; Incorrect treatment of contrived object; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Trivial destructors and object lifetime; Unknown. 1286; drafting; Equivalence of alias templates; Not resolved. 1287; C++14; Direct initialization vs “implicit” conversion in reference binding; Unknown. 1288; CD3; Reference list initialization; Unknown. 1289; NAD; Can an alias template name the current instantiation?; Unknown. 1290; CD3; Lifetime of the underlying array of an initializer_list member; Unknown. 1291; CD6; Looking up a conversion-type-id; N/A. 1292; CD4; Dependent calls with braced-init-lists containing a pack expansion; Unknown. 1293; CD3; String literals in constant expressions; Unknown. 1294; open; Side effects in dynamic/static initialization; Not resolved. 1295; CD3; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:86308,Integrability,Depend,Dependent,86308,; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Trivial destructors and object lifetime; Unknown. 1286; drafting; Equivalence of alias templates; Not resolved. 1287; C++14; Direct initialization vs “implicit” conversion in reference binding; Unknown. 1288; CD3; Reference list initialization; Unknown. 1289; NAD; Can an alias template name the current instantiation?; Unknown. 1290; CD3; Lifetime of the underlying array of an initializer_list member; Unknown. 1291; CD6; Looking up a conversion-type-id; N/A. 1292; CD4; Dependent calls with braced-init-lists containing a pack expansion; Unknown. 1293; CD3; String literals in constant expressions; Unknown. 1294; open; Side effects in dynamic/static initialization; Not resolved. 1295; CD3; Binding a reference to an rvalue bit-field; Clang 4. 1296; CD3; Ill-formed template declarations (not just definitions); Unknown. 1297; CD3; Misplaced function attribute-specifier; Unknown. 1298; CD3; Incorrect example in overload resolution; Unknown. 1299; CD5; “Temporary objects” vs “temporary expressions”; Unknown. 1300; dup; T() for array types; Unknown. 1301; CD3; Value initialization of union; Unknown. 1302; CD3; noexcept applied to expression of type void; Unknown. 1303; NAD; C language linkage for template with internal linkage; Unknown. 1304; drafting; Omitted array bound with string initialization; Not resolved. 1305; CD3; alignof applied to array of unknown size; Clang 3.0. 1306; CD3; Modifying an object within a const member function; Unknown. 1307; C++14; Overload resolution based on si,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:88309,Integrability,depend,dependent,88309," Overload resolution based on size of array initializer-list; Clang 14. 1308; CD3; Completeness of class type within an exception-specification; Superseded by 1330. 1309; CD4; Incorrect note regarding lookup of a member of the current instantiation; Unknown. 1310; CD3; What is an “acceptable lookup result?”; Clang 5. 1311; CD3; Volatile lvalues in constant expressions; Unknown. 1312; CD3; Simulated reinterpret_cast in constant expressions; Unknown. 1313; CD3; Undefined pointer arithmetic in constant expressions; Unknown. 1314; NAD; Pointer arithmetic within standard-layout objects; Unknown. 1315; CD4; Restrictions on non-type template arguments in partial specializations; Partial. 1316; NAD; constexpr function requirements and class scope; Unknown. 1317; NAD; Unnamed scoped enumerations; Unknown. 1318; CD3; Syntactic ambiguities with final; Unknown. 1319; NAD; Error in pack expansion example; Unknown. 1320; CD3; Converting scoped enumerations to bool; Unknown. 1321; CD3; Equivalency of dependent calls; Unknown. 1322; drafting; Function parameter type decay in templates; Not resolved. 1323; NAD; Nonexistent nonterminal in alignment-specifier grammar; Unknown. 1324; CD3; Value initialization and defaulted constructors; Unknown. 1325; NAD; Omitted declarator in friend declarations; Unknown. 1326; dup; Deducing an array bound from an initializer-list; Unknown. 1327; CD3; virt-specifier in a defaulted definition; Unknown. 1328; CD3; Conflict in reference binding vs overload resolution; Unknown. 1329; CD3; Recursive deduction substitutions; Unknown. 1330; CD3; Delayed instantiation of noexcept specifiers; Clang 4 (C++11 onwards). 1331; CD5; const mismatch with defaulted copy constructor; Unknown. 1332; CD5; Handling of invalid universal-character-names; Unknown. 1333; CD3; Omission of const in a defaulted copy constructor; Unknown. 1334; NAD; Layout compatibility and cv-qualification; Unknown. 1335; CD6; Stringizing, extended characters, and universal-character-names; Unk",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:93150,Integrability,Depend,Dependency,93150, temporary to rvalue reference; Unknown. 1377; dup; Access declarations not mentioned in Annex C; Unknown. 1378; CD5; When is an instantiation required?; Unknown. 1379; NAD; Is std::initializer_list an aggregate?; Unknown. 1380; CD3; Type definitions in template-parameter parameter-declarations; Unknown. 1381; CD3; Implicitly-declared special member functions and default nothrow; Unknown. 1382; CD3; Dead code for constructor names; Unknown. 1383; CD3; Clarifying discarded-value expressions; Unknown. 1384; NAD; reinterpret_cast in constant expressions; Unknown. 1385; CD3; Syntactic forms of conversion functions for surrogate call functions; Unknown. 1386; NAD; Explicitly-specified partial argument list with multiple parameter packs; Unknown. 1387; CD3; Missing non-deduced context for decltype; Unknown. 1388; CD3; Missing non-deduced context following a function parameter pack; Clang 4. 1389; NAD; Recursive reference in trailing-return-type; Unknown. 1390; drafting; Dependency of alias template specializations; Not resolved. 1391; CD4; Conversions to parameter types with non-deduced template arguments; Partial. 1392; CD3; Explicit conversion functions for references and non-references; Unknown. 1393; C++17; Pack expansions in using-declarations; Unknown. 1394; CD3; Incomplete types as parameters of deleted functions; Clang 15. 1395; C++17; Partial ordering of variadic templates reconsidered; Clang 16. 1396; C++23; Deferred instantiation and checking of non-static data member initializers; Unknown. 1397; CD4; Class completeness in non-static data member initializers; Clang 3.2. 1398; CD3; Non-type template parameters of type std::nullptr_t; Unknown. 1399; CD3; Deduction with multiple function parameter packs; Duplicate of 1388. 1400; NAD; Function pointer equality; Unknown. 1401; CD3; Similar types and reference compatibility; Unknown. 1402; CD3; Move functions too often deleted; Unknown. 1403; CD6; Universal-character-names in comments; Unknown. 1404; drafting; Object,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:94882,Integrability,depend,dependency,94882,tiple function parameter packs; Duplicate of 1388. 1400; NAD; Function pointer equality; Unknown. 1401; CD3; Similar types and reference compatibility; Unknown. 1402; CD3; Move functions too often deleted; Unknown. 1403; CD6; Universal-character-names in comments; Unknown. 1404; drafting; Object reallocation in unions; Not resolved. 1405; CD3; constexpr and mutable members of literal types; Unknown. 1406; CD3; ref-qualifiers and added parameters of non-static member function templates; Unknown. 1407; NAD; Integral to bool conversion in converted constant expressions; Unknown. 1408; CD3; What is “the same aggregate initialization?”; Unknown. 1409; CD3; What is the second standard conversion sequence of a list-initialization sequence?; Unknown. 1410; CD3; Reference overload tiebreakers should apply to rvalue references; Unknown. 1411; CD3; More on global scope :: in nested-name-specifier; Unknown. 1412; CD3; Problems in specifying pointer conversions; Unknown. 1413; CD3; Missing cases of value-dependency; Clang 12. 1414; drafting; Binding an rvalue reference to a reference-unrelated lvalue; Not resolved. 1415; CD3; Missing prohibition of block-scope definition of extern object; Unknown. 1416; CD3; Function cv-qualifiers and typeid; Unknown. 1417; C++14; Pointers/references to functions with cv-qualifiers or ref-qualifier; Unknown. 1418; CD3; Type of initializer_list backing array; Unknown. 1419; NAD; Evaluation order in aggregate initialization; Unknown. 1420; NAD; Abstract final classes; Unknown. 1421; NAD; Full expressions and aggregate initialization; Unknown. 1422; dup; Type of character literals containing universal-character-names; Unknown. 1423; CD3; Convertibility of nullptr to bool; Clang 11. 1424; C++14; When must sub-object destructors be accessible?; Unknown. 1425; CD3; Base-class subobjects of standard-layout structs; N/A (ABI constraint). 1426; CD5; Allowing additional parameter types in defaulted functions; Unknown. 1427; NAD; Default constructor and de,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:96898,Integrability,depend,dependent,96898,known. 1428; CD3; Dynamic const objects; Unknown. 1429; NAD; Scope of a member template's template parameter; Unknown. 1430; open; Pack expansion into fixed alias template parameter list; Not resolved. 1431; CD3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:97111,Integrability,depend,dependent,97111,3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 14,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98855,Integrability,depend,dependent,98855," constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in m",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99270,Integrability,depend,dependent,99270,"gnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception s",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99604,Integrability,depend,dependent,99604,"ct; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:100865,Integrability,depend,dependent,100865,tion; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497; NAD; Aggregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length b,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102686,Integrability,Depend,Dependent-class,102686,n conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106201,Integrability,wrap,wrapper,106201,mpty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109864,Integrability,depend,dependent,109864,"; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member i",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112505,Integrability,depend,dependent,112505,ass prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Nami,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114417,Integrability,depend,dependent,114417,ed. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specifica,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117727,Integrability,depend,dependence,117727, Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:120675,Integrability,depend,dependency,120675,umeration used as enumerator value; Unknown. 1766; CD4; Values outside the range of the values of an enumeration; Unknown. 1767; C++14; Scoped enumeration in a switch statement; Unknown. 1768; NAD; Zero-element array of runtime bound; Unknown. 1769; C++14; Catching a base class of the exception object; Unknown. 1770; C++14; Type matching of non-type template parameters and arguments; Unknown. 1771; CD6; Restricted lookup in nested-name-specifier; Unknown. 1772; C++14; __func__ in a lambda body; Clang 14. 1773; C++14; Out-of-lifetime lvalue-to-rvalue conversion; Unknown. 1774; CD4; Discrepancy between subobject destruction and stack unwinding; Unknown. 1775; C++14; Undefined behavior of line splice in raw string literal; Unknown. 1776; CD4; Replacement of class objects containing reference members; Unknown. 1777; CD4; Empty pack expansion in dynamic-exception-specification; Unknown. 1778; C++14; exception-specification in explicitly-defaulted functions; Clang 9. 1779; CD4; Type dependency of __func__; Clang 14. 1780; CD4; Explicit instantiation/specialization of generic lambda operator(); Unknown. 1781; CD5; Converting from nullptr_t to bool in overload resolution; Unknown. 1782; CD4; Form of initialization for nullptr_t to bool conversion; Unknown. 1783; NAD; Why are virtual destructors non-trivial?; Unknown. 1784; C++17; Concurrent execution during static local initialization; Unknown. 1785; NAD; Conflicting diagnostic requirements for template definitions; Unknown. 1786; C++14; Effect of merging allocations on memory leakage; Unknown. 1787; C++14; Uninitialized unsigned char values; Unknown. 1788; CD4; Sized deallocation of array of non-class type; Unknown. 1789; open; Array reference vs array decay in overload resolution; Not resolved. 1790; open; Ellipsis following function parameter pack; Not resolved. 1791; CD4; Incorrect restrictions on cv-qualifier-seq and ref-qualifier; Unknown. 1792; NAD; Incorrect example of explicit specialization of member enumeration; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:124200,Integrability,Depend,Dependent,124200,expressions; Yes. 1815; CD4; Lifetime extension in aggregate initialization; No. 1816; CD4; Unclear specification of bit-field values; Unknown. 1817; drafting; Linkage specifications and nested scopes; Not resolved. 1818; CD6; Visibility and inherited language linkage; Unknown. 1819; CD4; Acceptable scopes for definition of partial specialization; Unknown. 1820; CD6; Qualified typedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:124576,Integrability,Depend,Dependent,124576,ypedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125034,Integrability,inject,injected-class-name,125034,stant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125112,Integrability,depend,dependency,125112,mbiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not r,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128370,Integrability,depend,depending,128370,eordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128941,Integrability,depend,dependent,128941, requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:129379,Integrability,Depend,Dependent,129379,ember function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:129399,Integrability,inject,injected-class-names,129399,ember function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130243,Integrability,depend,dependent,130243,ed by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NA,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130534,Integrability,Inject,Injected,130534,; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from l,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131463,Integrability,Depend,Dependent,131463,nt of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion seq,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135051,Integrability,depend,dependent,135051,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135069,Integrability,depend,dependent,135069,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:136448,Integrability,depend,dependent,136448,explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspecified; Unknown. 2002; open; White space within preprocessing directives; Not resolved. 2003; drafting; Zero-argument macros incorrectly specified; Not resolved. 2004; CD4; Unions with mutable members in constant expressions; Unknown. 2005; NAD; Incorrect constexpr reference initialization requirements; Unknown. 2006; CD4; Cv-qualified void types; Unknown. 2007; CD6; Argument-dependent lookup for operator=; Clang 3.4. 2008; CD4; Default template-arguments underspecified; Unknown. 2009; CD6; Unclear specification of class scope; N/A. 2010; CD4; exception-specifications and conversion operators; Unknown. 2011; C++17; Unclear effect of reference capture of reference; Unknown. 2012; CD4; Lifetime of references; Unknown. 2013; drafting; Pointer subtraction in large array; Not resolved. 2014; NAD; Unneeded deallocation signatures; Unknown. 2015; CD4; odr-use of deleted virtual functions; Unknown. 2016; CD4; Confusing wording in description of conversion function; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy eli,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:137595,Integrability,Depend,Dependent,137595,; exception-specifications and conversion operators; Unknown. 2011; C++17; Unclear effect of reference capture of reference; Unknown. 2012; CD4; Lifetime of references; Unknown. 2013; drafting; Pointer subtraction in large array; Not resolved. 2014; NAD; Unneeded deallocation signatures; Unknown. 2015; CD4; odr-use of deleted virtual functions; Unknown. 2016; CD4; Confusing wording in description of conversion function; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138023,Integrability,inject,injected-class-name,138023,n; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140284,Integrability,depend,dependent,140284,itializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not reso,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140416,Integrability,depend,dependent,140416,s rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with em,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140438,Integrability,depend,dependent,140438,s rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with em,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140696,Integrability,depend,dependent,140696,ved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140966,Integrability,depend,dependence,140966,es; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142149,Integrability,Depend,Dependency,142149,tor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142168,Integrability,depend,dependent,142168,tor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142844,Integrability,depend,dependent,142844,ting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142965,Integrability,depend,dependence,142965, of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:143564,Integrability,depend,dependence,143564,. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,Integrability,inject,injection,144268,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145446,Integrability,depend,dependent,145446,; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145959,Integrability,depend,dependency,145959,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145974,Integrability,inject,injected-class-name,145974,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:148418,Integrability,depend,dependent,148418,"eclarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not resolved. 2174; C++17; Unclear rules for friend definitions in templates; Unknown. 2175; CD4; Ambiguity with attribute in conversion operator declaration; Unknown. 2176; CD4; Destroying the returned object when a destructor throws; Unknown. 2177; CD5; Placement operator delete and parameter copies; Unknown. 2178; NAD; Substitution of dependent template arguments in default template arguments; Unknown. 2179; drafting; Required diagnostic for partial specialization after first use; Not resolved. 2180; CD4; Virtual bases in destructors and defaulted assignment operators; Yes. 2181; drafting; Normative requirements in an informative Annex; Not resolved. 2182; drafting; Pointer arithmetic in array-like containers; Not resolved. 2183; NAD; Problems in description of potential exceptions; Unknown. 2184; CD4; Missing C compatibility entry for decrement of bool; Unknown. 2185; CD6; Cv-qualified numeric types; Unknown. 2186; drafting; Unclear point that “preceding initialization” must precede; Not resolved. 2187; drafting; Protected members and access via qualified-id; Not resolved. 2188; open; empty-declaration grammar ambiguity; Not resolved. 2189; open; Surrogate call template; Not resolved. 2190; open; Insufficient specification of __has_include; Not resolved. 2191; C++17; Incorrect result for noexcept(typeid(v)); Unknown. 2192; open; Const",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152286,Integrability,depend,dependent,152286,"x variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and i",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152369,Integrability,depend,dependent,152369,"cts; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154423,Integrability,depend,dependent,154423,nown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a us,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154449,Integrability,depend,dependent,154449,nown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a us,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155072,Integrability,depend,dependence,155072,of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniq,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155132,Integrability,Depend,Dependent,155132, asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specif,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155169,Integrability,depend,dependence,155169, asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specif,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156480,Integrability,Depend,Dependent,156480,1; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambd,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159231,Integrability,inject,injected-class-name,159231, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163193,Integrability,contract,contract-attribute-specifiers,163193,D; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:164467,Integrability,depend,dependent,164467, 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402; CD6; When is the restriction to a single c-char in a Unicode literal enforced?; Unknown. 2403; drafting; Temporary materialization and base/member initialization; Not resolved. 2404; CD5; [[no_unique_address]] and allocation order; Unknown. 2405; CD6; Additional type-dependent expressions; Unknown. 2406; CD5; [[fallthrough]] attribute and iteration statements; Clang 5. 2407; C++23; Missing entry in Annex C for defaulted comparison operators; Unknown. 2408; NAD; Temporaries and previously-initialized elements in aggregate initialization; Unknown. 2409; drafting; Explicit specializations of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “u,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:167433,Integrability,depend,dependency,167433,ries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Te,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:168309,Integrability,depend,dependent,168309,pressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Template parameter initialization; Clang 18. 2460; CD6; C language linkage and constrained non-template friends; Unknown. 2461; CD6; Diagnosing non-bool type constraints; Unknown. 2462; drafting; Problems with the omission of the typename keyword; Not resolved. 2463; open; Trivial copyability and unions with non-trivial members; Not resolved. 2464; CD6; Constexpr launder and unions; Unknown. 2465; CD6; Coroutine parameters passed to a promise constructor; Unknown. 2466; CD6; co_await should be a single evaluation; Unknown. 2467; drafting; CTAD for alias templates and the deducible check; Not resolved. 2468; drafting; Omission of the typename keyword in a member template parameter list; Not resolved. 2469; drafting; Implicit object creation vs constant expressions; Not resolved. 2470; CD6; Multiple array objects providing storage for one obje,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:170448,Integrability,depend,dependence,170448,uctor calls; Not resolved. 2474; CD6; Cv-qualification and deletion; Unknown. 2475; C++23; Object declarations of type cv void; Unknown. 2476; tentatively ready; placeholder-type-specifiers and function declarators; Unknown. 2477; CD6; Defaulted vs deleted copy constructors/assignment operators; Unknown. 2478; C++23; Properties of explicit specializations of implicitly-instantiated class templates; Unknown. 2479; CD6; Missing specifications for consteval and constinit; Unknown. 2480; drafting; Lookup for enumerators in modules; Not resolved. 2481; CD6; Cv-qualification of temporary to which a reference is bound; Unknown. 2482; CD6; bit_cast and indeterminate values; Unknown. 2483; C++23; Language linkage of static member functions; Unknown. 2484; CD6; char8_t and char16_t in integral promotions; Unknown. 2485; DRWP; Bit-fields in integral promotions; Unknown. 2486; CD6; Call to noexcept function via noexcept(false) pointer/lvalue; Unknown. 2487; drafting; Type dependence of function-style cast to incomplete array type; Not resolved. 2488; open; Overloading virtual functions and functions with trailing requires-clauses; Not resolved. 2489; C++23; Storage provided by array of char; Unknown. 2490; CD6; Restrictions on destruction in constant expressions; Unknown. 2491; CD6; Export of typedef after its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expression,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:179153,Integrability,depend,dependency,179153,"dule linkage; Not resolved. 2589; review; Context of access checks during constraint satisfaction checking; Not resolved. 2590; C++23; Underlying type should determine size and alignment requirements of an enum; Unknown. 2591; DR; Implicit change of active union member for anonymous union in union; Unknown. 2592; open; Missing definition for placement allocation/deallocation function; Not resolved. 2593; review; Insufficient base class restriction for pointer-to-member expression; Not resolved. 2594; CD6; Disallowing a global function template main; Unknown. 2595; DR; ""More constrained"" for eligible special member functions; Unknown. 2596; drafting; Instantiation of constrained non-template friends; Not resolved. 2597; CD6; Replaceable allocation and deallocation functions in the global module; Unknown. 2598; C++23; Unions should not require a non-static data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribut",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181772,Integrability,Inject,Injected-class-name,181772,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:189944,Integrability,Depend,Dependent,189944,"; Unknown. 2733; DR; Applying [[maybe_unused]] to a label; Unknown. 2734; open; Immediate forward-declared function templates; Not resolved. 2735; open; List-initialization and conversions in overload resolution; Not resolved. 2736; open; Standard layout class with empty base class also in first member; Not resolved. 2737; open; Temporary lifetime extension for reference init-captures; Not resolved. 2738; review; ""denotes a destructor"" is missing specification; Not resolved. 2739; open; Nested requirement not a constant expression; Not resolved. 2740; open; Too many objects have constexpr-unknown type; Not resolved. 2741; open; Implicit conversion sequence from empty list to array of unknown bound; Not resolved. 2742; open; Guaranteed copy elision for brace-initialization from prvalue; Not resolved. 2743; open; Copying non-trivial objects nested within a union; Not resolved. 2744; open; Multiple objects of the same type at the same address; Not resolved. 2745; open; Dependent odr-use in generic lambdas; Not resolved. 2746; open; Checking of default template arguments; Not resolved. 2747; DR; Cannot depend on an already-deleted splice; Unknown. 2748; tentatively ready; Accessing static data members via null pointer; Unknown. 2749; DR; Treatment of ""pointer to void"" for relational comparisons; Unknown. 2750; DRWP; construct_at without constructor call; Unknown. 2751; NAD; Order of destruction for parameters for operator functions; Unknown. 2752; open; Excess-precision floating-point literals; Not resolved. 2753; DR; Storage reuse for string literal objects and backing arrays; Unknown. 2754; DR; Using *this in explicit object member functions that are coroutines; Unknown. 2755; DR; Incorrect wording applied by P2738R1; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 27",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:190079,Integrability,depend,depend,190079,"t resolved. 2735; open; List-initialization and conversions in overload resolution; Not resolved. 2736; open; Standard layout class with empty base class also in first member; Not resolved. 2737; open; Temporary lifetime extension for reference init-captures; Not resolved. 2738; review; ""denotes a destructor"" is missing specification; Not resolved. 2739; open; Nested requirement not a constant expression; Not resolved. 2740; open; Too many objects have constexpr-unknown type; Not resolved. 2741; open; Implicit conversion sequence from empty list to array of unknown bound; Not resolved. 2742; open; Guaranteed copy elision for brace-initialization from prvalue; Not resolved. 2743; open; Copying non-trivial objects nested within a union; Not resolved. 2744; open; Multiple objects of the same type at the same address; Not resolved. 2745; open; Dependent odr-use in generic lambdas; Not resolved. 2746; open; Checking of default template arguments; Not resolved. 2747; DR; Cannot depend on an already-deleted splice; Unknown. 2748; tentatively ready; Accessing static data members via null pointer; Unknown. 2749; DR; Treatment of ""pointer to void"" for relational comparisons; Unknown. 2750; DRWP; construct_at without constructor call; Unknown. 2751; NAD; Order of destruction for parameters for operator functions; Unknown. 2752; open; Excess-precision floating-point literals; Not resolved. 2753; DR; Storage reuse for string literal objects and backing arrays; Unknown. 2754; DR; Using *this in explicit object member functions that are coroutines; Unknown. 2755; DR; Incorrect wording applied by P2738R1; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192246,Integrability,depend,dependence,192246,orability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment functi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:193088,Integrability,depend,dependence,193088," linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert m",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194101,Integrability,message,message,194101," DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; C",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:5664,Modifiability,variab,variables,5664,"; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expression; N/A. 68; TC1; Grammar does not allow ""friend class A<int>;""; Clang 2.8. 69; TC1; Storage class specifiers on template declarations; Clang 9. 70; CD1; Is an array bound a nondeduced context?; Yes. 71; NAD; Incorrect cross reference; N/A. 72; dup; Linkage and storage class specifiers for templates; Duplicate of 69. 73; TC1; Pointer equality; Superseded by 1652. 74; TC1; Enumeration value in direct-new-declarator; Yes. 75; TC1; In-class initialized members must be const; Yes. 76; TC1; Are const volatile variables considered ""constant expressions""?; Yes. 77; CD1; The definition of friend does not allow nested classes to be friends; Yes. 78; CD1; Section 8.5 paragraph 9 should state it only applies to non-static objects; Superseded by ????. 79; dup; Alignment and placement new; N/A. 80; TC1; Class members with same name as class; Clang 2.9. 81; NAD; Null pointers and C compatibility; N/A. 82; dup; Definition of ""using"" a constant expression; Duplicate of 48. 83; TC1; Overloading and deprecated conversion of string literal; Yes. 84; TC1; Overloading and conversion loophole used by auto_ptr; Yes. 85; TC1; Redeclaration of member class; Clang 3.4. 86; CD1; Lifetime of temporaries in query expressions; Duplicate of 446. 87; CD1; Exception specifications on function parameters; No. 88; NAD; Specialization of member constant templates; Clang 2.8. 89; TC1; Object lifetime does not account for reference rebinding; N/A. 90; TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A unio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7565,Modifiability,extend,extended-namespace-definition,7565,"TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A union's associated types should include the union itself; Yes. 92; CD4; Should exception-specifications be part of the type system?; Clang 4 (C++17 onwards). 93; TC1; Missing word in 3.8 basic.life paragraph 2; N/A. 94; TC1; Inconsistencies in the descriptions of constant expressions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9249,Modifiability,variab,variables,9249,; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:22814,Modifiability,variab,variable,22814,"te of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization examples are still incorrect; Yes. 337; CD1; Attempt to create array of abtract type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:28822,Modifiability,variab,variables,28822,"Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instantiation; Yes. 416; CD1; Class must be complete to allow operator lookup?; Yes. 417; CD1; Using derived-class qualified name in out-of-class nested class definition; No. 418; CD6; Imperfect wording on error on multiple default arguments on a called function; No. 419; open; Can cast to virtual base class be done on partially-constructed object?; Not resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31199,Modifiability,variab,variable,31199,"of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conf",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31277,Modifiability,variab,variables,31277,"ime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across p",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31939,Modifiability,variab,variable,31939,of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Quali,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32202,Modifiability,inherit,inherited,32202,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32286,Modifiability,inherit,inheritance,32286,ariables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Operator overloading in constant expressions; Yes. 488; CD1; Local types,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34494,Modifiability,variab,variable,34494,; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma follo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:42096,Modifiability,variab,variables,42096,Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:43197,Modifiability,variab,variables,43197,-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632; CD1; Brace-enclosed initializer for scalar member of aggregate; Yes. 633; CD2; Specifications for variables that should also apply to references; N/A. 634; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis redux; Yes. 635; NAD; Names of constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:44360,Modifiability,extend,extended,44360, constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr instances of constexpr constructor templates; Clang 3.1. 648; CD1; Constant expressions in constexpr initializers; Yes. 649; CD1; Optionally ill-formed extended alignment requests; Clang 3.5. 650; CD2; Order of destruction for temporaries bound to the returned value of a function; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Conversions to and from nullptr_t; Superseded by 1423. 655; C++11; Initialization not specified for forwarding constructors; Yes. 656; CD2; Direct binding to the result of a conversion operator; Yes. 657; CD2; Abstract class parameter in synthesized declaration; Partial. 658; CD2; Defining reinterpret_cast for pointer types; Unknown. 659; CD1; Alignment of function types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:46913,Modifiability,variab,variable,46913,coped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types and the ODR; Unknown. 679; CD1; Equivalence of template-ids and operator function templates; Yes. 680; CD2; What is a move constructor?; N/A. 681; CD1; Restrictions on declarators with late-specified return types; Partial. 682; CD5; Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/definitions in type-specifier-seqs and type-ids; Clang 3.0. 687; NAD; template keyword with unqualified-ids; Unknown. 688; CD1; Constexpr constructors and static initialization; Unknown. 689; CD5; Maximum values of signed and unsigned integers; Unknown. 690; CD2; The dynamic type of an rvalue reference; Unknown. 691; C++11; Template parameter packs in class template partial specializations; Unknown. 692; C++11; Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49601,Modifiability,variab,variable,49601,"nknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by th",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50355,Modifiability,variab,variables,50355,"d_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:52305,Modifiability,variab,variables,52305,"alifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure object call operator; Unknown. 762; CD2; Name lookup in the compound-statement of a lambda expression; Unknown. 763; CD2; Is a closure object's operator() inline?; Unknown. 764; CD2; Capturing unused variables in a lambda expression; Unknown. 765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknow",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55127,Modifiability,variab,variables,55127,known. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57306,Modifiability,extend,extended,57306, Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing buil,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59149,Modifiability,extend,extended,59149, rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing built-in comparison operators for pointer types; Unknown. 880; CD2; Built-in conditional operator for scoped enumerations; Unknown. 882; CD2; Defining main as deleted; Unknown. 883; CD2; std::memcpy vs std::memmove; Unknown. 884; CD2; Defining an explicitly-specialized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functio,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65223,Modifiability,Inherit,Inheriting,65223,2; Incorrect specification for copy initialization; Unknown. 979; CD2; Position of attribute-specifier in declarator syntax; Unknown. 980; CD2; Explicit instantiation of a member of a class template; Unknown. 981; C++11; Constexpr constructor templates and literal types; Unknown. 982; NAD; Initialization with an empty initializer list; Unknown. 983; CD2; Ambiguous pointer-to-member constant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of c,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67463,Modifiability,variab,variable,67463,"e declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:70512,Modifiability,inherit,inheritance,70512,"ODness; Unknown. 1053; NAD; Terminate vs undefined behavior for noexcept violation; Unknown. 1054; C++11; Lvalue-to-rvalue conversions in expression statements; No. 1055; C++11; Permissible uses of void; Unknown. 1056; C++11; Template aliases, member definitions, and the current instantiation; Unknown. 1057; C++11; decltype and the current instantiation; Unknown. 1058; NAD; Reference binding of incompatible array types; Unknown. 1059; CD3; Cv-qualified array types (with rvalues); Unknown. 1060; C++11; Scoped enumerators in integral constant expressions; Unknown. 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between te",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:73709,Modifiability,variab,variables,73709,pressions; Unknown. 1099; C++11; Infinite recursion in constexpr functions; Unknown. 1100; C++11; constexpr conversion functions and non-type template arguments; Unknown. 1101; C++11; Non-integral initialized static data members; Unknown. 1102; C++11; Better example of undefined behavior; Unknown. 1103; C++11; Reversion of phase 1 and 2 transformations in raw string literals; Unknown. 1104; C++11; Global-scope template arguments vs the <: digraph; Unknown. 1105; C++11; Issues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:76341,Modifiability,Inherit,Inheriting,76341,1136; C++11; Explicitly-defaulted explicit constructors; Unknown. 1137; C++11; Explicitly-defaulted virtual special member functions; Unknown. 1138; C++11; Rvalue-ness check for rvalue reference binding is wrong; Unknown. 1139; C++11; Rvalue reference binding to scalar xvalues; Unknown. 1140; C++11; Incorrect redefinition of POD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:76687,Modifiability,variab,variable,76687,OD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:89253,Modifiability,extend,extended,89253,"ol; Unknown. 1321; CD3; Equivalency of dependent calls; Unknown. 1322; drafting; Function parameter type decay in templates; Not resolved. 1323; NAD; Nonexistent nonterminal in alignment-specifier grammar; Unknown. 1324; CD3; Value initialization and defaulted constructors; Unknown. 1325; NAD; Omitted declarator in friend declarations; Unknown. 1326; dup; Deducing an array bound from an initializer-list; Unknown. 1327; CD3; virt-specifier in a defaulted definition; Unknown. 1328; CD3; Conflict in reference binding vs overload resolution; Unknown. 1329; CD3; Recursive deduction substitutions; Unknown. 1330; CD3; Delayed instantiation of noexcept specifiers; Clang 4 (C++11 onwards). 1331; CD5; const mismatch with defaulted copy constructor; Unknown. 1332; CD5; Handling of invalid universal-character-names; Unknown. 1333; CD3; Omission of const in a defaulted copy constructor; Unknown. 1334; NAD; Layout compatibility and cv-qualification; Unknown. 1335; CD6; Stringizing, extended characters, and universal-character-names; Unknown. 1336; CD3; Definition of “converting constructor”; Unknown. 1337; dup; Partial ordering and non-deduced parameters; Unknown. 1338; CD4; Aliasing and allocation functions; Unknown. 1339; NAD; Parenthesized braced-init-list and arrays; Unknown. 1340; CD3; Complete type in member pointer expressions; Unknown. 1341; NAD; Bit-field initializers; Superseded by P0683R1. 1342; CD6; Order of initialization with multiple declarators; Unknown. 1343; C++17; Sequencing of non-class initialization; Unknown. 1344; C++14; Adding new special member functions to a class via default arguments; Unknown. 1345; CD3; Initialization of anonymous union class members; Unknown. 1346; CD3; expression-list initializers and the auto specifier; Clang 3.5. 1347; CD3; Consistency of auto in multiple-declarator declarations; Clang 3.1. 1348; drafting; Use of auto in a trailing-return-type; Not resolved. 1349; dup; Consistency of alias template redeclarations; Unknown. 1350; CD",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:90312,Modifiability,inherit,inherited,90312,; Unknown. 1336; CD3; Definition of “converting constructor”; Unknown. 1337; dup; Partial ordering and non-deduced parameters; Unknown. 1338; CD4; Aliasing and allocation functions; Unknown. 1339; NAD; Parenthesized braced-init-list and arrays; Unknown. 1340; CD3; Complete type in member pointer expressions; Unknown. 1341; NAD; Bit-field initializers; Superseded by P0683R1. 1342; CD6; Order of initialization with multiple declarators; Unknown. 1343; C++17; Sequencing of non-class initialization; Unknown. 1344; C++14; Adding new special member functions to a class via default arguments; Unknown. 1345; CD3; Initialization of anonymous union class members; Unknown. 1346; CD3; expression-list initializers and the auto specifier; Clang 3.5. 1347; CD3; Consistency of auto in multiple-declarator declarations; Clang 3.1. 1348; drafting; Use of auto in a trailing-return-type; Not resolved. 1349; dup; Consistency of alias template redeclarations; Unknown. 1350; CD3; Incorrect exception specification for inherited constructors; Clang 3.5. 1351; CD4; Problems with implicitly-declared exception-specifications; Unknown. 1352; CD3; Inconsistent class scope and completeness rules; Unknown. 1353; DRWP; Array and variant members and deleted special member functions; Unknown. 1354; CD3; Destructor exceptions for temporaries in noexcept expressions; Unknown. 1355; CD3; Aggregates and “user-provided” constructors; Unknown. 1356; CD4; Exception specifications of copy assignment operators with virtual bases; Unknown. 1357; CD3; brace-or-equal-initializers for function and typedef members; Unknown. 1358; CD3; Unintentionally ill-formed constexpr function template instances; Clang 3.1. 1359; CD3; constexpr union constructors; Clang 3.5. 1360; CD6; constexpr defaulted default constructors; Unknown. 1361; CD3; Requirement on brace-or-equal-initializers of literal types; Unknown. 1362; CD3; Complete type required for implicit conversion to T&; Unknown. 1363; CD3; Triviality vs multiple default,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98912,Modifiability,variab,variables,98912,"address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; Whe",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99911,Modifiability,inherit,inheriting,99911, Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497; NAD; Aggregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101617,Modifiability,variab,variables,101617,gregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Arr,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102894,Modifiability,variab,variable,102894,lo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage o,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:105619,Modifiability,Inherit,Inheriting,105619,t resolved. 1555; NAD; Language linkage and function type compatibility; Unknown. 1556; CD3; Constructors and explicit conversion functions in direct initialization; Unknown. 1557; CD3; Language linkage of converted lambda function pointer; Unknown. 1558; CD4; Unused arguments in alias template specializations; Clang 12. 1559; CD3; String too long in initializer list of new-expression; Unknown. 1560; CD3; Gratuitous lvalue-to-rvalue conversion in conditional-expression with throw-expression operand; Clang 3.5. 1561; CD4; Aggregates with empty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When ar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106096,Modifiability,Inherit,Inherited,106096,on with throw-expression operand; Clang 3.5. 1561; CD4; Aggregates with empty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109025,Modifiability,variab,variables,109025,"enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109358,Modifiability,extend,extended,109358,"mment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:111136,Modifiability,inherit,inheriting,111136,"zer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member initializer; Unknown. 1642; DRWP; Missing requirements for prvalue operands; Unknown. 1643; NAD; Default arguments for template parameter packs; Unknown. 1644; NAD; Equivalent exception-specifications in function template declarations; Unknown. 1645; CD4; Identical inheriting constructors via default arguments; Clang 3.9. 1646; CD5; decltype-specifiers, abstract classes, and deduction failure; Unknown. 1647; drafting; Type agreement of non-type template arguments in partial specializations; Not resolved. 1648; C++14; thread_local vs block extern declarations; Unknown. 1649; C++14; Error in the syntax of mem-initializer-list; Unknown. 1650; NAD; Class prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114096,Modifiability,variab,variables,114096,ng 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs se,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114248,Modifiability,variab,variables,114248,eduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115374,Modifiability,variab,variable,115374,namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning e,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115884,Modifiability,variab,variable,115884,; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115957,Modifiability,variab,variable,115957, its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 17,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116020,Modifiability,variab,variable,116020,reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknow,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116142,Modifiability,inherit,inherited,116142,esolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117005,Modifiability,variab,variable,117005, 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexce,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117083,Modifiability,variab,variable,117083,AD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue con,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117163,Modifiability,variab,variable,117163,d constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117214,Modifiability,variab,variable,117214,luated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered init,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117647,Modifiability,Inherit,Inheriting,117647,oexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-tr,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117851,Modifiability,inherit,inheriting,117851,return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier o,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:118245,Modifiability,variab,variable,118245,d type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier of destructor; Clang 11. 1754; NAD; Declaration of partial specialization of static data member template; Unknown. 1755; drafting; Out-of-class partial specializations of member templates; Not resolved. 1756; CD4; Direct-list-initialization of a non-class object; Clang 3.7. 1757; CD4; Const integral subobjects; Unknown. 1758; CD4; Explicit conversion in copy/move list initialization; Clang 3.7. 1759,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:118323,Modifiability,variab,variable,118323,special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier of destructor; Clang 11. 1754; NAD; Declaration of partial specialization of static data member template; Unknown. 1755; drafting; Out-of-class partial specializations of member templates; Not resolved. 1756; CD4; Direct-list-initialization of a non-class object; Clang 3.7. 1757; CD4; Const integral subobjects; Unknown. 1758; CD4; Explicit conversion in copy/move list initialization; Clang 3.7. 1759; C++14; UTF-8 code units in plain char; Unknown. 1760; C++14; Access,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:123452,Modifiability,inherit,inherited,123452, as member-declaration; Clang 2.9. 1804; CD4; Partial specialization and friendship; Clang 2.7. 1805; CD4; Conversions of array operands in conditional-expressions; Unknown. 1806; CD4; Virtual bases and move-assignment; Unknown. 1807; CD4; Order of destruction of array elements after an exception; Clang 3.0. 1808; drafting; Constructor templates vs default constructors; Not resolved. 1809; CD4; Narrowing and template argument deduction; Unknown. 1810; CD4; Invalid ud-suffixes; Unknown. 1811; CD4; Lookup of deallocation function in a virtual destructor definition; Unknown. 1812; C++17; Omission of template in a typename-specifier; No. 1813; CD4; Direct vs indirect bases in standard-layout classes; Clang 7. 1814; CD4; Default arguments in lambda-expressions; Yes. 1815; CD4; Lifetime extension in aggregate initialization; No. 1816; CD4; Unclear specification of bit-field values; Unknown. 1817; drafting; Linkage specifications and nested scopes; Not resolved. 1818; CD6; Visibility and inherited language linkage; Unknown. 1819; CD4; Acceptable scopes for definition of partial specialization; Unknown. 1820; CD6; Qualified typedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125313,Modifiability,variab,variable,125313,eted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125597,Modifiability,Variab,Variable,125597,nknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer a,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130503,Modifiability,variab,variables,130503,ation; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qual,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131817,Modifiability,inherit,inherited,131817,ime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:132873,Modifiability,variab,variables,132873,ng 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and ope,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:133053,Modifiability,inherit,inherited,133053,arations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant spe,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134656,Modifiability,extend,extending,134656,expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135290,Modifiability,Inherit,Inheriting,135290,olved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspecified; Unknown. 2002; open; White space within preprocessing directives; Not resolved. 2003; drafting; Zero-argument macros incorrectly specified; Not resolved. 2004; CD4; Unions with mutable members in constant expressions; Unknown. 2005; N,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138170,Modifiability,variab,variable,138170,n vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specificat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138398,Modifiability,Refactor,Refactoring,138398,lias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simpli,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144466,Modifiability,flexible,flexible,144466,versions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initial,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144602,Modifiability,variab,variables,144602,cified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit mem,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144757,Modifiability,extend,extended,144757,5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:146029,Modifiability,variab,variable,146029,r-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not r,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:146993,Modifiability,Polymorphi,Polymorphic,146993,"rafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not resolved. 2159; NAD; Lambda capture and local thread_local variables; Unknown. 2160; open; Issues with partial ordering; Not resolved. 2161; NAD; Explicit instantiation declaration and “preceding initialization”; Unknown. 2162; CD3; Capturing this by reference; Unknown. 2163; CD4; Labels in constexpr functions; Unknown. 2164; CD5; Name hiding and using-directives; Unknown. 2165; CD6; Namespaces, declarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolv",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:147097,Modifiability,variab,variables,147097,"CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not resolved. 2159; NAD; Lambda capture and local thread_local variables; Unknown. 2160; open; Issues with partial ordering; Not resolved. 2161; NAD; Explicit instantiation declaration and “preceding initialization”; Unknown. 2162; CD3; Capturing this by reference; Unknown. 2163; CD4; Labels in constexpr functions; Unknown. 2164; CD5; Name hiding and using-directives; Unknown. 2165; CD6; Namespaces, declarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151282,Modifiability,variab,variable,151282,"ictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-d",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:153169,Modifiability,variab,variable,153169,"Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154925,Modifiability,Inherit,Inheriting,154925,mbiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvert,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155211,Modifiability,inherit,inheriting,155211,r friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unkn,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157136,Modifiability,inherit,inheritance,157136,nknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Sel,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157276,Modifiability,variab,variable,157276,ion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; draf,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157854,Modifiability,variab,variables,157854,constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initializat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159096,Modifiability,variab,variable,159096,Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160245,Modifiability,variab,variables,160245,own. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ s,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160718,Modifiability,Extend,Extended,160718,"rspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unknown. 2366; CD5; Can default initialization be constant initialization?; Unknown. 2367; NAD; Lambdas in default arguments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering b",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160887,Modifiability,inherit,inherited,160887,"resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unknown. 2366; CD5; Can default initialization be constant initialization?; Unknown. 2367; NAD; Lambdas in default arguments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering between constraints and substitution; Unknown. 2370; CD6; friend declarations of namespace-scope functions; No. 2371; CD5; Use",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163137,Modifiability,variab,variable,163137,specification of enum direct-list-initialization; Unknown. 2375; NAD; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163290,Modifiability,variab,variable,163290, CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402; CD6; When is the restriction to a single c-char in a Unicode literal enfor,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166265,Modifiability,variab,variables,166265,"nknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166536,Modifiability,Variab,Variable,166536,"ng pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:171764,Modifiability,Inherit,Inheriting,171764," its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expressions; Extension. 2501; drafting; Explicit instantiation and trailing requires-clauses; Not resolved. 2502; CD6; Unintended declaration conflicts in nested statement scopes; Unknown. 2503; drafting; Unclear relationship among name, qualified name, and unqualified name; Not resolved. 2504; DR; Inheriting constructors from virtual base classes; Unknown. 2505; drafting; Nested unnamed namespace of inline unnamed namespace; Not resolved. 2506; CD6; Structured bindings and array cv-qualifiers; Unknown. 2507; CD6; Default arguments for operator[]; Unknown. 2508; C++23; Restrictions on uses of template parameter names; Unknown. 2509; CD6; decl-specifier-seq in lambda-specifiers; Unknown. 2510; NAD; noexcept-specifier of friend function vs class completeness; Unknown. 2511; CD6; cv-qualified bit-fields; Unknown. 2512; NAD; typeid and incomplete class types; Unknown. 2513; open; Ambiguity with requires-clause and operator-function-id; Not resolved. 2514; open; Modifying const subobjects; Not resolved. 2515; open; Result of a function call; Not resolved. 2516; C++23; Locus of enum-specifier or opaque-enum-declaration; Clang 3.0. 2517; C++23; Useless restriction on use of parameter in constraint-expression; Unknown. 2518; C++23; Conformance requirements and #error/#warning; Clang 17. 2519; DRWP; Object repre",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:174018,Modifiability,variab,variables,174018,"espace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175328,Modifiability,variab,variable,175328,"40; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not res",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181181,Modifiability,Variab,Variables,181181,ise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unk,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186308,Modifiability,extend,extended,186308,"egate CTAD, string, and brace elision; Unknown. 2686; open; Pack expansion into a non-pack parameter of a concept; Not resolved. 2687; C++23; Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186555,Modifiability,inherit,inheritance,186555," Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:191705,Modifiability,variab,variable,191705,"; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; Unknown. 2761; DR; Implicitly invoking the deleted destructor of an anonymous union member; Unknown. 2762; DR; Type of implicit object parameter; Unknown. 2763; DR; Ignorability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; r",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194136,Modifiability,Inherit,Inheriting,194136,"ing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alig",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194221,Modifiability,variab,variables,194221,"ect copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolv",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194566,Modifiability,rewrite,rewrite,194566,"g to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196668,Modifiability,variab,variables,196668,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196945,Modifiability,extend,extended,196945,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:197020,Modifiability,inherit,inheriting,197020,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:806,Performance,optimiz,optimization,806,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65280,Performance,perform,perform,65280,D2; Position of attribute-specifier in declarator syntax; Unknown. 980; CD2; Explicit instantiation of a member of a class template; Unknown. 981; C++11; Constexpr constructor templates and literal types; Unknown. 982; NAD; Initialization with an empty initializer list; Unknown. 983; CD2; Ambiguous pointer-to-member constant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:81076,Performance,multi-thread,multi-threaded,81076,ialized static data members; Unknown. 1204; C++11; Specifiers in a for-range-declaration; Unknown. 1205; dup; Lvalue reference binding and function viability; Unknown. 1206; C++11; Defining opaque enumeration members of class templates; Unknown. 1207; C++11; Type of class member in trailing-return-type; Unknown. 1208; C++11; Explicit noexcept in defaulted definition; Unknown. 1209; open; Is a potentially-evaluated expression in a template definition a “use?”; Not resolved. 1210; C++11; Injection of elaborated-type-specifier in enumeration scope; Unknown. 1211; drafting; Misaligned lvalues; Not resolved. 1212; C++11; Non-function-call xvalues and decltype; Unknown. 1213; CD3; Array subscripting and xvalues; Clang 7. 1214; C++11; Kinds of initializers; Unknown. 1215; C++11; Definition of POD struct; Unknown. 1216; C++11; Exceptions “allowed” by a noexcept-specification; Unknown. 1217; NAD; Are deleted functions implicitly noexcept?; Unknown. 1218; C++11; What is the “currently-handled exception” in a multi-threaded program?; Unknown. 1219; C++11; Non-static data member initializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creati,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:121027,Performance,Concurren,Concurrent,121027,rs and arguments; Unknown. 1771; CD6; Restricted lookup in nested-name-specifier; Unknown. 1772; C++14; __func__ in a lambda body; Clang 14. 1773; C++14; Out-of-lifetime lvalue-to-rvalue conversion; Unknown. 1774; CD4; Discrepancy between subobject destruction and stack unwinding; Unknown. 1775; C++14; Undefined behavior of line splice in raw string literal; Unknown. 1776; CD4; Replacement of class objects containing reference members; Unknown. 1777; CD4; Empty pack expansion in dynamic-exception-specification; Unknown. 1778; C++14; exception-specification in explicitly-defaulted functions; Clang 9. 1779; CD4; Type dependency of __func__; Clang 14. 1780; CD4; Explicit instantiation/specialization of generic lambda operator(); Unknown. 1781; CD5; Converting from nullptr_t to bool in overload resolution; Unknown. 1782; CD4; Form of initialization for nullptr_t to bool conversion; Unknown. 1783; NAD; Why are virtual destructors non-trivial?; Unknown. 1784; C++17; Concurrent execution during static local initialization; Unknown. 1785; NAD; Conflicting diagnostic requirements for template definitions; Unknown. 1786; C++14; Effect of merging allocations on memory leakage; Unknown. 1787; C++14; Uninitialized unsigned char values; Unknown. 1788; CD4; Sized deallocation of array of non-class type; Unknown. 1789; open; Array reference vs array decay in overload resolution; Not resolved. 1790; open; Ellipsis following function parameter pack; Not resolved. 1791; CD4; Incorrect restrictions on cv-qualifier-seq and ref-qualifier; Unknown. 1792; NAD; Incorrect example of explicit specialization of member enumeration; Unknown. 1793; CD4; thread_local in explicit specializations; Unknown. 1794; C++17; template keyword and alias templates; Yes. 1795; CD4; Disambiguating original-namespace-definition and extension-namespace-definition; Unknown. 1796; CD4; Is all-bits-zero for null characters a meaningful requirement?; Unknown. 1797; CD4; Are all bit patterns of unsigned char distinct ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:133193,Performance,concurren,concurrent,133193,; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:174567,Performance,optimiz,optimized,174567,"ences; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration preven",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50419,Safety,safe,safely-derived,50419,n. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:54462,Safety,Safe,Safely-derived,54462,; Unknown. 785; CD2; “Execution sequence” is inappropriate phraseology; Unknown. 786; CD2; Definition of “thread”; Unknown. 787; CD2; Unnecessary lexical undefined behavior; Unknown. 788; CD2; Relationship between locale and values of the execution character set; Unknown. 789; CD2; Deprecating trigraphs; Unknown. 790; CD2; Concatenation of raw and non-raw string literals; Unknown. 792; CD2; Effects of std::quick_exit; Unknown. 793; CD2; Use of class members during destruction; Unknown. 794; NAD; Base-derived conversion in member type of pointer-to-member conversion; Unknown. 795; NAD; Dependency of lambdas on <functional>; Unknown. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attri,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57255,Safety,safe,safety,57255,; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and bindi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77815,Safety,safe,safety,77815,Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unk,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:79188,Safety,safe,safely-derived,79188, C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use of address-constant pointers in constant expressions; Unknown. 1194; C++11; Constexpr references; Unknown. 1195; C++11; References to non-literal types in constexpr functions; Unknown. 1196; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions definitions?; Unknown. 1202; C++11; Calling virtual functions during destruction; Unknown. 1203; dup; Misleading note regarding initialized static data members; Unknown. 1204; C++11; Specifiers in a for-range-declaration; Unknown. 1205; dup; Lvalue reference ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,Safety,redund,redundant,98536,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106282,Safety,safe,safety,106282,and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 15,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134045,Safety,Redund,Redundant,134045,structor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-de,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134329,Safety,Redund,Redundant,134329,wn. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138210,Safety,Redund,Redundant,138210, description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs stati,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:150932,Safety,Redund,Redundant,150932,"onversions in template argument deduction; Unknown. 2201; C++17; Cv-qualification of array types; Unknown. 2202; drafting; When does default argument instantiation occur?; Not resolved. 2203; drafting; Defaulted copy/move constructors and UDCs; Not resolved. 2204; NAD; Naming delegated constructors; Unknown. 2205; C++17; Restrictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed names",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159136,Safety,Redund,Redundancy,159136,tializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181543,Safety,Avoid,Avoid,181543,"e; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Inco",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:182046,Safety,Redund,Redundant,182046,"owing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,Safety,redund,redundant,187787,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196379,Safety,Redund,Redundant,196379,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1051,Security,Access,Access,1051,"ion status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1187,Security,access,access,1187,"Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1256,Security,access,access,1256,"on but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1798,Security,Access,Access,1798," allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1950,Security,access,accessed,1950,"function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 3",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:2086,Security,access,access,2086,"nts used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3722,Security,Access,Access,3722,"ibrary DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversions; Clang 2.8. 52; TC1; Non-static members, member selection and access checking; Clang 2.8. 53; TC1; Lvalue-to-rvalue conversion before certain static_casts; Yes. 54; CD1; Static_cast from private base to derived class; Clang 2.8. 55; NAD; Adding/subtracting pointer and enumeration value; Yes. 56; TC1; Redeclaring typedefs within classes; Yes. 57; open; Empty unions; Not resolved. 58; CD1; Signedness of bit fields of enum type; Clang 3.1. 59; TC1; Clarification of overloading and UDC to reference type; Yes. 60; CD1; Reference binding and valid conversion sequences; Yes. 61; NAD; Address of static member function ""&p->f"";",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:4168,Security,access,access,4168,"on of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversions; Clang 2.8. 52; TC1; Non-static members, member selection and access checking; Clang 2.8. 53; TC1; Lvalue-to-rvalue conversion before certain static_casts; Yes. 54; CD1; Static_cast from private base to derived class; Clang 2.8. 55; NAD; Adding/subtracting pointer and enumeration value; Yes. 56; TC1; Redeclaring typedefs within classes; Yes. 57; open; Empty unions; Not resolved. 58; CD1; Signedness of bit fields of enum type; Clang 3.1. 59; TC1; Clarification of overloading and UDC to reference type; Yes. 60; CD1; Reference binding and valid conversion sequences; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expressio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9913,Security,access,access,9913,emporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; C,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9954,Security,Inject,Injection-related,9954,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9982,Security,access,access,9982,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:10294,Security,Access,Accessibility,10294,nd new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static f,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:10950,Security,Access,Access,10950,elated errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtractio,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,Security,inject,injection,11726,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11750,Security,access,access,11750,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,Security,inject,injection,11784,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:12097,Security,Access,Access,12097,"tween Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested clas",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13644,Security,access,access,13644,"D-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member f",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13762,Security,access,accessible,13762,"Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18081,Security,access,access,18081,"on; Clang 4. 260; open; User-defined conversions and built-in operator=; Not resolved. 261; CD1; When is a deallocation function ""used?""; No. 262; CD1; Default arguments and ellipsis; Yes. 263; CD1; Can a constructor be declared a friend?; Clang 3.3. 264; open; Unusable template constructors and conversion functions; Not resolved. 265; dup; Destructors, exceptions, and deallocation; Duplicate of 353. 266; NAD; No grammar sentence symbol; N/A. 267; open; Alignment requirement for new-expressions; Not resolved. 268; open; Macro name suppression in rescanned replacement text; Not resolved. 269; NAD; Order of initialization of multiply-defined static data members; of class templates; N/A. 270; CD1; Order of initialization of static data members of class templates; N/A. 271; CD6; Explicit instantiation and template argument deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18452,Security,Access,Access,18452,"icate of 353. 266; NAD; No grammar sentence symbol; N/A. 267; open; Alignment requirement for new-expressions; Not resolved. 268; open; Macro name suppression in rescanned replacement text; Not resolved. 269; NAD; Order of initialization of multiply-defined static data members; of class templates; N/A. 270; CD1; Order of initialization of static data members of class templates; N/A. 271; CD6; Explicit instantiation and template argument deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. 290; NAD; Should memcpy be allowed into a POD with a const member?; N/A. 291; CD1; Overload resolution needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specificatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,Security,inject,injection,20182,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20956,Security,Inject,Injected-class-name,20956,"303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24043,Security,access,access,24043," 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit sp",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24836,Security,access,access,24836,"ignature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:26931,Security,access,access,26931," CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1823. 398; CD1; Ambiguous wording on naming a type in deduction; Yes. 399; CD6; Destructor lookup redux; Clang 11. 400; CD1; Using-declarations and the ""struct hack""; Yes. 401; CD1; When is access for template parameter default arguments checked?; Clang 2.8. 402; open; More on partial ordering of function templates; Not resolved. 403; CD1; Reference to a type as a template-id; Yes. 404; CD1; Unclear reference to construction with non-trivial constructor; N/A. 405; CD6; Unqualified function name lookup; Yes. 406; CD1; Static data member in class with name for linkage purposes; Clang 2.9. 407; C++11; Named class with associated typedef: two names or one?; Clang 3.8. 408; CD2; sizeof applied to unknown-bound array static data member of template; Clang 3.4. 409; CD1; Obsolete paragraph missed by changes for issue 224; Yes. 410; CD1; Paragraph missed in changes for issue 166; No. 411; CD6; Use of universal-character-name in character versus string literals; Unknown. 412; NAD; Can a replacement allocation function be inline?; Clang 3.4. 413; CD1; Definition of ""empty class""; Yes. 414; CD1; Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instanti",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,Security,inject,injected,29274,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29397,Security,inject,inject,29397,"; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording is",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29823,Security,access,accesses,29823,"riables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32212,Security,access,access,32212,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34162,Security,Access,Access,34162,"es. 487; NAD; Operator overloading in constant expressions; Yes. 488; CD1; Local types, overload resolution, and template argument deduction; Yes (C++11 onwards). 489; NAD; Must member function templates be instantiated during overload resolution?; N/A. 490; CD2; Name lookup in friend declarations; Clang 2.8. 491; CD1; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:39679,Security,Access,Access,39679,ct rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41154,Security,access,access,41154, conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,Security,inject,injected-class-name,41297,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:43662,Security,Access,Accessing,43662,of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632; CD1; Brace-enclosed initializer for scalar member of aggregate; Yes. 633; CD2; Specifications for variables that should also apply to references; N/A. 634; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis redux; Yes. 635; NAD; Names of constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr instances of constexpr constructor templates; Clang 3.1. 648; CD1; Constant expressions in constexpr initializers; Yes. 649; CD1; Optionally ill-formed extended alignment requests; Clang 3.5. 650; CD2; Order of destruction for temporaries bound to the returned value of a function; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Con,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
