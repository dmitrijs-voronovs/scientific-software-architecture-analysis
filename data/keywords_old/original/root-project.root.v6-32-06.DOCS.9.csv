id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96142,Deployability,configurat,configuration,96142,"`¶ <PenaltyBreakTemplateDeclaration>`; The penalty for breaking after template declaration. .. _PenaltyExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96245,Deployability,configurat,configuration,96245,"ExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96351,Deployability,configurat,configuration,96351,"tyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96999,Deployability,configurat,configuration,96999,"`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97176,Deployability,configurat,configuration,97176,"block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the rig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97321,Deployability,configurat,configuration,97321,"in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _Ra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97469,Deployability,configurat,configuration,97469,"tStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting su",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99205,Deployability,update,updated,99205,"ype' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99948,Deployability,configurat,configuration,99948,"hing delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100039,Deployability,configurat,configuration,100039,"ning the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBraces",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100144,Deployability,configurat,configuration,100144,"r delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBracesLLVM:. **RemoveBracesLLVM** (``Boolean``) :versionbadge:`clang-format 14` :ref:`¶ <RemoveBracesLLVM>`; Rem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100252,Deployability,configurat,configuration,100252," specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBracesLLVM:. **RemoveBracesLLVM** (``Boolean``) :versionbadge:`clang-format 14` :ref:`¶ <RemoveBracesLLVM>`; Remove optional braces of control statements (``if``, ``else``, ``for``,; and ``while``) in C++ according to th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102953,Deployability,configurat,configuration,102953," { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:103150,Deployability,configurat,configuration,103150,"r(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:103376,Deployability,configurat,configuration,103376,"lse { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:104387,Deployability,configurat,configuration,104387,"so remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... templa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:104687,Deployability,configurat,configuration,104687,"emicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105215,Deployability,configurat,configuration,105215,"format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105548,Deployability,configurat,configuration,105548,"<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106418,Deployability,configurat,configuration,106418,"me T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106696,Deployability,configurat,configuration,106696," T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:107857,Deployability,configurat,configuration,107857,"_SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:107942,Deployability,configurat,configuration,107942,"rsionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinition",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:108038,Deployability,configurat,configuration,108038,"s to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109229,Deployability,configurat,configuration,109229,"e maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109332,Deployability,A/B,A/B,109332,"This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109421,Deployability,configurat,configuration,109421,"namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109553,Deployability,A/B,A/B,109553,"de-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109662,Deployability,configurat,configuration,109662,"ines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclaration",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109798,Deployability,A/B,A/B,109798,"t bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110264,Deployability,configurat,configuration,110264,"lock:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110455,Deployability,configurat,configuration,110455,"ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110877,Deployability,configurat,configuration,110877,"port:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111122,Deployability,configurat,configuration,111122," placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111595,Deployability,configurat,configuration,111595,"eclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using std::string;; using std::chrono::duration_cast;. .. _SpaceAfterCStyleCast:. **SpaceAfterCStyleCast** (``Boolean``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceAfterCStyleCast>`; If ``true``, a space is inserted after C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113363,Deployability,configurat,configuration,113363,"r C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113615,Deployability,configurat,configuration,113615,"er the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113841,Deployability,configurat,configuration,113841,"ef:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:114064,Deployability,configurat,configuration,114064," **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break;; } }. .. _SpaceBeforeCpp11BracedList:. **SpaceBeforeCpp11BracedList** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCpp11BracedList>`; If ``true``, a space will be inserted before a C++11 braced list; used to i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:116551,Deployability,configurat,configuration,116551,"oo::Foo() : a(a) {} Foo::Foo(): a(a) {}. .. _SpaceBeforeInheritanceColon:. **SpaceBeforeInheritanceColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeInheritanceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:116757,Deployability,configurat,configuration,116757,"nceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117007,Deployability,configurat,configuration,117007,":ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Config",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117464,Deployability,configurat,configuration,117464,"eses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117686,Deployability,configurat,configuration,117686,"a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118023,Deployability,configurat,configuration,118023,"me as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118678,Deployability,configurat,configuration,118678,"n configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code-block:: c++. true: false:; if (...) {} vs. if(...) {}. * ``bool AfterForeachMacros`` If ``true``, put space between foreach macros and opening parentheses. .. code-block:: c++. true: false:; FOREACH (...) vs. FOREACH(...); <loop-body> <loop-body>. * ``bool AfterFunctionDeclarationName`` If ``true``, put a space between function declaration name and opening; parentheses. .. code-block:: c++. true: false:; void f (); vs. void f();. * ``bool AfterFunctionDefinitionName`` If ``true``, put a space between function definition name and opening; parentheses. .. code-block:: c++. true: false:; void f () {} vs. void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123319,Deployability,configurat,configuration,123319,"pacesInParensOptions``. .. _SpacesBeforeTrailingComments:. **SpacesBeforeTrailingComments** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesBeforeTrailingComments>`; The number of spaces before trailing line comments; (``//`` - comments). This does not affect trailing block comments (``/*`` - comments) as those; commonly have different usage patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123488,Deployability,configurat,configuration,123488,"ngComments>`; The number of spaces before trailing line comments; (``//`` - comments). This does not affect trailing block comments (``/*`` - comments) as those; commonly have different usage patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123658,Deployability,configurat,configuration,123658,"ge patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInContainerLiterals>`; If ``true``, spaces are inserted inside container literals (e.g. ObjC and; Javascript array and dict literals). For J",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:125774,Deployability,configurat,configuration,125774," arr = [ 1, 2, 3 ]; vs. var arr = [1, 2, 3];; f({a : 1, b : 2, c : 3}); f({a: 1, b: 2, c: 3});. .. _SpacesInLineCommentPrefix:. **SpacesInLineCommentPrefix** (``SpacesInLineComment``) :versionbadge:`clang-format 13` :ref:`¶ <SpacesInLineCommentPrefix>`; How many spaces are allowed at the start of a line comment. To disable the; maximum set it to ``-1``, apart from that the maximum takes precedence; over the minimum. .. code-block:: c++. Minimum = 1; Maximum = -1; // One space is forced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126248,Deployability,configurat,configuration,126248,"ced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126388,Deployability,configurat,configuration,126388,"e relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126998,Deployability,configurat,configuration,126998,". .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ) { ... } while (i < 5) { ... }. * ``bool InCStyleCasts`` Put a space in C style casts. .. code-block:: c++. true: false:; x = ( int32 )y vs. x = (int32)y. * ``bool InEmptyParentheses`` Put a space in parentheses only if the parentheses are empty i.e. '()'. .. code-block:: c++. true: false:; void f( ) { vs. void f() {; int x[] = {foo( ), bar( )}; int x[] = {foo(), bar()};; if (true) { if (true) {; f( ); f();; } }; } }. * ``bool Other`` Put a space in parentheses not covered by preceding options. .. code-block:: c++. true: false:; t f( Deleted & ) & = delete; vs. t f(Dele",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129147,Deployability,configurat,configuration,129147,"``, spaces will be inserted after ``(`` and before ``)``.; This option is **deprecated**. The previous behavior is preserved by using; ``SpacesInParens`` with ``Custom`` and by setting all; ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; Statement",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129268,Deployability,configurat,configuration,129268,"ved by using; ``SpacesInParens`` with ``Custom`` and by setting all; ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignCo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129341,Deployability,configurat,configuration,129341,"acesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129414,Deployability,configurat,configuration,129414,"mptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _State",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129487,Deployability,configurat,configuration,129487,"* (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129561,Deployability,configurat,configuration,129561,"e``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129718,Deployability,configurat,configuration,129718,". .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to mak",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:131604,Deployability,configurat,configuration,131604,"l macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; align",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132111,Deployability,configurat,configuration,132111,"es. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132181,Deployability,configurat,configuration,132181,"ntifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132291,Deployability,configurat,configuration,132291," :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132516,Deployability,configurat,configuration,132516,"lock:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132648,Deployability,configurat,configuration,132648,"F', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Addi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133506,Deployability,configurat,configuration,133506,"ation: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:134722,Deployability,patch,patches,134722,"ample: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21641,Integrability,wrap,wrapped,21641,"` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22068,Integrability,wrap,wrapped,22068,"fine A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22463,Integrability,wrap,wrapped,22463,"f ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27686,Integrability,contract,contracted,27686,"t;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> std::same_as<int>;; };. false:; template <typename T>; concept c = requires(T x) {; {; x + 1; } -> std::same_as<int>;; };. .. _AllowShortEnumsOnASingleLine:. **AllowShortEnumsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <AllowShortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowSho",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:34568,Integrability,wrap,wrapping,34568,"es of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38435,Integrability,wrap,wrapping,38435,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38804,Integrability,wrap,wrapping,38804,";. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39481,Integrability,wrap,wrap,39481,"s`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39665,Integrability,wrap,wrap,39665,"es: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39859,Integrability,wrap,wrap,39859,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:40488,Integrability,interface,interfaces,40488," Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; ba",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:40554,Integrability,synchroniz,synchronized,40554,"0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:40578,Integrability,wrap,wrapped,40578,"0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:41659,Integrability,wrap,wrapped,41659," Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:41860,Integrability,wrap,wrapped,41860,"lock:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWid",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:41902,Integrability,wrap,wrapping,41902,"true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of colum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42330,Integrability,wrap,wrapped,42330,"; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42384,Integrability,wrap,wrapping,42384," code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _B",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42652,Integrability,wrap,wrapped,42652,"e (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42695,Integrability,wrap,wrapping,42695,"ool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46170,Integrability,wrap,wrap,46170,"; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52530,Integrability,depend,depends,52530,"; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:57854,Integrability,wrap,wrapped,57854,"he column limit. A column limit of ``0`` means that there is no column limit. In this case,; clang-format will respect the input's line breaking decisions within; statements unless they contradict other rules. .. _CommentPragmas:. **CommentPragmas** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <CommentPragmas>`; A regular expression that describes comments with special meaning,; which should not be split into lines or otherwise changed. .. code-block:: c++. // CommentPragmas: '^ FOOBAR pragma:'; // Will leave the following line unaffected; #include <vector> // FOOBAR pragma: keep. .. _CompactNamespaces:. **CompactNamespaces** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <CompactNamespaces>`; If ``true``, consecutive namespace declarations will be on the same; line. If ``false``, each namespace is declared on a new line. .. code-block:: c++. true:; namespace Foo { namespace Bar {; }}. false:; namespace Foo {; namespace Bar {; }; }. If it does not fit on a single line, the overflowing namespaces get; wrapped:. .. code-block:: c++. namespace Foo { namespace Bar {; namespace Extra {; }}}. .. _ConstructorInitializerAllOnOneLineOrOnePerLine:. **ConstructorInitializerAllOnOneLineOrOnePerLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerAllOnOneLineOrOnePerLine>`; This option is **deprecated**. See ``CurrentLine`` of; ``PackConstructorInitializers``. .. _ConstructorInitializerIndentWidth:. **ConstructorInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerIndentWidth>`; The number of characters to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a lon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:74632,Integrability,wrap,wrapped,74632,"OO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. IndentWidth: 3. void f() {; someFunction();; if (true, false) {; f();; }; }. .. _IndentWrappedFunctionNames:. **IndentWrappedFunctionNames** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWrappedFunctionNames>`; Indent if a function definition or declaration is wrapped after the; type. .. code-block:: c++. true:; LoooooooooooooooooooooooooooooooooooooooongReturnType; LoooooooooooooooooooooooooooooooongFunctionDeclaration();. false:; LoooooooooooooooooooooooooooooooooooooooongReturnType; LoooooooooooooooooooooooooooooooongFunctionDeclaration();. .. _InsertBraces:. **InsertBraces** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <InsertBraces>`; Insert braces after control statements (``if``, ``else``, ``for``, ``do``,; and ``while``) in C++ unless the control statements are inside macro; definitions or the braces would enclose preprocessor directives. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) vs. if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D); handleFunctio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76324,Integrability,wrap,wrap,76324,"irectives. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) vs. if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D); handleFunctionDecl(D);; else if (isa<VarDecl>(D)) } else if (isa<VarDecl>(D)) {; handleVarDecl(D); handleVarDecl(D);; else } else {; return; return;; }. while (i--) vs. while (i--) {; for (auto *A : D.attrs()) for (auto *A : D.attrs()) {; handleAttr(A); handleAttr(A);; }; }. do vs. do {; --i; --i;; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76921,Integrability,wrap,wrapped,76921,";; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal lit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:81175,Integrability,wrap,wrap,81175,". import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: false:; if (foo) { vs. if (foo) {; bar();; bar(); }; }. .. _LambdaBodyIndentation:. **LambdaBodyIndentation** (``LambdaBodyIndentationKind``) :versionbadge:`clang-format 13` :ref:`¶ <LambdaBodyIndentation>`; The indentation style of lambd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83880,Integrability,protocol,protocol-buffers,83880,"e resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **Macro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84075,Integrability,message,messages,84075,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84131,Integrability,protocol,protocol-buffers,84131,":versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MA",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:86122,Integrability,depend,depending,86122,"BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-block:: c++. A(a*b);. will usually be interpreted as a call to a function A, and the; multiplication expression will be formatted as ``a * b``. If we specify the macro definition:. .. code-block:: yaml. Macros:; - A(x)=x. the code will now be parsed as a declaration of the variable b of type a*,; and formatted as ``a* b`` (depending on pointer-binding rules). Features and restrictions:; * Both function-like macros and object-like macros are supported.; * Macro arguments must be used exactly once in the expansion.; * No recursive expansion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88124,Integrability,protocol,protocol,88124,"used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Aut",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88343,Integrability,protocol,protocol,88343,"in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88489,Integrability,protocol,protocol,88489," in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88627,Integrability,protocol,protocol,88627,"(``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCB",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88790,Integrability,interface,interface,88790," to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88934,Integrability,interface,interface,88934,"ackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:91496,Integrability,protocol,protocol,91496,"mentioned in this array will be sorted last, in; stable order. Comments between attributes will leave the attributes; untouched. .. warning::. Using this option could lead to incorrect code formatting due to; clang-format's lack of complete semantic information. As such, extra; care should be taken to review code changes made by this option. .. code-block:: yaml. ObjCPropertyAttributeOrder: [; class, direct,; atomic, nonatomic,; assign, retain, strong, copy, weak, unsafe_unretained,; readonly, readwrite, getter, setter,; nullable, nonnull, null_resettable, null_unspecified; ]. .. _ObjCSpaceAfterProperty:. **ObjCSpaceAfterProperty** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceAfterProperty>`; Add a space after ``@property`` in Objective-C, i.e. use; ``@property (readonly)`` instead of ``@property(readonly)``. .. _ObjCSpaceBeforeProtocolList:. **ObjCSpaceBeforeProtocolList** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:656,Modifiability,config,configurable,656,"..; !!!!NOTE!!!!; This file is automatically generated, in part. Do not edit the style options; in this file directly. Instead, modify them in include/clang/Format/Format.h; and run the docs/tools/dump_format_style.py script to update this file. .. raw:: html. <style type=""text/css"">; .versionbadge { background-color: #1c913d; height: 20px; display: inline-block; min-width: 120px; text-align: center; border-radius: 5px; color: #FFFFFF; font-family: ""Verdana,Geneva,DejaVu Sans,sans-serif""; }; </style>. .. role:: versionbadge. ==========================; Clang-Format Style Options; ==========================. :doc:`ClangFormatStyleOptions` describes configurable formatting style options; supported by :doc:`LibFormat` and :doc:`ClangFormat`. When using :program:`clang-format` command line utility or; ``clang::format::reformat(...)`` functions from code, one can either use one of; the predefined styles (LLVM, Google, Chromium, Mozilla, WebKit, Microsoft) or; create a custom style by configuring specific style options. Configuring Style with clang-format; ===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:994,Modifiability,config,configuring,994,"..; !!!!NOTE!!!!; This file is automatically generated, in part. Do not edit the style options; in this file directly. Instead, modify them in include/clang/Format/Format.h; and run the docs/tools/dump_format_style.py script to update this file. .. raw:: html. <style type=""text/css"">; .versionbadge { background-color: #1c913d; height: 20px; display: inline-block; min-width: 120px; text-align: center; border-radius: 5px; color: #FFFFFF; font-family: ""Verdana,Geneva,DejaVu Sans,sans-serif""; }; </style>. .. role:: versionbadge. ==========================; Clang-Format Style Options; ==========================. :doc:`ClangFormatStyleOptions` describes configurable formatting style options; supported by :doc:`LibFormat` and :doc:`ClangFormat`. When using :program:`clang-format` command line utility or; ``clang::format::reformat(...)`` functions from code, one can either use one of; the predefined styles (LLVM, Google, Chromium, Mozilla, WebKit, Microsoft) or; create a custom style by configuring specific style options. Configuring Style with clang-format; ===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:1203,Modifiability,config,configuration,1203,"tyle.py script to update this file. .. raw:: html. <style type=""text/css"">; .versionbadge { background-color: #1c913d; height: 20px; display: inline-block; min-width: 120px; text-align: center; border-radius: 5px; color: #FFFFFF; font-family: ""Verdana,Geneva,DejaVu Sans,sans-serif""; }; </style>. .. role:: versionbadge. ==========================; Clang-Format Style Options; ==========================. :doc:`ClangFormatStyleOptions` describes configurable formatting style options; supported by :doc:`LibFormat` and :doc:`ClangFormat`. When using :program:`clang-format` command line utility or; ``clang::format::reformat(...)`` functions from code, one can either use one of; the predefined styles (LLVM, Google, Chromium, Mozilla, WebKit, Microsoft) or; create a custom style by configuring specific style options. Configuring Style with clang-format; ===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:1294,Modifiability,config,configuration,1294,"tyle.py script to update this file. .. raw:: html. <style type=""text/css"">; .versionbadge { background-color: #1c913d; height: 20px; display: inline-block; min-width: 120px; text-align: center; border-radius: 5px; color: #FFFFFF; font-family: ""Verdana,Geneva,DejaVu Sans,sans-serif""; }; </style>. .. role:: versionbadge. ==========================; Clang-Format Style Options; ==========================. :doc:`ClangFormatStyleOptions` describes configurable formatting style options; supported by :doc:`LibFormat` and :doc:`ClangFormat`. When using :program:`clang-format` command line utility or; ``clang::format::reformat(...)`` functions from code, one can either use one of; the predefined styles (LLVM, Google, Chromium, Mozilla, WebKit, Microsoft) or; create a custom style by configuring specific style options. Configuring Style with clang-format; ===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:1979,Modifiability,config,configuration,1979,"===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; Point",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2132,Modifiability,config,configuration,2132,"===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; Point",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2791,Modifiability,config,configuration,2791,"th may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =====================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3369,Modifiability,config,configuration,3369,"or specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3483,Modifiability,config,config,3483,"-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; ============",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3523,Modifiability,config,configuration,3523,"g standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3573,Modifiability,config,configuration,3573,"g standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3638,Modifiability,config,configuration,3638,"o its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5013,Modifiability,config,configuration,5013,"rmat on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5190,Modifiability,config,configuration,5190,"lso, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5266,Modifiability,config,configuration,5266,"y; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7328,Modifiability,config,configuration,7328,"e the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7487,Modifiability,config,configuration,7487,"d applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7668,Modifiability,config,configuration,7668,"nStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7881,Modifiability,config,configuration,7881,"The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8651,Modifiability,config,configuration,8651,"ion: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8861,Modifiability,config,configuration,8861,"ation: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:9072,Modifiability,config,configuration,9072,"rgument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:9475,Modifiability,config,configuration,9475,"the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:11852,Modifiability,config,configuration,11852,"lse:; a &= 2;; bbb = 2;. * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveBitFields:. **AlignConsecutiveBitFields** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 11` :ref:`¶ <AlignConsecutiveBitFields>`; Style of aligning consecutive bit fields. ``Consecutive`` will align the bitfield separators of consecutive lines.; This will result in formattings like:. .. code-block:: c++. int aaaa : 1;; int b : 12;; int ccc : 8;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:14246,Modifiability,config,configuration,14246,"b = 2;. * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveDeclarations:. **AlignConsecutiveDeclarations** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveDeclarations>`; Style of aligning consecutive declarations. ``Consecutive`` will align the declaration names of consecutive lines.; This will result in formattings like:. .. code-block:: c++. int aaaa = 12;; float b = 23;; std::string ccc;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:16647,Modifiability,config,configuration,16647," * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveMacros:. **AlignConsecutiveMacros** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AlignConsecutiveMacros>`; Style of aligning consecutive macro definitions. ``Consecutive`` will result in formattings like:. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19131,Modifiability,config,configuration,19131,"r function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20815,Modifiability,config,configuration,20815,"ents`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20970,Modifiability,config,configuration,20970,"comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21154,Modifiability,config,configuration,21154,"l AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21548,Modifiability,config,configuration,21548,"apedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21752,Modifiability,config,configuration,21752,"s:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22234,Modifiability,config,configuration,22234,"aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKind",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23194,Modifiability,config,configuration,23194," * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKee",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23363,Modifiability,config,configuration,23363,"``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set; to 1, it formats like below. .. code-block:: c++. int a; // these are. int ab; // aligned. int abcdef; // but this isn't. .. _AllowAllAr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23552,Modifiability,config,configuration,23552,"bbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set; to 1, it formats like below. .. code-block:: c++. int a; // these are. int ab; // aligned. int abcdef; // but this isn't. .. _AllowAllArgumentsOnNextLine:. **AllowAllArgumentsOnNextLine** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <AllowAllArgumentsOnNextLine>`; If a function call or braced initializer list ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23729,Modifiability,config,configuration,23729,"of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set; to 1, it formats like below. .. code-block:: c++. int a; // these are. int ab; // aligned. int abcdef; // but this isn't. .. _AllowAllArgumentsOnNextLine:. **AllowAllArgumentsOnNextLine** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <AllowAllArgumentsOnNextLine>`; If a function call or braced initializer list doesn't fit on a; line, allow putting all arguments onto the next line, even if; ``BinPackArguments`` is ``false``. .. code-block:: c++. true:; callFunction(; a, b, c, d);. false:; callFunction(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:25879,Modifiability,config,configuration,25879,"onbadge:`clang-format 9` :ref:`¶ <AllowAllConstructorInitializersOnNextLine>`; This option is **deprecated**. See ``NextLine`` of; ``PackConstructorInitializers``. .. _AllowAllParametersOfDeclarationOnNextLine:. **AllowAllParametersOfDeclarationOnNextLine** (``Boolean``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowAllParametersOfDeclarationOnNextLine>`; If the function declaration doesn't fit on a line,; allow putting all parameters of a function declaration onto; the next line even if ``BinPackParameters`` is ``false``. .. code-block:: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26114,Modifiability,config,configuration,26114," :versionbadge:`clang-format 3.3` :ref:`¶ <AllowAllParametersOfDeclarationOnNextLine>`; If the function declaration doesn't fit on a line,; allow putting all parameters of a function declaration onto; the next line even if ``BinPackParameters`` is ``false``. .. code-block:: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26421,Modifiability,config,configuration,26421,":: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. whil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27039,Modifiability,config,configuration,27039,"noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27195,Modifiability,config,configuration,27195," when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27336,Modifiability,config,configuration,27336,"az(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> std::same_as<int>;; };. false:; template <typename T>; concept c = requires(T x) {; {; x + 1; } -> std::same_as<int>;; };. .. _AllowShortEnumsOnASingleLin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:28903,Modifiability,config,configuration,28903,"rtCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> std::same_as<int>;; };. false:; template <typename T>; concept c = requires(T x) {; {; x + 1; } -> std::same_as<int>;; };. .. _AllowShortEnumsOnASingleLine:. **AllowShortEnumsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <AllowShortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:28996,Modifiability,config,configuration,28996,"owShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> std::same_as<int>;; };. false:; template <typename T>; concept c = requires(T x) {; {; x + 1; } -> std::same_as<int>;; };. .. _AllowShortEnumsOnASingleLine:. **AllowShortEnumsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <AllowShortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29300,Modifiability,config,configuration,29300,"_as<int>;; };. .. _AllowShortEnumsOnASingleLine:. **AllowShortEnumsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <AllowShortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29435,Modifiability,config,configuration,29435,"hortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); retu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29638,Modifiability,config,configuration,29638,"ionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) retur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30081,Modifiability,config,configuration,30081,"does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30279,Modifiability,config,configuration,30279,"``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30511,Modifiability,config,configuration,30511,"ss Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30769,Modifiability,config,configuration,30769,"tatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); M",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31272,Modifiability,config,configuration,31272,"``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :ver",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31358,Modifiability,config,configuration,31358,"ment. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31525,Modifiability,config,configuration,31525,"ot else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31781,Modifiability,config,configuration,31781,"lways put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32547,Modifiability,config,configuration,32547,"to a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32690,Modifiability,config,configuration,32690,"gin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32776,Modifiability,config,configuration,32776,"erge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Alway",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33130,Modifiability,config,configuration,33130,a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; },MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33365,Modifiability,config,configuration,33365," definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33550,Modifiability,config,configuration,33550,"er return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33767,Modifiability,config,configuration,33767,"el``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33997,Modifiability,config,configuration,33997,"`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible value",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:35052,Modifiability,config,configuration,35052,"of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:35346,Modifiability,config,configuration,35346,"e multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. Attrib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:35641,Modifiability,config,configuration,35641,"es from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. AttributeMacros: ['__capability', '__output', '__unused']. .. _BinPackArguments:. **BinPackArguments** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackArguments>`; If ``false``, a function call's arguments will either be all on the; same line or will have on",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:36319,Modifiability,config,configuration,36319,"ne`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. AttributeMacros: ['__capability', '__output', '__unused']. .. _BinPackArguments:. **BinPackArguments** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackArguments>`; If ``false``, a function call's arguments will either be all on the; same line or will have one line each. .. code-block:: c++. true:; void f() {; f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. false:; void f() {; f(aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:36351,Modifiability,config,configured,36351,"ne`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. AttributeMacros: ['__capability', '__output', '__unused']. .. _BinPackArguments:. **BinPackArguments** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackArguments>`; If ``false``, a function call's arguments will either be all on the; same line or will have one line each. .. code-block:: c++. true:; void f() {; f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. false:; void f() {; f(aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37697,Modifiability,config,configuration,37697,"aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. false:; void f() {; f(aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: fals",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37823,Modifiability,config,configuration,37823,"aaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared thi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37995,Modifiability,config,configuration,37995,"format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38115,Modifiability,config,configuration,38115," will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38757,Modifiability,config,configuration,38757," .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39448,Modifiability,config,configuration,39448,"s`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39629,Modifiability,config,configuration,39629,"es: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39824,Modifiability,config,configuration,39824,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:43897,Modifiability,variab,variable,43897,"d``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44158,Modifiability,config,configuration,44158,"omeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44526,Modifiability,config,configuration,44526,"iterals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; Dat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44906,Modifiability,config,configuration,44906,"luding constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46230,Modifiability,config,configuration,46230," .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46664,Modifiability,config,configuration,46664,"-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:47122,Modifiability,config,configuration,47122,"foreBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:47733,Modifiability,config,configuration,47733,"ck:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Linux`` (in configuration: ``Linux``); Like ``Attach``, but break before braces on function, namespace and; class definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``M",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:48213,Modifiability,config,configuration,48213,"oooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Linux`` (in configuration: ``Linux``); Like ``Attach``, but break before braces on function, namespace and; class definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``Mozilla``); Like ``Attach``, but break before braces on enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Strous",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:48741,Modifiability,config,configuration,48741,"urrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Linux`` (in configuration: ``Linux``); Like ``Attach``, but break before braces on function, namespace and; class definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``Mozilla``); Like ``Attach``, but break before braces on enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Stroustrup`` (in configuration: ``Stroustrup``); Like ``Attach``, but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_All",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:49271,Modifiability,config,configuration,49271,"definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``Mozilla``); Like ``Attach``, but break before braces on enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Stroustrup`` (in configuration: ``Stroustrup``); Like ``Attach``, but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); L",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:49797,Modifiability,config,configuration,49797,"enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Stroustrup`` (in configuration: ``Stroustrup``); Like ``Attach``, but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configura",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:50281,Modifiability,config,configuration,50281," but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:50805,Modifiability,config,configuration,50805,"; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:51408,Modifiability,config,configuration,51408,"E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``All",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:51891,Modifiability,config,configuration,51891,"ements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52240,Modifiability,config,configuration,52240,"}. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52414,Modifiability,config,configuration,52414,"h``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52616,Modifiability,config,configuration,52616," break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53039,Modifiability,config,configuration,53039,"reConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53185,Modifiability,config,configuration,53185,"S_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <Bre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53476,Modifiability,config,configuration,53476," is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:54349,Modifiability,config,configuration,54349,": [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:54550,Modifiability,config,configuration,54550," _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance li",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:54779,Modifiability,config,configuration,54779,"reaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55093,Modifiability,inherit,inheritance,55093,"ndValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55169,Modifiability,config,configuration,55169,"g-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVery",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55208,Modifiability,inherit,inheritance,55208,"g-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVery",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55345,Modifiability,config,configuration,55345,"tructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55384,Modifiability,inherit,inheritance,55384,"tructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55549,Modifiability,config,configuration,55549,"ma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55587,Modifiability,inherit,inheritance,55587,"ma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55712,Modifiability,config,configuration,55712,"initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryVeryVe"",; ""ryVeryVeryVeryVeryVery"",; ""VeryLongString""};. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. .. _ColumnLimit:. **C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55750,Modifiability,inherit,inheritance,55750,"initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryVeryVe"",; ""ryVeryVeryVeryVeryVery"",; ""VeryLongString""};. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. .. _ColumnLimit:. **C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:58505,Modifiability,inherit,inheritance,58505," **CompactNamespaces** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <CompactNamespaces>`; If ``true``, consecutive namespace declarations will be on the same; line. If ``false``, each namespace is declared on a new line. .. code-block:: c++. true:; namespace Foo { namespace Bar {; }}. false:; namespace Foo {; namespace Bar {; }; }. If it does not fit on a single line, the overflowing namespaces get; wrapped:. .. code-block:: c++. namespace Foo { namespace Bar {; namespace Extra {; }}}. .. _ConstructorInitializerAllOnOneLineOrOnePerLine:. **ConstructorInitializerAllOnOneLineOrOnePerLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerAllOnOneLineOrOnePerLine>`; This option is **deprecated**. See ``CurrentLine`` of; ``PackConstructorInitializers``. .. _ConstructorInitializerIndentWidth:. **ConstructorInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerIndentWidth>`; The number of characters to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a long comment; arg);. .. _Cpp11BracedListStyle:. **Cpp11BracedListStyle** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <Cpp11BracedListStyle>`; If ``true``, format braced lists as best suited for C++11 braced; lists. Important differences:; - No spaces inside the braced list.; - No line break before the closing brace.; - Indentation with the continuation indent, not with the block indent. Fundamentally, C++11 braced lists are formatted exactly like function; calls would be formatted in their place. If the braced list follows a name; (e.g. a type or variable name), clang-format formats as if the ``{}`` were",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:59385,Modifiability,variab,variable,59385,"rs to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a long comment; arg);. .. _Cpp11BracedListStyle:. **Cpp11BracedListStyle** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <Cpp11BracedListStyle>`; If ``true``, format braced lists as best suited for C++11 braced; lists. Important differences:; - No spaces inside the braced list.; - No line break before the closing brace.; - Indentation with the continuation indent, not with the block indent. Fundamentally, C++11 braced lists are formatted exactly like function; calls would be formatted in their place. If the braced list follows a name; (e.g. a type or variable name), clang-format formats as if the ``{}`` were; the parentheses of a function call with that name. If there is no name,; a zero-length name is assumed. .. code-block:: c++. true: false:; vector<int> x{1, 2, 3, 4}; vs. vector<int> x{ 1, 2, 3, 4 };; vector<T> x{{}, {}, {}, {}}; vector<T> x{ {}, {}, {}, {} };; f(MyMap[{composite, key}]); f(MyMap[{ composite, key }]);; new int[3]{1, 2, 3}; new int[3]{ 1, 2, 3 };. .. _DeriveLineEnding:. **DeriveLineEnding** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **Di",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60828,Modifiability,config,configuration,60828,"ng** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60948,Modifiability,config,configuration,60948,"LF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61178,Modifiability,config,configuration,61178,st common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBl,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61320,Modifiability,config,configuration,61320,ile.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61875,Modifiability,config,configuration,61875,fiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62106,Modifiability,config,configuration,62106,"vate:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62214,Modifiability,config,configuration,62214,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62543,Modifiability,config,configuration,62543,"AccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNam",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:63450,Modifiability,config,config,63450,":; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64356,Modifiability,variab,variable-declaration,64356,":. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64419,Modifiability,config,configuration,64419," use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separatel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64451,Modifiability,config,configured,64451," use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separatel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64908,Modifiability,config,configuration,64908,"id foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64940,Modifiability,config,configured,64940,"id foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:65369,Modifiability,config,configuration,65369,"ody>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:65593,Modifiability,config,configuration,65593,"clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:65837,Modifiability,config,configuration,65837,"nditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The value belonging to the first; matching regular expression is assigned and ``#includes`` are sorted first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:66390,Modifiability,extend,extended,66390," Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The value belonging to the first; matching regular expression is assigned and ``#includes`` are sorted first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX is assigned as; category. The main header for a source file automatically gets category 0.; so that it is generally kept at the beginning of the ``#includes``; (https://llvm.org/docs/CodingStandards.html#include-style). However, you; can also assign negative priorities if you have certain headers that; always need to be first. There is a third and optional field ``SortPriority`` which can used while; ``IncludeBlocks = IBS_Regroup`` to define the priority in which; ``#includes`` should be ordered. The value of ``Priority`` d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:67714,Modifiability,config,configure,67714,"d first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX is assigned as; category. The main header for a source file automatically gets category 0.; so that it is generally kept at the beginning of the ``#includes``; (https://llvm.org/docs/CodingStandards.html#include-style). However, you; can also assign negative priorities if you have certain headers that; always need to be first. There is a third and optional field ``SortPriority`` which can used while; ``IncludeBlocks = IBS_Regroup`` to define the priority in which; ``#includes`` should be ordered. The value of ``Priority`` defines the; order of ``#include blocks`` and also allows the grouping of ``#includes``; of different priority. ``SortPriority`` is set to the value of; ``Priority`` as default if it is not assigned. Each regular expression can be marked as case sensitive with the field; ``CaseSensitive``, per default it is not. To configure this in the .clang-format file, use:. .. code-block:: yaml. IncludeCategories:; - Regex: '^""(llvm|llvm-c|clang|clang-c)/'; Priority: 2; SortPriority: 2; CaseSensitive: true; - Regex: '^((<|"")(gtest|gmock|isl|json)/)'; Priority: 3; - Regex: '<[[:alnum:].]+>'; Priority: 4; - Regex: '.*'; Priority: 1; SortPriority: 0. .. _IncludeIsMainRegex:. **IncludeIsMainRegex** (``String``) :versionbadge:`clang-format 3.9` :ref:`¶ <IncludeIsMainRegex>`; Specify a regular expression of suffixes that are allowed in the; file-to-main-include mapping. When guessing whether a #include is the ""main"" include (to assign; category 0, see above), use this regex of allowed suffixes to the header; stem. A partial match is done, so that:; - """" means ""arbitrary suffix""; - ""$"" means ""no suffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-form",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:68516,Modifiability,config,configured,68516,"set to the value of; ``Priority`` as default if it is not assigned. Each regular expression can be marked as case sensitive with the field; ``CaseSensitive``, per default it is not. To configure this in the .clang-format file, use:. .. code-block:: yaml. IncludeCategories:; - Regex: '^""(llvm|llvm-c|clang|clang-c)/'; Priority: 2; SortPriority: 2; CaseSensitive: true; - Regex: '^((<|"")(gtest|gmock|isl|json)/)'; Priority: 3; - Regex: '<[[:alnum:].]+>'; Priority: 4; - Regex: '.*'; Priority: 1; SortPriority: 0. .. _IncludeIsMainRegex:. **IncludeIsMainRegex** (``String``) :versionbadge:`clang-format 3.9` :ref:`¶ <IncludeIsMainRegex>`; Specify a regular expression of suffixes that are allowed in the; file-to-main-include mapping. When guessing whether a #include is the ""main"" include (to assign; category 0, see above), use this regex of allowed suffixes to the header; stem. A partial match is done, so that:; - """" means ""arbitrary suffix""; - ""$"" means ""no suffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-format 10` :ref:`¶ <IncludeIsMainSourceRegex>`; Specify a regular expression for files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69157,Modifiability,config,config,69157,"xes that are allowed in the; file-to-main-include mapping. When guessing whether a #include is the ""main"" include (to assign; category 0, see above), use this regex of allowed suffixes to the header; stem. A partial match is done, so that:; - """" means ""arbitrary suffix""; - ""$"" means ""no suffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-format 10` :ref:`¶ <IncludeIsMainSourceRegex>`; Specify a regular expression for files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69287,Modifiability,config,configured,69287,"r a #include is the ""main"" include (to assign; category 0, see above), use this regex of allowed suffixes to the header; stem. A partial match is done, so that:; - """" means ""arbitrary suffix""; - ""$"" means ""no suffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-format 10` :ref:`¶ <IncludeIsMainSourceRegex>`; Specify a regular expression for files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:71993,Modifiability,config,configuration,71993,"; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; } {; plop();; }; }. .. _IndentCaseLabels:. **IndentCaseLabels** (``Boolean``) :versionbadge:`clang-format 3.3` :ref:`¶ <IndentCaseLabels>`; Indent case labels one level from the switch statement. When ``false``, use the same indentation level as for the switch; statement. Switch statement body is always indented one level more than; case labels (except the first block following the case label, which; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentSt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:72365,Modifiability,config,configuration,72365,"nt. Switch statement body is always indented one level more than; case labels (except the first block following the case label, which; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:72499,Modifiability,config,configuration,72499,"ich; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configura",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73182,Modifiability,config,configuration,73182,"oid foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73337,Modifiability,config,configuration,73337,"nt`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73504,Modifiability,config,configuration,73504,"`); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. IndentWidth: 3. void f() {; someFunction();; if (true, false) {; f();; }; }. .. _IndentWrappedFunctionNames:. **IndentWrappedFunctionNames** (``Boolean``) :versionbadge:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76758,Modifiability,config,configuration,76758,"to *A : D.attrs()) for (auto *A : D.attrs()) {; handleAttr(A); handleAttr(A);; }; }. do vs. do {; --i; --i;; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76837,Modifiability,config,configuration,76837,";; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal lit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:77454,Modifiability,config,configuration,77454,"s`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal literals. .. code-block:: c++. IntegerLiteralSeparator:; Binary: 0; Decimal: 3; Hex: -1. You can also specify a minimum number of digits (``BinaryMinDigits``,; ``DecimalMinDigits``, and ``HexMinDigits``) the integer literal must; have in order for the separators to be inserted. * ``int8_t Binary`` Format separators in binary literals. .. code-block:: text. /* -1: */ b = 0b100111101101;; /* 0: */ b = 0b10011'11'0110'1;; /* 3: */ b = 0b100'111'101'101;; /* 4: */ b = 0b1001'1110'1101;. * ``int8_t BinaryMinDigits`` Format separators in binary literals with a minimum number of dig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:77700,Modifiability,config,config,77700,"o not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal literals. .. code-block:: c++. IntegerLiteralSeparator:; Binary: 0; Decimal: 3; Hex: -1. You can also specify a minimum number of digits (``BinaryMinDigits``,; ``DecimalMinDigits``, and ``HexMinDigits``) the integer literal must; have in order for the separators to be inserted. * ``int8_t Binary`` Format separators in binary literals. .. code-block:: text. /* -1: */ b = 0b100111101101;; /* 0: */ b = 0b10011'11'0110'1;; /* 3: */ b = 0b100'111'101'101;; /* 4: */ b = 0b1001'1110'1101;. * ``int8_t BinaryMinDigits`` Format separators in binary literals with a minimum number of digits. .. code-block:: text. // Binary: 3; // BinaryMinDigits: 7; b1 = 0b101101;; b2 = 0b1'101'101;. * ``int8_t Decimal`` Format separators in decimal literals. .. code-block:: text. /* -1: */ d = 18446744073709550592ull;; /* 0: */ d = 184467'440737'0'95505'92ull;; /* 3: */ d = 18'446'744'073'709'550'592ull;. * ``int8_t Deci",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:79925,Modifiability,config,configuration,79925,"* ``int8_t Hex`` Format separators in hexadecimal literals. .. code-block:: text. /* -1: */ h = 0xDEADBEEFDEADBEEFuz;; /* 0: */ h = 0xDEAD'BEEF'DE'AD'BEE'Fuz;; /* 2: */ h = 0xDE'AD'BE'EF'DE'AD'BE'EFuz;. * ``int8_t HexMinDigits`` Format separators in hexadecimal literals with a minimum number of; digits. .. code-block:: text. // Hex: 2; // HexMinDigits: 6; h1 = 0xABCDE;; h2 = 0xAB'CD'EF;. .. _JavaImportGroups:. **JavaImportGroups** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <JavaImportGroups>`; A vector of prefixes ordered by the desired groups for Java imports. One group's prefix can be a subset of another - the longest prefix is; always matched. Within a group, the imports are ordered lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:79957,Modifiability,config,configured,79957,"* ``int8_t Hex`` Format separators in hexadecimal literals. .. code-block:: text. /* -1: */ h = 0xDEADBEEFDEADBEEFuz;; /* 0: */ h = 0xDEAD'BEEF'DE'AD'BEE'Fuz;; /* 2: */ h = 0xDE'AD'BE'EF'DE'AD'BE'EFuz;. * ``int8_t HexMinDigits`` Format separators in hexadecimal literals with a minimum number of; digits. .. code-block:: text. // Hex: 2; // HexMinDigits: 6; h1 = 0xABCDE;; h2 = 0xAB'CD'EF;. .. _JavaImportGroups:. **JavaImportGroups** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <JavaImportGroups>`; A vector of prefixes ordered by the desired groups for Java imports. One group's prefix can be a subset of another - the longest prefix is; always matched. Within a group, the imports are ordered lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80649,Modifiability,config,configuration,80649,"red lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80787,Modifiability,config,configuration,80787,"efore non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80919,Modifiability,config,configuration,80919,"tion file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:82503,Modifiability,config,configuration,82503,"sAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: false:; if (foo) { vs. if (foo) {; bar();; bar(); }; }. .. _LambdaBodyIndentation:. **LambdaBodyIndentation** (``LambdaBodyIndentationKind``) :versionbadge:`clang-format 13` :ref:`¶ <LambdaBodyIndentation>`; The indentation style of lambda bodies. ``Signature`` (the default); causes the lambda body to be indented one additional level relative to; the indentation level of the signature. ``OuterScope`` forces the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaSc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:82729,Modifiability,config,configuration,82729,"3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: false:; if (foo) { vs. if (foo) {; bar();; bar(); }; }. .. _LambdaBodyIndentation:. **LambdaBodyIndentation** (``LambdaBodyIndentationKind``) :versionbadge:`clang-format 13` :ref:`¶ <LambdaBodyIndentation>`; The indentation style of lambda bodies. ``Signature`` (the default); causes the lambda body to be indented one additional level relative to; the indentation level of the signature. ``OuterScope`` forces the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83272,Modifiability,config,configuration,83272,"; the indentation level of the signature. ``OuterScope`` forces the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83327,Modifiability,config,configuration,83327,"s the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83399,Modifiability,config,configuration,83399," parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83468,Modifiability,config,configuration,83468,"LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83543,Modifiability,config,configuration,83543,"to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83624,Modifiability,config,configuration,83624,"; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83693,Modifiability,config,configuration,83693,"ope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83785,Modifiability,config,configuration,83785,"ative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83922,Modifiability,config,configuration,83922,"ReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84009,Modifiability,config,configuration,84009,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84172,Modifiability,config,configuration,84172,"ge, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_EN",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84531,Modifiability,config,configuration,84531,"in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84585,Modifiability,config,configuration,84585,"avaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A li",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84647,Modifiability,config,configuration,84647,"_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84764,Modifiability,config,configuration,84764,": ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:86071,Modifiability,variab,variable,86071,"BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-block:: c++. A(a*b);. will usually be interpreted as a call to a function A, and the; multiplication expression will be formatted as ``a * b``. If we specify the macro definition:. .. code-block:: yaml. Macros:; - A(x)=x. the code will now be parsed as a declaration of the variable b of type a*,; and formatted as ``a* b`` (depending on pointer-binding rules). Features and restrictions:; * Both function-like macros and object-like macros are supported.; * Macro arguments must be used exactly once in the expansion.; * No recursive expansion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87155,Modifiability,config,configuration,87155,"restrictions:; * Both function-like macros and object-like macros are supported.; * Macro arguments must be used exactly once in the expansion.; * No recursive expansion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87304,Modifiability,config,configuration,87304,"ion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objectiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87486,Modifiability,config,configuration,87486,"lock:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89070,Modifiability,config,configuration,89070,"bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) sel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89173,Modifiability,config,configuration,89173,"en they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {; u = c;; }]; }. .. _ObjCPropertyAttributeOrder:. **ObjCPro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89249,Modifiability,config,configuration,89249," value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {; u = c;; }]; }. .. _ObjCPropertyAttributeOrder:. **ObjCPropertyAttributeOrder** (``List of Strings``) :versionbadge:`clang-format 18`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92202,Modifiability,config,configuration,92202," i.e. use; ``@property (readonly)`` instead of ``@property(readonly)``. .. _ObjCSpaceBeforeProtocolList:. **ObjCSpaceBeforeProtocolList** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ccccccccccc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92358,Modifiability,config,configuration,92358,"ean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherw",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92560,Modifiability,config,configuration,92560,"ndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92856,Modifiability,config,configuration,92856,"; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). .. _PenaltyBreakAssignment:. **PenaltyBreakAssignment** (``Unsigned``) :versionbadge:`clang-format 5` :ref:`¶ <PenaltyBreakAssignment>`; The penalty for breaking around an assignment operator. .. _PenaltyBreakBeforeFirstCallParameter:. **PenaltyBreakBeforeFirstCallParameter** (``Unsigned``) :v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:93274,Modifiability,config,configuration,93274,"Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). .. _PenaltyBreakAssignment:. **PenaltyBreakAssignment** (``Unsigned``) :versionbadge:`clang-format 5` :ref:`¶ <PenaltyBreakAssignment>`; The penalty for breaking around an assignment operator. .. _PenaltyBreakBeforeFirstCallParameter:. **PenaltyBreakBeforeFirstCallParameter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyBreakBeforeFirstCallParameter>`; The penalty for breaking a function call after ``call(``. .. _PenaltyBreakComment:. **PenaltyBreakComment** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyBreakComment>`; The penalty for each line break introduced inside a comment. .. _PenaltyBreakFirstLessLess:. **PenaltyBreakFirst",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96142,Modifiability,config,configuration,96142,"`¶ <PenaltyBreakTemplateDeclaration>`; The penalty for breaking after template declaration. .. _PenaltyExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96245,Modifiability,config,configuration,96245,"ExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96351,Modifiability,config,configuration,96351,"tyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96999,Modifiability,config,configuration,96999,"`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97176,Modifiability,config,configuration,97176,"block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the rig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97321,Modifiability,config,configuration,97321,"in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _Ra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97469,Modifiability,config,configuration,97469,"tStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting su",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99389,Modifiability,config,configure,99389,"RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :ve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99948,Modifiability,config,configuration,99948,"hing delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100039,Modifiability,config,configuration,100039,"ning the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBraces",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100144,Modifiability,config,configuration,100144,"r delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBracesLLVM:. **RemoveBracesLLVM** (``Boolean``) :versionbadge:`clang-format 14` :ref:`¶ <RemoveBracesLLVM>`; Rem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100252,Modifiability,config,configuration,100252," specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBracesLLVM:. **RemoveBracesLLVM** (``Boolean``) :versionbadge:`clang-format 14` :ref:`¶ <RemoveBracesLLVM>`; Remove optional braces of control statements (``if``, ``else``, ``for``,; and ``while``) in C++ according to th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102953,Modifiability,config,configuration,102953," { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:103150,Modifiability,config,configuration,103150,"r(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:103376,Modifiability,config,configuration,103376,"lse { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:104387,Modifiability,config,configuration,104387,"so remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... templa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:104687,Modifiability,config,configuration,104687,"emicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105215,Modifiability,config,configuration,105215,"format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105548,Modifiability,config,configuration,105548,"<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106418,Modifiability,config,configuration,106418,"me T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106696,Modifiability,config,configuration,106696," T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:107857,Modifiability,config,configuration,107857,"_SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:107942,Modifiability,config,configuration,107942,"rsionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinition",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:108038,Modifiability,config,configuration,108038,"s to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109229,Modifiability,config,configuration,109229,"e maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109421,Modifiability,config,configuration,109421,"namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109662,Modifiability,config,configuration,109662,"ines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclaration",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110264,Modifiability,config,configuration,110264,"lock:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110455,Modifiability,config,configuration,110455,"ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110877,Modifiability,config,configuration,110877,"port:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111122,Modifiability,config,configuration,111122," placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111595,Modifiability,config,configuration,111595,"eclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using std::string;; using std::chrono::duration_cast;. .. _SpaceAfterCStyleCast:. **SpaceAfterCStyleCast** (``Boolean``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceAfterCStyleCast>`; If ``true``, a space is inserted after C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113363,Modifiability,config,configuration,113363,"r C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113615,Modifiability,config,configuration,113615,"er the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113841,Modifiability,config,configuration,113841,"ef:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:114064,Modifiability,config,configuration,114064," **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break;; } }. .. _SpaceBeforeCpp11BracedList:. **SpaceBeforeCpp11BracedList** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCpp11BracedList>`; If ``true``, a space will be inserted before a C++11 braced list; used to i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:115862,Modifiability,inherit,inheritance,115862,":: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break;; } }. .. _SpaceBeforeCpp11BracedList:. **SpaceBeforeCpp11BracedList** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCpp11BracedList>`; If ``true``, a space will be inserted before a C++11 braced list; used to initialize an object (after the preceding identifier or type). .. code-block:: c++. true: false:; Foo foo { bar }; vs. Foo foo{ bar };; Foo {}; Foo{};; vector<int> { 1, 2, 3 }; vector<int>{ 1, 2, 3 };; new int[3] { 1, 2, 3 }; new int[3]{ 1, 2, 3 };. .. _SpaceBeforeCtorInitializerColon:. **SpaceBeforeCtorInitializerColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCtorInitializerColon>`; If ``false``, spaces will be removed before constructor initializer; colon. .. code-block:: c++. true: false:; Foo::Foo() : a(a) {} Foo::Foo(): a(a) {}. .. _SpaceBeforeInheritanceColon:. **SpaceBeforeInheritanceColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeInheritanceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatement",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:116551,Modifiability,config,configuration,116551,"oo::Foo() : a(a) {} Foo::Foo(): a(a) {}. .. _SpaceBeforeInheritanceColon:. **SpaceBeforeInheritanceColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeInheritanceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:116757,Modifiability,config,configuration,116757,"nceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117007,Modifiability,config,configuration,117007,":ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Config",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117464,Modifiability,config,configuration,117464,"eses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117686,Modifiability,config,configuration,117686,"a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118023,Modifiability,config,configuration,118023,"me as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118678,Modifiability,config,configuration,118678,"n configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code-block:: c++. true: false:; if (...) {} vs. if(...) {}. * ``bool AfterForeachMacros`` If ``true``, put space between foreach macros and opening parentheses. .. code-block:: c++. true: false:; FOREACH (...) vs. FOREACH(...); <loop-body> <loop-body>. * ``bool AfterFunctionDeclarationName`` If ``true``, put a space between function declaration name and opening; parentheses. .. code-block:: c++. true: false:; void f (); vs. void f();. * ``bool AfterFunctionDefinitionName`` If ``true``, put a space between function definition name and opening; parentheses. .. code-block:: c++. true: false:; void f () {} vs. void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123319,Modifiability,config,configuration,123319,"pacesInParensOptions``. .. _SpacesBeforeTrailingComments:. **SpacesBeforeTrailingComments** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesBeforeTrailingComments>`; The number of spaces before trailing line comments; (``//`` - comments). This does not affect trailing block comments (``/*`` - comments) as those; commonly have different usage patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123488,Modifiability,config,configuration,123488,"ngComments>`; The number of spaces before trailing line comments; (``//`` - comments). This does not affect trailing block comments (``/*`` - comments) as those; commonly have different usage patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123658,Modifiability,config,configuration,123658,"ge patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInContainerLiterals>`; If ``true``, spaces are inserted inside container literals (e.g. ObjC and; Javascript array and dict literals). For J",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:125774,Modifiability,config,configuration,125774," arr = [ 1, 2, 3 ]; vs. var arr = [1, 2, 3];; f({a : 1, b : 2, c : 3}); f({a: 1, b: 2, c: 3});. .. _SpacesInLineCommentPrefix:. **SpacesInLineCommentPrefix** (``SpacesInLineComment``) :versionbadge:`clang-format 13` :ref:`¶ <SpacesInLineCommentPrefix>`; How many spaces are allowed at the start of a line comment. To disable the; maximum set it to ``-1``, apart from that the maximum takes precedence; over the minimum. .. code-block:: c++. Minimum = 1; Maximum = -1; // One space is forced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126248,Modifiability,config,configuration,126248,"ced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126388,Modifiability,config,configuration,126388,"e relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126998,Modifiability,config,configuration,126998,". .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ) { ... } while (i < 5) { ... }. * ``bool InCStyleCasts`` Put a space in C style casts. .. code-block:: c++. true: false:; x = ( int32 )y vs. x = (int32)y. * ``bool InEmptyParentheses`` Put a space in parentheses only if the parentheses are empty i.e. '()'. .. code-block:: c++. true: false:; void f( ) { vs. void f() {; int x[] = {foo( ), bar( )}; int x[] = {foo(), bar()};; if (true) { if (true) {; f( ); f();; } }; } }. * ``bool Other`` Put a space in parentheses not covered by preceding options. .. code-block:: c++. true: false:; t f( Deleted & ) & = delete; vs. t f(Dele",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129147,Modifiability,config,configuration,129147,"``, spaces will be inserted after ``(`` and before ``)``.; This option is **deprecated**. The previous behavior is preserved by using; ``SpacesInParens`` with ``Custom`` and by setting all; ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; Statement",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129268,Modifiability,config,configuration,129268,"ved by using; ``SpacesInParens`` with ``Custom`` and by setting all; ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignCo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129341,Modifiability,config,configuration,129341,"acesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129414,Modifiability,config,configuration,129414,"mptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _State",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129487,Modifiability,config,configuration,129487,"* (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129561,Modifiability,config,configuration,129561,"e``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129718,Modifiability,config,configuration,129718,". .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to mak",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:130256,Modifiability,variab,variable,130256,"03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; id",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:131604,Modifiability,config,configuration,131604,"l macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; align",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:131636,Modifiability,config,configured,131636,"l macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; align",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132111,Modifiability,config,configuration,132111,"es. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132181,Modifiability,config,configuration,132181,"ntifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132291,Modifiability,config,configuration,132291," :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132516,Modifiability,config,configuration,132516,"lock:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132648,Modifiability,config,configuration,132648,"F', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Addi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133506,Modifiability,config,configuration,133506,"ation: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133538,Modifiability,config,configured,133538,"ation: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:45534,Performance,load,loader,45534,"n: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:45559,Performance,load,loader,45559,"n: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2505,Safety,detect,detects,2505,"ile located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:2753,Safety,detect,detect,2753,"-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:63015,Safety,detect,detects,63015,"/* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:63485,Safety,risk,risk,63485,"c:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:98496,Safety,detect,detecting,98496,"tom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _RawStringFormats:. **RawStringFormats** (``List of RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102640,Safety,redund,redundant,102640,"s option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); handleFunctionDecl(D); handleFunctionDecl(D);; } else if (isa<VarDecl>(D)) { else if (isa<VarDecl>(D)); handleVarDecl(D); handleVarDecl(D);; }. if (isa<VarDecl>(D)) { vs. if (isa<VarDecl>(D)) {; for (auto *A : D.attrs()) { for (auto *A : D.attrs()); if (shouldProcessAttr(A)) { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129754,Safety,detect,detection,129754,". .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to mak",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:6956,Security,access,access,6956,"h `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60775,Security,access,access,60775," {}, {}, {} };; f(MyMap[{composite, key}]); f(MyMap[{ composite, key }]);; new int[3]{1, 2, 3}; new int[3]{ 1, 2, 3 };. .. _DeriveLineEnding:. **DeriveLineEnding** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60889,Security,access,access,60889,"ng** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61004,Security,access,access,61004,"LF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61237,Security,access,access,61237,st common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBl,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61376,Security,access,access,61376,ile.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61816,Security,access,access,61816,difier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; pri,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61932,Security,access,access,61932,fiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62166,Security,access,access,62166,"vate:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62273,Security,access,access,62273,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62600,Security,access,access,62600,"AccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNam",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62624,Security,access,access,62624,"AccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNam",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69831,Security,access,access,69831,"or files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69905,Security,access,access,69905,"nly when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:70097,Security,access,access,70097,"ce; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:70247,Security,access,access,70247,"tensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; } {; plop();; }; }. .. _IndentCaseLabels:. **IndentCaseLabels** (``Boolean``) :versionbadge:`cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73397,Security,hash,hash,73397,"nt`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73566,Security,hash,hash,73566,"`); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. IndentWidth: 3. void f() {; someFunction();; if (true, false) {; f();; }; }. .. _IndentWrappedFunctionNames:. **IndentWrappedFunctionNames** (``Boolean``) :versionbadge:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:134647,Security,access,accessible,134647,"ample: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8760,Testability,test,test,8760,"ode-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignCon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8972,Testability,test,test,8972,"ackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19271,Testability,log,log,19271,"ool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19304,Testability,log,log,19304,"ool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19393,Testability,log,log,19393,"me length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19426,Testability,log,log,19426,"me length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19600,Testability,log,log,19600,". a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines**",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19633,Testability,log,log,19633,". a = 2;; bbb >>= 2;. .. _AlignConsecutiveShortCaseStatements:. **AlignConsecutiveShortCaseStatements** (``ShortCaseStatementsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines**",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19722,Testability,log,log,19722,"entsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19755,Testability,log,log,19755,"entsAlignmentStyle``) :versionbadge:`clang-format 17` :ref:`¶ <AlignConsecutiveShortCaseStatements>`; Style of aligning consecutive short case labels.; Only applies if ``AllowShortCaseLabelsOnASingleLine`` is ``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19924,Testability,log,log,19924,"``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:19957,Testability,log,log,19957,"``true``. .. code-block:: yaml. # Example of usage:; AlignConsecutiveShortCaseStatements:; Enabled: true; AcrossEmptyLines: true; AcrossComments: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20064,Testability,log,log,20064,"ents: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20097,Testability,log,log,20097,"ents: true; AlignCaseColons: false. Nested configuration flags:. Alignment options. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20352,Testability,log,log,20352,"l) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20386,Testability,log,log,20386,"l) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20476,Testability,log,log,20476,"ines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20509,Testability,log,log,20509,"ines`` Whether to align across empty lines. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";. default: return """";; }. * ``bool AcrossComments`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53417,Testability,test,test,53417,"..;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Brea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62302,Testability,log,logical,62302,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69465,Testability,log,logic,69465,"uffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-format 10` :ref:`¶ <IncludeIsMainSourceRegex>`; Specify a regular expression for files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80229,Testability,test,test,80229,"th a minimum number of; digits. .. code-block:: text. // Hex: 2; // HexMinDigits: 6; h1 = 0xABCDE;; h2 = 0xAB'CD'EF;. .. _JavaImportGroups:. **JavaImportGroups** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <JavaImportGroups>`; A vector of prefixes ordered by the desired groups for Java imports. One group's prefix can be a subset of another - the longest prefix is; always matched. Within a group, the imports are ordered lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80379,Testability,test,test,80379,"ortGroups** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <JavaImportGroups>`; A vector of prefixes ordered by the desired groups for Java imports. One group's prefix can be a subset of another - the longest prefix is; always matched. Within a group, the imports are ordered lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:112652,Testability,log,logical,112652,"n configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using std::string;; using std::chrono::duration_cast;. .. _SpaceAfterCStyleCast:. **SpaceAfterCStyleCast** (``Boolean``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceAfterCStyleCast>`; If ``true``, a space is inserted after C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:135127,Testability,test,test,135127,"ake; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c++. void test(); {; switch (suffix); {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y); {; q();; }; else if (x > y); {; w();; }; else; {; r();; }; }; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:135650,Testability,test,test,135650,"ake; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c++. void test(); {; switch (suffix); {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y); {; q();; }; else if (x > y); {; w();; }; else; {; r();; }; }; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:4998,Usability,usab,usable,4998,"rmat on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5532,Usability,guid,guide,5532,"mat::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5651,Usability,guid,guide,5651,"vm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5808,Usability,guid,guide,5808,"supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5950,Usability,guid,guide,5950,"enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:6069,Usability,guid,guide,6069," ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26155,Usability,simpl,simple,26155," :versionbadge:`clang-format 3.3` :ref:`¶ <AllowAllParametersOfDeclarationOnNextLine>`; If the function declaration doesn't fit on a line,; allow putting all parameters of a function declaration onto; the next line even if ``BinPackParameters`` is ``false``. .. code-block:: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133074,Usability,clear,clear,133074,"e values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133142,Usability,clear,clear,133142,"tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:134664,Usability,guid,guide,134664,"ample: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:19440,Energy Efficiency,monitor,monitor,19440,86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:86159,Energy Efficiency,reduce,reduce,86159,lvm-mca/Views; - `20`; - `19`; - `1`; - :part:`95%`; * - llvm/tools/llvm-microsoft-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-ml; - `3`; - `1`; - `2`; - :part:`33%`; * - llvm/tools/llvm-modextract; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-mt; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-nm; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-objcopy; - `3`; - `2`; - `1`; - :part:`66%`; * - llvm/tools/llvm-objdump; - `15`; - `10`; - `5`; - :part:`66%`; * - llvm/tools/llvm-opt-fuzzer; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/tools/llvm-opt-report; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-pdbutil; - `47`; - `15`; - `32`; - :part:`31%`; * - llvm/tools/llvm-profdata; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-profgen; - `11`; - `6`; - `5`; - :part:`54%`; * - llvm/tools/llvm-rc; - `12`; - `6`; - `6`; - :part:`50%`; * - llvm/tools/llvm-readobj; - `19`; - `3`; - `16`; - :part:`15%`; * - llvm/tools/llvm-reduce; - `7`; - `6`; - `1`; - :part:`85%`; * - llvm/tools/llvm-reduce/deltas; - `40`; - `39`; - `1`; - :part:`97%`; * - llvm/tools/llvm-rtdyld; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-rust-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-sim; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-size; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-special-case-list-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-split; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-stress; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-strings; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-symbolizer; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-tapi-diff; - `3`; - `3`; - `0`; - :good:`100%`; * - llvm/tools/llvm-tli-checker; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-undname; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/ll,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:86223,Energy Efficiency,reduce,reduce,86223,ols/llvm-microsoft-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-ml; - `3`; - `1`; - `2`; - :part:`33%`; * - llvm/tools/llvm-modextract; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-mt; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-nm; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-objcopy; - `3`; - `2`; - `1`; - :part:`66%`; * - llvm/tools/llvm-objdump; - `15`; - `10`; - `5`; - :part:`66%`; * - llvm/tools/llvm-opt-fuzzer; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/tools/llvm-opt-report; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-pdbutil; - `47`; - `15`; - `32`; - :part:`31%`; * - llvm/tools/llvm-profdata; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-profgen; - `11`; - `6`; - `5`; - :part:`54%`; * - llvm/tools/llvm-rc; - `12`; - `6`; - `6`; - :part:`50%`; * - llvm/tools/llvm-readobj; - `19`; - `3`; - `16`; - :part:`15%`; * - llvm/tools/llvm-reduce; - `7`; - `6`; - `1`; - :part:`85%`; * - llvm/tools/llvm-reduce/deltas; - `40`; - `39`; - `1`; - :part:`97%`; * - llvm/tools/llvm-rtdyld; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-rust-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-sim; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-size; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-special-case-list-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-split; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-stress; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-strings; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-symbolizer; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-tapi-diff; - `3`; - `3`; - `0`; - :good:`100%`; * - llvm/tools/llvm-tli-checker; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-undname; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-xray; - `19`; - `15`; - `4`; - :part:`78%`; * - llvm/tools/ll,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:107292,Energy Efficiency,reduce,reduce,107292,:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/AMX; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/ArmNeon; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/ArmSVE; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/LLVMIR; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/NVVM; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/OpenACC; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/OpenMP; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/ROCDL; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/LLVMIR/Dialect/X86Vector; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Target/SPIRV; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/include/mlir/Tools/mlir-lsp-server; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Tools/mlir-reduce; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Tools/PDLL/AST; - `4`; - `2`; - `2`; - :part:`50%`; * - mlir/include/mlir/Tools/PDLL/CodeGen; - `2`; - `2`; - `0`; - :good:`100%`; * - mlir/include/mlir/Tools/PDLL/ODS; - `4`; - `4`; - `0`; - :good:`100%`; * - mlir/include/mlir/Tools/PDLL/Parser; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir/Transforms; - `9`; - `7`; - `2`; - :part:`77%`; * - mlir/include/mlir-c; - `15`; - `15`; - `0`; - :good:`100%`; * - mlir/include/mlir-c/Bindings/Python; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/include/mlir-c/Dialect; - `11`; - `11`; - `0`; - :good:`100%`; * - mlir/lib/Analysis; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/lib/Analysis/AliasAnalysis; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Analysis/Presburger; - `8`; - `8`; - `0`; - :good:`100%`; * - mlir/lib/Bindings/Python; - `23`; - `23`; - `0`; - :good:`100%`; * - mlir/lib/Bindings/Python/Conversions; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Bin,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:119144,Energy Efficiency,reduce,reduce,119144,ArmNeon; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/ArmSVE; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/LLVMIR; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/NVVM; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/OpenACC; - `1`; - `0`; - `1`; - :none:`0%`; * - mlir/lib/Target/LLVMIR/Dialect/OpenMP; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/ROCDL; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/LLVMIR/Dialect/X86Vector; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Target/SPIRV; - `2`; - `2`; - `0`; - :good:`100%`; * - mlir/lib/Target/SPIRV/Deserialization; - `4`; - `3`; - `1`; - :part:`75%`; * - mlir/lib/Target/SPIRV/Serialization; - `4`; - `3`; - `1`; - :part:`75%`; * - mlir/lib/Tools/mlir-lsp-server; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/lib/Tools/mlir-lsp-server/lsp; - `6`; - `4`; - `2`; - :part:`66%`; * - mlir/lib/Tools/mlir-reduce; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Tools/PDLL/AST; - `6`; - `5`; - `1`; - :part:`83%`; * - mlir/lib/Tools/PDLL/CodeGen; - `2`; - `1`; - `1`; - :part:`50%`; * - mlir/lib/Tools/PDLL/ODS; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/lib/Tools/PDLL/Parser; - `3`; - `1`; - `2`; - :part:`33%`; * - mlir/lib/Transforms; - `13`; - `11`; - `2`; - :part:`84%`; * - mlir/lib/Transforms/Utils; - `6`; - `6`; - `0`; - :good:`100%`; * - mlir/lib/Translation; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-cpu-runner; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-linalg-ods-gen; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-lsp-server; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-opt; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-pdll; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-reduce; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-spirv-cpu-ru,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:120007,Energy Efficiency,reduce,reduce,120007,`5`; - `4`; - `1`; - :part:`80%`; * - mlir/lib/Tools/mlir-lsp-server/lsp; - `6`; - `4`; - `2`; - :part:`66%`; * - mlir/lib/Tools/mlir-reduce; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/lib/Tools/PDLL/AST; - `6`; - `5`; - `1`; - :part:`83%`; * - mlir/lib/Tools/PDLL/CodeGen; - `2`; - `1`; - `1`; - :part:`50%`; * - mlir/lib/Tools/PDLL/ODS; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/lib/Tools/PDLL/Parser; - `3`; - `1`; - `2`; - :part:`33%`; * - mlir/lib/Transforms; - `13`; - `11`; - `2`; - :part:`84%`; * - mlir/lib/Transforms/Utils; - `6`; - `6`; - `0`; - :good:`100%`; * - mlir/lib/Translation; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-cpu-runner; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-linalg-ods-gen; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-lsp-server; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-opt; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-pdll; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-reduce; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-spirv-cpu-runner; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-tblgen; - `29`; - `28`; - `1`; - :part:`96%`; * - mlir/tools/mlir-translate; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/tools/mlir-vulkan-runner; - `4`; - `4`; - `0`; - :good:`100%`; * - mlir/unittests/Analysis/Presburger; - `8`; - `8`; - `0`; - :good:`100%`; * - mlir/unittests/Conversion/PDLToPDLInterp; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/Affine/Analysis; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/Quant; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/SparseTensor; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/SPIRV; - `2`; - `2`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/Utils; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittest,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:11878,Integrability,wrap,wrapper,11878,`1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:11952,Integrability,wrap,wrapper,11952,`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `1,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:12102,Integrability,wrap,wrapper,12102, * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `13`; - `1`; - :part:`92%`; * - clang/unittests/AST; - `30`; - `8`; - `22`; - :part:`26%`; * - clang/unittests/ASTMatchers; - `6`; - `3`; - `3`; - :part,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:37280,Integrability,synchroniz,synchronization,37280,/generic/include/clc/cl_khr_local_int32_base_atomics; - `6`; - `5`; - `1`; - :part:`83%`; * - libclc/generic/include/clc/cl_khr_local_int32_extended_atomics; - `5`; - `5`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/common; - `6`; - `6`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/explicit_fence; - `1`; - `1`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/float; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/generic/include/clc/geometric; - `8`; - `8`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/image; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/integer; - `16`; - `13`; - `3`; - :part:`81%`; * - libclc/generic/include/clc/math; - `95`; - `92`; - `3`; - :part:`96%`; * - libclc/generic/include/clc/misc; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/relational; - `18`; - `12`; - `6`; - :part:`66%`; * - libclc/generic/include/clc/shared; - `5`; - `3`; - `2`; - :part:`60%`; * - libclc/generic/include/clc/synchronization; - `2`; - `2`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/workitem; - `8`; - `8`; - `0`; - :good:`100%`; * - libclc/generic/include/integer; - `1`; - `1`; - `0`; - :good:`100%`; * - libclc/generic/include/math; - `15`; - `15`; - `0`; - :good:`100%`; * - libclc/generic/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/generic/lib/math; - `8`; - `1`; - `7`; - :part:`12%`; * - libclc/generic/lib/relational; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/utils; - `1`; - `0`; - `1`; - :none:`0%`; * - libcxx/benchmarks; - `28`; - `10`; - `18`; - :part:`35%`; * - libcxx/include; - `22`; - `0`; - `22`; - :none:`0%`; * - libcxx/include/__algorithm; - `102`; - `15`; - `87`; - :part:`14%`; * - libcxx/include/__bit; - `2`; - `0`; - `2`; - :none:`0%`; * - libcxx/include/__charconv; - `3`; - `0`; - `3`; - :none:`0%`; * - libcxx/include/__chrono; - `8`; - `0`; - `8`; - :none:`0%`; * - libcxx/include/__compare; - `13`; - `1`; - `12`; - :part:`7%`; * - libcxx/include/__concepts; - `2,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:124487,Integrability,interface,interface,124487,ls/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/ben,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6697,Modifiability,plugin,plugins,6697,ling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/include/clang/Tooling/DependencyScanning; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6792,Modifiability,plugin,plugins,6792,g; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/linux; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/l,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6881,Modifiability,plugin,plugins,6881,; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/linux; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/mac; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatche,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:12237,Modifiability,refactor,refactor,12237,00%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `13`; - `1`; - :part:`92%`; * - clang/unittests/AST; - `30`; - `8`; - `22`; - :part:`26%`; * - clang/unittests/ASTMatchers; - `6`; - `3`; - `3`; - :part:`50%`; * - clang/unittests/ASTMatchers/Dynamic; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/unittests/Basic; - `8`; - `4`; - `4`; - :p,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:15874,Modifiability,plugin,plugin,15874,ls/TableGen; - `22`; - `3`; - `19`; - :part:`13%`; * - clang-tools-extra/clang-apply-replacements/include/clang-apply-replacements/Tooling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-apply-replacements/lib/Tooling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-apply-replacements/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-change-namespace; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/clang-change-namespace/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-doc; - `17`; - `16`; - `1`; - :part:`94%`; * - clang-tools-extra/clang-doc/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-include-fixer; - `13`; - `8`; - `5`; - :part:`61%`; * - clang-tools-extra/clang-include-fixer/find-all-symbols; - `17`; - `13`; - `4`; - :part:`76%`; * - clang-tools-extra/clang-include-fixer/find-all-symbols/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-include-fixer/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-include-fixer/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-move; - `4`; - `1`; - `3`; - :part:`25%`; * - clang-tools-extra/clang-move/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-query; - `5`; - `4`; - `1`; - :part:`80%`; * - clang-tools-extra/clang-query/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-reorder-fields; - `2`; - `1`; - `1`; - :part:`50%`; * - clang-tools-extra/clang-reorder-fields/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-tidy; - `20`; - `14`; - `6`; - :part:`70%`; * - clang-tools-extra/clang-tidy/abseil; - `42`; - `31`; - `11`; - :part:`73%`; * - clang-tools-extra/clang-tidy/altera; - `11`; - `9`; - `2`; - :part:`81%`; * - clang-tools-extra/clang-tidy/android; - `33`; - `23`; - `10`; - :part:`69%`; * - clang-tools-extra/clang-tidy/boost; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18238,Modifiability,plugin,plugin,18238,- :part:`40%`; * - clang-tools-extra/clang-tidy/fuchsia; - `15`; - `10`; - `5`; - :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18316,Modifiability,portab,portability,18316, :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:19771,Modifiability,refactor,refactor,19771,ngd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks; - `20`; - `19`; - `1`; - :part:`95%`; * - clang-tools-extra/clangd/unittests/xpc; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/framework; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/test-client; - `1`; - `1`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:19846,Modifiability,refactor,refactor,19846,clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks; - `20`; - `19`; - `1`; - :part:`95%`; * - clang-tools-extra/clangd/unittests/xpc; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/framework; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/test-client; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/modularize; - `9`; - `1`; - `8,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:31886,Modifiability,config,config,31886,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:41793,Modifiability,plugin,plugins,41793,rt:`10%`; * - lld/COFF; - `37`; - `13`; - `24`; - :part:`35%`; * - lld/Common; - `11`; - `9`; - `2`; - :part:`81%`; * - lld/ELF; - `48`; - `25`; - `23`; - :part:`52%`; * - lld/ELF/Arch; - `14`; - `4`; - `10`; - :part:`28%`; * - lld/include/lld/Common; - `14`; - `8`; - `6`; - :part:`57%`; * - lld/include/lld/Core; - `20`; - `4`; - `16`; - :part:`20%`; * - lld/MachO; - `45`; - `43`; - `2`; - :part:`95%`; * - lld/MachO/Arch; - `6`; - `6`; - `0`; - :good:`100%`; * - lld/MinGW; - `1`; - `1`; - `0`; - :good:`100%`; * - lld/tools/lld; - `1`; - `1`; - `0`; - :good:`100%`; * - lld/wasm; - `29`; - `15`; - `14`; - :part:`51%`; * - lldb/bindings/python; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/examples/darwin/heap_find/heap; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/examples/functions; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/examples/interposing/darwin/fd_interposing; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/examples/lookup; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/examples/plugins/commands; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/examples/synthetic/bitfield; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/include/lldb; - `12`; - `6`; - `6`; - :part:`50%`; * - lldb/include/lldb/API; - `70`; - `60`; - `10`; - :part:`85%`; * - lldb/include/lldb/Breakpoint; - `25`; - `9`; - `16`; - :part:`36%`; * - lldb/include/lldb/Core; - `61`; - `31`; - `30`; - :part:`50%`; * - lldb/include/lldb/DataFormatters; - `18`; - `10`; - `8`; - :part:`55%`; * - lldb/include/lldb/Expression; - `17`; - `7`; - `10`; - :part:`41%`; * - lldb/include/lldb/Host; - `39`; - `20`; - `19`; - :part:`51%`; * - lldb/include/lldb/Host/android; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/include/lldb/Host/common; - `8`; - `2`; - `6`; - :part:`25%`; * - lldb/include/lldb/Host/freebsd; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/include/lldb/Host/linux; - `6`; - `4`; - `2`; - :part:`66%`; * - lldb/include/lldb/Host/macosx; - `2`; - `0`; - `2`; - :none:`0%`; * - lldb/include/lldb/Host/netbsd; - `1,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:82573,Modifiability,config,config,82573,; - `11`; - `3`; - :part:`78%`; * - llvm/tools/bugpoint; - `12`; - `1`; - `11`; - :part:`8%`; * - llvm/tools/bugpoint-passes; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/dsymutil; - `18`; - `16`; - `2`; - :part:`88%`; * - llvm/tools/gold; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llc; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/lli; - `4`; - `3`; - `1`; - :part:`75%`; * - llvm/tools/lli/ChildTarget; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-ar; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-bcanalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-c-test; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/tools/llvm-cat; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify/lib; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-config; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cov; - `23`; - `12`; - `11`; - :part:`52%`; * - llvm/tools/llvm-cvtres; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cxxdump; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-cxxfilt; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-cxxmap; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-debuginfod-find; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-diff/lib; - `6`; - `0`; - `6`; - :none:`0%`; * - llvm/tools/llvm-dis; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-dis-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-dlang-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-dwarfdump; - `4`; - `3`; - `1`; - :part:`75%`; * - llvm/tools/llvm-dwarfdump/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-dwp; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-exegesis; -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:121829,Modifiability,plugin,plugins,121829,`; - :good:`100%`; * - mlir/unittests/Dialect/SPIRV; - `2`; - `2`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/Utils; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/li,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:121917,Modifiability,plugin,plugins,121917,; * - mlir/unittests/Dialect/Utils; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122000,Modifiability,plugin,plugins,122000,nittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122080,Modifiability,plugin,plugins,122080,s/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122168,Modifiability,plugin,plugins,122168,- `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122259,Modifiability,plugin,plugins,122259,ir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openm,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122347,Modifiability,plugin,plugins,122347, `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - open,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122424,Modifiability,plugin,plugins,122424, - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122516,Modifiability,plugin,plugins,122516, - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122601,Modifiability,plugin,plugins,122601,eviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122680,Modifiability,plugin,plugins,122680,DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122764,Modifiability,plugin,plugins,122764, - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122844,Modifiability,plugin,plugins,122844,mic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:17040,Performance,concurren,concurrency,17040,1`; - `3`; - :part:`25%`; * - clang-tools-extra/clang-move/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-query; - `5`; - `4`; - `1`; - :part:`80%`; * - clang-tools-extra/clang-query/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-reorder-fields; - `2`; - `1`; - `1`; - :part:`50%`; * - clang-tools-extra/clang-reorder-fields/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-tidy; - `20`; - `14`; - `6`; - :part:`70%`; * - clang-tools-extra/clang-tidy/abseil; - `42`; - `31`; - `11`; - :part:`73%`; * - clang-tools-extra/clang-tidy/altera; - `11`; - `9`; - `2`; - :part:`81%`; * - clang-tools-extra/clang-tidy/android; - `33`; - `23`; - `10`; - :part:`69%`; * - clang-tools-extra/clang-tidy/boost; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/bugprone; - `125`; - `106`; - `19`; - :part:`84%`; * - clang-tools-extra/clang-tidy/cert; - `29`; - `28`; - `1`; - :part:`96%`; * - clang-tools-extra/clang-tidy/concurrency; - `5`; - `4`; - `1`; - :part:`80%`; * - clang-tools-extra/clang-tidy/cppcoreguidelines; - `45`; - `42`; - `3`; - :part:`93%`; * - clang-tools-extra/clang-tidy/darwin; - `5`; - `2`; - `3`; - :part:`40%`; * - clang-tools-extra/clang-tidy/fuchsia; - `15`; - `10`; - `5`; - :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18154,Performance,perform,performance,18154,3`; - :part:`93%`; * - clang-tools-extra/clang-tidy/darwin; - `5`; - `2`; - `3`; - :part:`40%`; * - clang-tools-extra/clang-tidy/fuchsia; - `15`; - `10`; - `5`; - :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:32407,Performance,load,loader,32407,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:32475,Performance,load,loader,32475,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:59701,Performance,cache,cached,59701,%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2; - `2`; - `1`; - `1`; - :part:`50%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3; - `2`; - `1`; - `1`; - :part:`50%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter2; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/Kaleidoscope/Chapter3; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter4; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter5; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter6; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter7; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter8; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/Chapter9; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/include; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/Kaleidoscope/MCJIT/cached; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/examples/Kaleidoscope/MCJIT/complete; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/MCJIT/initial; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Kaleidoscope/MCJIT/lazy; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/examples/ModuleMaker; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/OrcV2Examples; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITDumpObjects; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITWithInitializers; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/OrcV2Examples/LLJITWithLazyReexports; - `1`; - `1`; - `0`; - :good:`100%`; * -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23971,Safety,safe,safestack,23971,p_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/li,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:21884,Security,sanitiz,sanitizer,21884,a/pp-trace; - `3`; - `1`; - `2`; - :part:`33%`; * - clang-tools-extra/tool-template; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-apply-replacements; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-change-namespace; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-doc; - `9`; - `9`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-include-fixer; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-include-fixer/find-all-symbols; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-move; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-query; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-tidy; - `16`; - `9`; - `7`; - :part:`56%`; * - clang-tools-extra/unittests/include/common; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/include/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/include/sanitizer; - `15`; - `3`; - `12`; - :part:`20%`; * - compiler-rt/include/xray; - `3`; - `2`; - `1`; - :part:`66%`; * - compiler-rt/lib/asan; - `57`; - `5`; - `52`; - :part:`8%`; * - compiler-rt/lib/asan/tests; - `17`; - `1`; - `16`; - :part:`5%`; * - compiler-rt/lib/BlocksRuntime; - `2`; - `0`; - `2`; - :none:`0%`; * - compiler-rt/lib/builtins; - `11`; - `9`; - `2`; - :part:`81%`; * - compiler-rt/lib/builtins/arm; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/builtins/ppc; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:2476,Testability,test,tests,2476,/include/bolt/RuntimeLibs; - `3`; - `3`; - `0`; - :good:`100%`; * - bolt/include/bolt/Utils; - `4`; - `4`; - `0`; - :good:`100%`; * - bolt/lib/Core; - `14`; - `5`; - `9`; - :part:`35%`; * - bolt/lib/Passes; - `45`; - `21`; - `24`; - :part:`46%`; * - bolt/lib/Profile; - `7`; - `3`; - `4`; - :part:`42%`; * - bolt/lib/Rewrite; - `6`; - `0`; - `6`; - :none:`0%`; * - bolt/lib/RuntimeLibs; - `3`; - `3`; - `0`; - :good:`100%`; * - bolt/lib/Target/AArch64; - `1`; - `0`; - `1`; - :none:`0%`; * - bolt/lib/Target/X86; - `1`; - `0`; - `1`; - :none:`0%`; * - bolt/lib/Utils; - `2`; - `1`; - `1`; - :part:`50%`; * - bolt/runtime; - `3`; - `0`; - `3`; - :none:`0%`; * - bolt/tools/driver; - `1`; - `0`; - `1`; - :none:`0%`; * - bolt/tools/heatmap; - `1`; - `1`; - `0`; - :good:`100%`; * - bolt/tools/llvm-bolt-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - bolt/tools/merge-fdata; - `1`; - `0`; - `1`; - :none:`0%`; * - bolt/unittests/Core; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/bindings/python/tests/cindex/INPUTS; - `5`; - `3`; - `2`; - :part:`60%`; * - clang/docs/analyzer/checkers; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/examples/AnnotateFunctions; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/examples/Attribute; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/examples/CallSuperAttribute; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/examples/PluginsOrder; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/examples/PrintFunctionNames; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/include/clang/Analysis; - `16`; - `4`; - `12`; - :part:`25%`; * - clang/include/clang/Analysis/Analyses; - `15`; - `3`; - `12`; - :part:`20%`; * - clang/include/clang/Analysis/DomainSpecific; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/include/clang/Analysis/FlowSensitive; - `16`; - `15`; - `1`; - :part:`93%`; * - clang/include/clang/Analysis/Support; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/include/clang/APINotes; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/ARCMigrate; - `3`; - `,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:10809,Testability,test,test,10809,; * - clang/lib/Testing; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Tooling; - `16`; - `7`; - `9`; - :part:`43%`; * - clang/lib/Tooling/ASTDiff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Tooling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Tooling/DependencyScanning; - `5`; - `4`; - `1`; - :part:`80%`; * - clang/lib/Tooling/DumpTool; - `4`; - `3`; - `1`; - :part:`75%`; * - clang/lib/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Refactoring; - `5`; - `3`; - `2`; - :part:`60%`; * - clang/lib/Tooling/Refactoring/Extract; - `2`; - `1`; - `1`; - :part:`50%`; * - clang/lib/Tooling/Refactoring/Rename; - `5`; - `2`; - `3`; - :part:`40%`; * - clang/lib/Tooling/Syntax; - `7`; - `6`; - `1`; - :part:`85%`; * - clang/lib/Tooling/Syntax/Pseudo; - `8`; - `8`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Transformer; - `7`; - `4`; - `3`; - :part:`57%`; * - clang/tools/amdgpu-arch; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/apinotes-test; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/arcmt-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:10874,Testability,test,test,10874, clang/lib/Tooling; - `16`; - `7`; - `9`; - :part:`43%`; * - clang/lib/Tooling/ASTDiff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Tooling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Tooling/DependencyScanning; - `5`; - `4`; - `1`; - :part:`80%`; * - clang/lib/Tooling/DumpTool; - `4`; - `3`; - `1`; - :part:`75%`; * - clang/lib/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Refactoring; - `5`; - `3`; - `2`; - :part:`60%`; * - clang/lib/Tooling/Refactoring/Extract; - `2`; - `1`; - `1`; - :part:`50%`; * - clang/lib/Tooling/Refactoring/Rename; - `5`; - `2`; - `3`; - :part:`40%`; * - clang/lib/Tooling/Syntax; - `7`; - `6`; - `1`; - :part:`85%`; * - clang/lib/Tooling/Syntax/Pseudo; - `8`; - `8`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Transformer; - `7`; - `4`; - `3`; - :part:`57%`; * - clang/tools/amdgpu-arch; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/apinotes-test; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/arcmt-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:10939,Testability,test,test,10939,g/lib/Tooling/ASTDiff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Tooling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Tooling/DependencyScanning; - `5`; - `4`; - `1`; - :part:`80%`; * - clang/lib/Tooling/DumpTool; - `4`; - `3`; - `1`; - :part:`75%`; * - clang/lib/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Refactoring; - `5`; - `3`; - `2`; - :part:`60%`; * - clang/lib/Tooling/Refactoring/Extract; - `2`; - `1`; - `1`; - :part:`50%`; * - clang/lib/Tooling/Refactoring/Rename; - `5`; - `2`; - `3`; - :part:`40%`; * - clang/lib/Tooling/Syntax; - `7`; - `6`; - `1`; - :part:`85%`; * - clang/lib/Tooling/Syntax/Pseudo; - `8`; - `8`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Transformer; - `7`; - `4`; - `3`; - :part:`57%`; * - clang/tools/amdgpu-arch; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/apinotes-test; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/arcmt-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/cla,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:11808,Testability,test,test,11808,est; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/arcmt-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:12767,Testability,test,tests,12767,ne:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `13`; - `1`; - :part:`92%`; * - clang/unittests/AST; - `30`; - `8`; - `22`; - :part:`26%`; * - clang/unittests/ASTMatchers; - `6`; - `3`; - `3`; - :part:`50%`; * - clang/unittests/ASTMatchers/Dynamic; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/unittests/Basic; - `8`; - `4`; - `4`; - :part:`50%`; * - clang/unittests/CodeGen; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/unittests/CrossTU; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/DirectoryWatcher; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/unittests/Driver; - `5`; - `1`; - `4`; - :part:`20%`; * - clang/unittests/Format; - `24`; - `24`; - `0`; - :good:`100%`; * - clang/unittests/Frontend; - `11`; - `7`; - `4`; - :part:`63%`; * - clang/unittests/Index; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Interpreter; - `2`; - `2`; - `0,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18779,Testability,benchmark,benchmarks,18779,; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18857,Testability,benchmark,benchmarks,18857,`48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:20749,Testability,test,test-client,20749,ls-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks; - `20`; - `19`; - `1`; - :part:`95%`; * - clang-tools-extra/clangd/unittests/xpc; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/framework; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/test-client; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/modularize; - `9`; - `1`; - `8`; - :part:`11%`; * - clang-tools-extra/pp-trace; - `3`; - `1`; - `2`; - :part:`33%`; * - clang-tools-extra/tool-template; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-apply-replacements; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-change-namespace; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-doc; - `9`; - `9`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-include-fixer; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-include-fixer/find-all-symbols; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-move; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-query; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-tidy; - `16`; - `9`; - `7`; - :part:`56%`; * - clang-tools-extra/unittests/include/commo,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:22087,Testability,test,tests,22087,- :good:`100%`; * - clang-tools-extra/unittests/clang-change-namespace; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-doc; - `9`; - `9`; - `0`; - :good:`100%`; * - clang-tools-extra/unittests/clang-include-fixer; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-include-fixer/find-all-symbols; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-move; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/unittests/clang-query; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/unittests/clang-tidy; - `16`; - `9`; - `7`; - :part:`56%`; * - clang-tools-extra/unittests/include/common; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/include/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/include/sanitizer; - `15`; - `3`; - `12`; - :part:`20%`; * - compiler-rt/include/xray; - `3`; - `2`; - `1`; - :part:`66%`; * - compiler-rt/lib/asan; - `57`; - `5`; - `52`; - :part:`8%`; * - compiler-rt/lib/asan/tests; - `17`; - `1`; - `16`; - :part:`5%`; * - compiler-rt/lib/BlocksRuntime; - `2`; - `0`; - `2`; - :none:`0%`; * - compiler-rt/lib/builtins; - `11`; - `9`; - `2`; - :part:`81%`; * - compiler-rt/lib/builtins/arm; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/builtins/ppc; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:22764,Testability,test,tests,22764,`0`; - `1`; - :none:`0%`; * - compiler-rt/include/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/include/sanitizer; - `15`; - `3`; - `12`; - :part:`20%`; * - compiler-rt/include/xray; - `3`; - `2`; - `1`; - :part:`66%`; * - compiler-rt/lib/asan; - `57`; - `5`; - `52`; - :part:`8%`; * - compiler-rt/lib/asan/tests; - `17`; - `1`; - `16`; - :part:`5%`; * - compiler-rt/lib/BlocksRuntime; - `2`; - `0`; - `2`; - :none:`0%`; * - compiler-rt/lib/builtins; - `11`; - `9`; - `2`; - :part:`81%`; * - compiler-rt/lib/builtins/arm; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/builtins/ppc; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23070,Testability,test,tests,23070,r-rt/lib/asan/tests; - `17`; - `1`; - `16`; - :part:`5%`; * - compiler-rt/lib/BlocksRuntime; - `2`; - `0`; - `2`; - :none:`0%`; * - compiler-rt/lib/builtins; - `11`; - `9`; - `2`; - :part:`81%`; * - compiler-rt/lib/builtins/arm; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/builtins/ppc; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23144,Testability,test,tests,23144,lib/BlocksRuntime; - `2`; - `0`; - `2`; - :none:`0%`; * - compiler-rt/lib/builtins; - `11`; - `9`; - `2`; - :part:`81%`; * - compiler-rt/lib/builtins/arm; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/builtins/ppc; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23375,Testability,test,tests,23375,- `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/cfi; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/dfsan; - `14`; - `9`; - `5`; - :part:`64%`; * - compiler-rt/lib/fuzzer; - `47`; - `9`; - `38`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23577,Testability,test,tests,23577,`; - :part:`19%`; * - compiler-rt/lib/fuzzer/afl; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/fuzzer/dataflow; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - comp,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:23710,Testability,test,tests,23710,`; - `3`; - :none:`0%`; * - compiler-rt/lib/fuzzer/tests; - `2`; - `1`; - `1`; - :part:`50%`; * - compiler-rt/lib/gwp_asan; - `12`; - `12`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/optional; - `10`; - `10`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/platform_specific; - `13`; - `13`; - `0`; - :good:`100%`; * - compiler-rt/lib/gwp_asan/tests; - `15`; - `14`; - `1`; - :part:`93%`; * - compiler-rt/lib/gwp_asan/tests/platform_specific; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:24220,Testability,test,tests,24220,ib/hwasan; - `30`; - `9`; - `21`; - :part:`30%`; * - compiler-rt/lib/interception; - `8`; - `1`; - `7`; - :part:`12%`; * - compiler-rt/lib/interception/tests; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/lsan; - `20`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`2,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:24443,Testability,benchmark,benchmarks,24443,0`; - `4`; - `16`; - :part:`20%`; * - compiler-rt/lib/memprof; - `31`; - `29`; - `2`; - :part:`93%`; * - compiler-rt/lib/memprof/tests; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/msan; - `18`; - `4`; - `14`; - :part:`22%`; * - compiler-rt/lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compi,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:24698,Testability,test,tests,24698,lib/msan/tests; - `4`; - `0`; - `4`; - :none:`0%`; * - compiler-rt/lib/orc; - `21`; - `16`; - `5`; - :part:`76%`; * - compiler-rt/lib/orc/unittests; - `10`; - `9`; - `1`; - :part:`90%`; * - compiler-rt/lib/profile; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:24911,Testability,benchmark,benchmarks,24911,- `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/safestack; - `3`; - `1`; - `2`; - :part:`33%`; * - compiler-rt/lib/sanitizer_common; - `167`; - `29`; - `138`; - :part:`17%`; * - compiler-rt/lib/sanitizer_common/symbolizer; - `2`; - `2`; - `0`; - :good:`100%`; * - compiler-rt/lib/sanitizer_common/tests; - `46`; - `12`; - `34`; - :part:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25253,Testability,test,tests,25253,rt:`26%`; * - compiler-rt/lib/scudo; - `20`; - `0`; - `20`; - :none:`0%`; * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfec,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25326,Testability,test,tests,25326, * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; *,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25600,Testability,test,tests,25600,alone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25736,Testability,test,tests,25736,%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_decl,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25752,Testability,test,tests,25752,-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25834,Testability,test,tests,25834,rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-te,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25850,Testability,test,tests,25850,`3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-te,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25950,Testability,test,tests,25950,0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cr,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25966,Testability,test,tests,25966,r-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-test,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26064,Testability,test,tests,26064,`1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26080,Testability,test,tests,26080,`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - c,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26198,Testability,test,tests,26198,3`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26214,Testability,test,tests,26214,art:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-pr,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26346,Testability,test,tests,26346,3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-test,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26362,Testability,test,tests,26362,rt:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26498,Testability,test,tests,26498,ne:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26514,Testability,test,tests,26514,piler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :par,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26671,Testability,test,tests,26671,_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26687,Testability,test,tests,26687,`2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26835,Testability,test,tests,26835,s/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`1,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26851,Testability,test,tests,26851,s/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26965,Testability,test,tests,26965,sts/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:26981,Testability,test,tests,26981,re_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27096,Testability,test,tests,27096,e_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27112,Testability,test,tests,27112,/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27223,Testability,test,tests,27223,/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/F,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27239,Testability,test,tests,27239,ommands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27329,Testability,test,tests,27329,cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27345,Testability,test,tests,27345,sts/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27452,Testability,test,tests,27452,; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27468,Testability,test,tests,27468,:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; -,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27481,Testability,test,tests,27481,cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27544,Testability,test,tests,27544,ds/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder; - `7`; - `7,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27560,Testability,test,tests,27560,eclare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder; - `7`; - `7`; - `0`; - :goo,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27572,Testability,test,tests,27572,precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder; - `7`; - `7`; - `0`; - :good:`100%`; * ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27632,Testability,test,tests,27632,; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder; - `7`; - `7`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder/Runtime; - `10`; - `,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:27648,Testability,test,tests,27648,; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/windows_noncanonical_path/source; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_finish_test; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/expect_step_kind; - `5`; - `0`; - `5`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps; - `8`; - `2`; - `6`; - :part:`25%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools; - `1`; - `0`; - `1`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/clang-opt-bisect; - `2`; - `0`; - `2`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter-tests; - `15`; - `3`; - `12`; - :part:`20%`; * - cross-project-tests/debuginfo-tests/llgdb-tests; - `8`; - `0`; - `8`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb; - `2`; - `1`; - `1`; - :part:`50%`; * - flang/examples; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/examples/FlangOmpReport; - `3`; - `3`; - `0`; - :good:`100%`; * - flang/examples/PrintFlangFunctionNames; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Common; - `21`; - `21`; - `0`; - :good:`100%`; * - flang/include/flang/Decimal; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Evaluate; - `23`; - `23`; - `0`; - :good:`100%`; * - flang/include/flang/Frontend; - `11`; - `10`; - `1`; - :part:`90%`; * - flang/include/flang/FrontendTool; - `1`; - `1`; - `0`; - :good:`100%`; * - flang/include/flang/Lower; - `25`; - `24`; - `1`; - :part:`96%`; * - flang/include/flang/Lower/Support; - `2`; - `2`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder; - `7`; - `7`; - `0`; - :good:`100%`; * - flang/include/flang/Optimizer/Builder/Runtime; - `10`; - `10`; - `0`; - :g,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:31587,Testability,benchmark,benchmarks,31587,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:31646,Testability,benchmark,benchmarks,31646,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:31734,Testability,benchmark,benchmarks,31734,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:31807,Testability,benchmark,benchmarks,31807,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:32546,Testability,assert,assert,32546, - `0`; - `1`; - :none:`0%`; * - libc/benchmarks; - `15`; - `14`; - `1`; - :part:`93%`; * - libc/benchmarks/automemcpy/include/automemcpy; - `4`; - `4`; - `0`; - :good:`100%`; * - libc/benchmarks/automemcpy/lib; - `5`; - `5`; - `0`; - :good:`100%`; * - libc/benchmarks/automemcpy/unittests; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/config/linux; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/fuzzing/math; - `6`; - `6`; - `0`; - :good:`100%`; * - libc/fuzzing/stdlib; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/fuzzing/string; - `3`; - `2`; - `1`; - :part:`66%`; * - libc/include; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-macros; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-macros/linux; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-types; - `28`; - `28`; - `0`; - :good:`100%`; * - libc/loader/linux/aarch64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/loader/linux/x86_64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/src/assert; - `3`; - `1`; - `2`; - :part:`33%`; * - libc/src/ctype; - `32`; - `32`; - `0`; - :good:`100%`; * - libc/src/errno; - `4`; - `4`; - `0`; - :good:`100%`; * - libc/src/fcntl; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/fcntl/linux; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/fenv; - `28`; - `28`; - `0`; - :good:`100%`; * - libc/src/inttypes; - `6`; - `6`; - `0`; - :good:`100%`; * - libc/src/math; - `91`; - `91`; - `0`; - :good:`100%`; * - libc/src/math/aarch64; - `10`; - `10`; - `0`; - :good:`100%`; * - libc/src/math/generic; - `94`; - `94`; - `0`; - :good:`100%`; * - libc/src/math/x86_64; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/signal; - `8`; - `8`; - `0`; - :good:`100%`; * - libc/src/signal/linux; - `10`; - `10`; - `0`; - :good:`100%`; * - libc/src/stdio; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/stdlib; - `46`; - `46`; - `0`; - :good:`100%`; * - libc/src/stdlib/linux; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/src/string; - `61`; - `61`; - `0`; - :g,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:35414,Testability,test,testutils,35414,5`; - `14`; - `1`; - :part:`93%`; * - libc/src/__support/FPUtil/aarch64; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/__support/FPUtil/generic; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/__support/FPUtil/x86_64; - `6`; - `5`; - `1`; - :part:`83%`; * - libc/src/__support/OSUtil; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/__support/OSUtil/linux; - `3`; - `2`; - `1`; - :part:`66%`; * - libc/src/__support/OSUtil/linux/aarch64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/src/__support/OSUtil/linux/x86_64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/src/__support/threads; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/src/__support/threads/linux; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/utils/HdrGen; - `9`; - `9`; - `0`; - :good:`100%`; * - libc/utils/HdrGen/PrototypeTestGen; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/utils/LibcTableGenUtil; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/utils/MPFRWrapper; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/utils/testutils; - `10`; - `9`; - `1`; - :part:`90%`; * - libc/utils/tools/WrapperGen; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/utils/UnitTest; - `12`; - `11`; - `1`; - :part:`91%`; * - libclc/generic/include; - `2`; - `1`; - `1`; - :part:`50%`; * - libclc/generic/include/clc; - `6`; - `2`; - `4`; - :part:`33%`; * - libclc/generic/include/clc/async; - `4`; - `4`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/atomic; - `11`; - `7`; - `4`; - :part:`63%`; * - libclc/generic/include/clc/cl_khr_global_int32_base_atomics; - `6`; - `5`; - `1`; - :part:`83%`; * - libclc/generic/include/clc/cl_khr_global_int32_extended_atomics; - `5`; - `5`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/cl_khr_int64_base_atomics; - `6`; - `3`; - `3`; - :part:`50%`; * - libclc/generic/include/clc/cl_khr_int64_extended_atomics; - `5`; - `5`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/cl_khr_local_int32_base_atomics; - `6`; - `5`; - `1`; - :part:`83%`; * - libclc/generic/include/clc/cl_khr_loc,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:37815,Testability,benchmark,benchmarks,37815,e/clc/image; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/integer; - `16`; - `13`; - `3`; - :part:`81%`; * - libclc/generic/include/clc/math; - `95`; - `92`; - `3`; - :part:`96%`; * - libclc/generic/include/clc/misc; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/relational; - `18`; - `12`; - `6`; - :part:`66%`; * - libclc/generic/include/clc/shared; - `5`; - `3`; - `2`; - :part:`60%`; * - libclc/generic/include/clc/synchronization; - `2`; - `2`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/workitem; - `8`; - `8`; - `0`; - :good:`100%`; * - libclc/generic/include/integer; - `1`; - `1`; - `0`; - :good:`100%`; * - libclc/generic/include/math; - `15`; - `15`; - `0`; - :good:`100%`; * - libclc/generic/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/generic/lib/math; - `8`; - `1`; - `7`; - :part:`12%`; * - libclc/generic/lib/relational; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/utils; - `1`; - `0`; - `1`; - :none:`0%`; * - libcxx/benchmarks; - `28`; - `10`; - `18`; - :part:`35%`; * - libcxx/include; - `22`; - `0`; - `22`; - :none:`0%`; * - libcxx/include/__algorithm; - `102`; - `15`; - `87`; - :part:`14%`; * - libcxx/include/__bit; - `2`; - `0`; - `2`; - :none:`0%`; * - libcxx/include/__charconv; - `3`; - `0`; - `3`; - :none:`0%`; * - libcxx/include/__chrono; - `8`; - `0`; - `8`; - :none:`0%`; * - libcxx/include/__compare; - `13`; - `1`; - `12`; - :part:`7%`; * - libcxx/include/__concepts; - `22`; - `0`; - `22`; - :none:`0%`; * - libcxx/include/__coroutine; - `4`; - `0`; - `4`; - :none:`0%`; * - libcxx/include/__filesystem; - `16`; - `3`; - `13`; - :part:`18%`; * - libcxx/include/__format; - `17`; - `2`; - `15`; - :part:`11%`; * - libcxx/include/__functional; - `27`; - `0`; - `27`; - :none:`0%`; * - libcxx/include/__ios; - `1`; - `0`; - `1`; - :none:`0%`; * - libcxx/include/__iterator; - `36`; - `0`; - `36`; - :none:`0%`; * - libcxx/include/__memory; - `19`; - `1`; - `18`; - :part:`5%`; * - libcxx/include/__numeric; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:54125,Testability,test,test,54125,- `1`; - `0`; - :good:`100%`; * - lldb/tools/argdumper; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/tools/darwin-debug; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/tools/debugserver/source; - `51`; - `40`; - `11`; - :part:`78%`; * - lldb/tools/debugserver/source/MacOSX; - `24`; - `16`; - `8`; - :part:`66%`; * - lldb/tools/debugserver/source/MacOSX/arm; - `2`; - `1`; - `1`; - :part:`50%`; * - lldb/tools/debugserver/source/MacOSX/arm64; - `2`; - `1`; - `1`; - :part:`50%`; * - lldb/tools/debugserver/source/MacOSX/i386; - `3`; - `0`; - `3`; - :none:`0%`; * - lldb/tools/debugserver/source/MacOSX/x86_64; - `3`; - `0`; - `3`; - :none:`0%`; * - lldb/tools/driver; - `4`; - `4`; - `0`; - :good:`100%`; * - lldb/tools/intel-features; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/tools/intel-features/intel-mpx; - `2`; - `1`; - `1`; - :part:`50%`; * - lldb/tools/lldb-instr; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/tools/lldb-server; - `9`; - `4`; - `5`; - :part:`44%`; * - lldb/tools/lldb-test; - `5`; - `2`; - `3`; - :part:`40%`; * - lldb/tools/lldb-vscode; - `27`; - `24`; - `3`; - :part:`88%`; * - lldb/unittests; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/API; - `2`; - `2`; - `0`; - :good:`100%`; * - lldb/unittests/Breakpoint; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/Core; - `10`; - `9`; - `1`; - :part:`90%`; * - lldb/unittests/DataFormatter; - `3`; - `3`; - `0`; - :good:`100%`; * - lldb/unittests/debugserver; - `3`; - `2`; - `1`; - :part:`66%`; * - lldb/unittests/Disassembler; - `2`; - `0`; - `2`; - :none:`0%`; * - lldb/unittests/Editline; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/Expression; - `5`; - `3`; - `2`; - :part:`60%`; * - lldb/unittests/Host; - `16`; - `11`; - `5`; - :part:`68%`; * - lldb/unittests/Host/linux; - `2`; - `2`; - `0`; - :good:`100%`; * - lldb/unittests/Host/posix; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/Instruction; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/Interpreter; - `6`; - `2,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:57461,Testability,test,tests,57461,:part:`66%`; * - lldb/unittests/Signals; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/Symbol; - `11`; - `7`; - `4`; - :part:`63%`; * - lldb/unittests/SymbolFile/DWARF; - `6`; - `4`; - `2`; - :part:`66%`; * - lldb/unittests/SymbolFile/DWARF/Inputs; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/SymbolFile/NativePDB; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/SymbolFile/PDB; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/SymbolFile/PDB/Inputs; - `5`; - `5`; - `0`; - :good:`100%`; * - lldb/unittests/Target; - `10`; - `6`; - `4`; - :part:`60%`; * - lldb/unittests/TestingSupport; - `5`; - `4`; - `1`; - :part:`80%`; * - lldb/unittests/TestingSupport/Host; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/TestingSupport/Symbol; - `3`; - `3`; - `0`; - :good:`100%`; * - lldb/unittests/Thread; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/tools/lldb-server/inferior; - `2`; - `0`; - `2`; - :none:`0%`; * - lldb/unittests/tools/lldb-server/tests; - `7`; - `0`; - `7`; - :none:`0%`; * - lldb/unittests/UnwindAssembly/ARM64; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/UnwindAssembly/PPC64; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/UnwindAssembly/x86; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/Utility; - `45`; - `32`; - `13`; - :part:`71%`; * - lldb/utils/lit-cpuid; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/utils/TableGen; - `6`; - `6`; - `0`; - :good:`100%`; * - llvm/benchmarks; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/bindings/go/llvm; - `6`; - `3`; - `3`; - :part:`50%`; * - llvm/bindings/ocaml/llvm; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/cmake; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/examples/BrainF; - `3`; - `0`; - `3`; - :none:`0%`; * - llvm/examples/Bye; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/ExceptionDemo; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Fibonacci; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/HowToUseJIT; - `1`; - `0`; - `1`;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:57930,Testability,benchmark,benchmarks,57930,le/PDB/Inputs; - `5`; - `5`; - `0`; - :good:`100%`; * - lldb/unittests/Target; - `10`; - `6`; - `4`; - :part:`60%`; * - lldb/unittests/TestingSupport; - `5`; - `4`; - `1`; - :part:`80%`; * - lldb/unittests/TestingSupport/Host; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/TestingSupport/Symbol; - `3`; - `3`; - `0`; - :good:`100%`; * - lldb/unittests/Thread; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/tools/lldb-server/inferior; - `2`; - `0`; - `2`; - :none:`0%`; * - lldb/unittests/tools/lldb-server/tests; - `7`; - `0`; - `7`; - :none:`0%`; * - lldb/unittests/UnwindAssembly/ARM64; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/UnwindAssembly/PPC64; - `1`; - `1`; - `0`; - :good:`100%`; * - lldb/unittests/UnwindAssembly/x86; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/unittests/Utility; - `45`; - `32`; - `13`; - :part:`71%`; * - lldb/utils/lit-cpuid; - `1`; - `0`; - `1`; - :none:`0%`; * - lldb/utils/TableGen; - `6`; - `6`; - `0`; - :good:`100%`; * - llvm/benchmarks; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/bindings/go/llvm; - `6`; - `3`; - `3`; - :part:`50%`; * - llvm/bindings/ocaml/llvm; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/cmake; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/examples/BrainF; - `3`; - `0`; - `3`; - :none:`0%`; * - llvm/examples/Bye; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/ExceptionDemo; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/Fibonacci; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/HowToUseJIT; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/examples/HowToUseLLJIT; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/examples/IRTransforms; - `4`; - `4`; - `0`; - :good:`100%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1; - `2`; - `1`; - `1`; - :part:`50%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2; - `2`; - `1`; - `1`; - :part:`50%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3; - `2`; - `1`; - `1`; - :part:`50%`; * - llvm/examples/Kaleidoscope/BuildingAJIT/Chap,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:82313,Testability,test,test,82313,- `19`; - `59`; - :part:`24%`; * - llvm/lib/Transforms/Vectorize; - `22`; - `13`; - `9`; - :part:`59%`; * - llvm/lib/WindowsDriver; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/lib/WindowsManifest; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/lib/XRay; - `14`; - `11`; - `3`; - :part:`78%`; * - llvm/tools/bugpoint; - `12`; - `1`; - `11`; - :part:`8%`; * - llvm/tools/bugpoint-passes; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/dsymutil; - `18`; - `16`; - `2`; - :part:`88%`; * - llvm/tools/gold; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llc; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/lli; - `4`; - `3`; - `1`; - :part:`75%`; * - llvm/tools/lli/ChildTarget; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-ar; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-bcanalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-c-test; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/tools/llvm-cat; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify/lib; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-config; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cov; - `23`; - `12`; - `11`; - :part:`52%`; * - llvm/tools/llvm-cvtres; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cxxdump; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-cxxfilt; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-cxxmap; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-debuginfod-find; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-diff/lib; - `6`; - `0`; - `6`; - :none:`0%`; * - llvm/tools/llvm-dis; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-dis-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-dlang-demangle-fuzzer; - `2`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:123429,Testability,test,tests,123429,generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:123570,Testability,test,tests,123570,%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:123641,Testability,test,tests,123641,:none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:123731,Testability,test,tests,123731,00%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:125489,Testability,benchmark,benchmark,125489, - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/benchmark/cmake; - `5`; - `1`; - `4`; - :part:`20%`; * - third-party/benchmark/include/benchmark; - `1`; - `0`; - `1`; - :none:`0%`; * - third-party/benchmark/src; - `21`; - `21`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/clang/include/clang/Config; - `1`; - `1`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/llvm/include/llvm/Config; - `2`; - `1`; - `1`; - :part:`50%`; * - Total; - :total:`16432`; - :total:`8857`; - :total:`7575`; - :total:`53%`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:125558,Testability,benchmark,benchmark,125558, - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/benchmark/cmake; - `5`; - `1`; - `4`; - :part:`20%`; * - third-party/benchmark/include/benchmark; - `1`; - `0`; - `1`; - :none:`0%`; * - third-party/benchmark/src; - `21`; - `21`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/clang/include/clang/Config; - `1`; - `1`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/llvm/include/llvm/Config; - `2`; - `1`; - `1`; - :part:`50%`; * - Total; - :total:`16432`; - :total:`8857`; - :total:`7575`; - :total:`53%`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:125576,Testability,benchmark,benchmark,125576, - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/benchmark/cmake; - `5`; - `1`; - `4`; - :part:`20%`; * - third-party/benchmark/include/benchmark; - `1`; - `0`; - `1`; - :none:`0%`; * - third-party/benchmark/src; - `21`; - `21`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/clang/include/clang/Config; - `1`; - `1`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/llvm/include/llvm/Config; - `2`; - `1`; - `1`; - :part:`50%`; * - Total; - :total:`16432`; - :total:`8857`; - :total:`7575`; - :total:`53%`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:125638,Testability,benchmark,benchmark,125638, - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/benchmark/cmake; - `5`; - `1`; - `4`; - :part:`20%`; * - third-party/benchmark/include/benchmark; - `1`; - `0`; - `1`; - :none:`0%`; * - third-party/benchmark/src; - `21`; - `21`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/clang/include/clang/Config; - `1`; - `1`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/llvm/include/llvm/Config; - `2`; - `1`; - `1`; - :part:`50%`; * - Total; - :total:`16432`; - :total:`8857`; - :total:`7575`; - :total:`53%`; ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1371,Availability,avail,available,1371,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1405,Availability,avail,available,1405,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:107,Integrability,wrap,wrapper,107,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:166,Integrability,wrap,wrapper,166,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:609,Integrability,wrap,wrapped,609,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:828,Integrability,wrap,wrapper,828,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:861,Integrability,wrap,wrapped,861,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:926,Integrability,wrap,wrapper,926,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1918,Integrability,wrap,wrapped-module,1918,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1943,Integrability,wrap,wrapped,1943,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:2221,Integrability,wrap,wrapped,2221,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:2588,Integrability,wrap,wrapper,2588,"e code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_64 --linker-path=/usr/bin/ld -- <Args>; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1967,Testability,test,testing,1967,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:1803,Availability,avail,available,1803," code objects; for the host and all the offload devices. A bundled code object may also be used to bundle just the offloaded code; objects, and embedded as data into the host code object. The host compilation; includes an ``init`` function that will use the runtime corresponding to the; offload kind (see :ref:`clang-offload-kind-table`) to load the offload code; objects appropriate to the devices present when the host program is executed. :program:`clang-offload-bundler` is located in; `clang/tools/clang-offload-bundler`. .. code-block:: console. $ clang-offload-bundler -help; OVERVIEW: A tool to bundle several input files of the specified type <type>; referring to the same source file but different targets into a single; one. The resulting file can also be unbundled into different files by; this tool if -unbundle is provided. USAGE: clang-offload-bundler [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing when unbundling.; --bundle-align=<uint> - Alignment of bundle for binary files; --check-input-archive - Check if input heterogeneous archive is valid in terms of TargetID rules.; --inputs=<string> - [<input file>,...]; --list - List bundle IDs in the bundled file.; --outputs=<string> - [<output file>,...]; --targets=<string> - [<offload kind>-<target triple>,...]; --type=<string> - Type of the files to be bundled/unbundled.; Current supported types are:; i - cpp-output; ii - c++-cpp-output; cui - cuda/hip-output; d - dependency; ll - llvm; bc - llvm-bc; s - assembler; o - object; a - archive of bundled files; gch - precompiled-header; ast - clang AST file; --unbundle - Unbundl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:1877,Availability,avail,available,1877," code objects; for the host and all the offload devices. A bundled code object may also be used to bundle just the offloaded code; objects, and embedded as data into the host code object. The host compilation; includes an ``init`` function that will use the runtime corresponding to the; offload kind (see :ref:`clang-offload-kind-table`) to load the offload code; objects appropriate to the devices present when the host program is executed. :program:`clang-offload-bundler` is located in; `clang/tools/clang-offload-bundler`. .. code-block:: console. $ clang-offload-bundler -help; OVERVIEW: A tool to bundle several input files of the specified type <type>; referring to the same source file but different targets into a single; one. The resulting file can also be unbundled into different files by; this tool if -unbundle is provided. USAGE: clang-offload-bundler [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing when unbundling.; --bundle-align=<uint> - Alignment of bundle for binary files; --check-input-archive - Check if input heterogeneous archive is valid in terms of TargetID rules.; --inputs=<string> - [<input file>,...]; --list - List bundle IDs in the bundled file.; --outputs=<string> - [<output file>,...]; --targets=<string> - [<offload kind>-<target triple>,...]; --type=<string> - Type of the files to be bundled/unbundled.; Current supported types are:; i - cpp-output; ii - c++-cpp-output; cui - cuda/hip-output; d - dependency; ll - llvm; bc - llvm-bc; s - assembler; o - object; a - archive of bundled files; gch - precompiled-header; ast - clang AST file; --unbundle - Unbundl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:13612,Availability,avail,available,13612," Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; internal passing of information between tools. Only the primary and not; alternative processor name is used and the target features are specified in; alphabetic order. Command line tools convert non-canonical form to canonical; form. Target Specific information; ===========================. Target specific information is available for the following:. *AMD GPU*; AMD GPU supports target ID and target features. See `User Guide for AMDGPU Backend; <https://llvm.org/docs/AMDGPUUsage.html>`_ which defines the `processors; <https://llvm.org/docs/AMDGPUUsage.html#amdgpu-processors>`_ and `target; features <https://llvm.org/docs/AMDGPUUsage.html#amdgpu-target-features>`_; supported. Most other targets do not support target IDs. Archive Unbundling; ==================. Unbundling of a heterogeneous device archive (HDA) is done to create device specific; archives. HDA is in a format compatible with GNU ``ar`` utility and contains a; collection of bundled device binaries where each bundle file will contain; device binaries for a host and one or more targets. The output device-specific; archive is in a format compatible with GNU ``ar`` utility and contains a; collection of device binaries for a specific target. ::. Heterogeneous Device Archive, HDA = {F1.X, F2.X, ..., FN.Y}; where, Fi = Bundle{Host-DeviceBinary, T1",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:17653,Availability,error,error,17653,"d device binary files, and a list of offload targets (not; host), and extracts the device binaries into a new archive file for each; offload target. Each resulting archive file contains all device binaries; compatible with that particular offload target. Compatibility between a; device binary in HDA and a target is based on the compatibility between their; bundle entry IDs as defined in :ref:`compatibility-bundle-entry-id`. Following cases may arise during compatibility testing:. * A binary is compatible with one or more targets: Insert the binary into the; device-specific archive of each compatible target.; * A binary is not compatible with any target: Skip the binary.; * One or more binaries are compatible with a target: Insert all binaries into; the device-specific archive of the target. The insertion need not be ordered.; * No binary is compatible with a target: If ``allow-missing-bundles`` option is; present then create an empty archive for the target. Otherwise, produce an; error without creating an archive. The created archive file does not contain an index of the symbols and device; binary files are named as <<Parent Bundle Name>-<DeviceBinary's TargetID>>,; with ':' replaced with '_'. Usage; -----. ::. clang-offload-bundler --unbundle --inputs=libFatArchive.a -type=a \; -targets=openmp-amdgcn-amdhsa-gfx906:sramecc+:xnack+, \; openmp-amdgcn-amdhsa-gfx908:sramecc-:xnack+ \; -outputs=devicelib-gfx906.a,deviceLib-gfx908.a. .. _additional-options-archive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a devi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:11024,Deployability,configurat,configuration,11024,"lang-target-id`. .. _code-object-composition:. Bundled Code Object Composition; -------------------------------. * Each entry of a bundled code object must have a different bundle entry ID.; * There can be multiple entries for the same processor provided they differ; in target feature settings.; * If there is an entry with a target feature specified as *Any*, then all; entries must specify that target feature as *Any* for the same processor. There may be additional target specific restrictions. .. _compatibility-bundle-entry-id:. Compatibility Rules for Bundle Entry ID; ---------------------------------------. A code object, specified using its Bundle Entry ID, can be loaded and; executed on a target processor, if:. * Their offload kinds are the same.; * Their target triples are compatible.; * Their Target IDs are compatible as defined in :ref:`compatibility-target-id`. .. _clang-target-id:. Target ID; =========. A target ID is used to indicate the processor and optionally its configuration,; expressed by a set of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:2718,Integrability,depend,dependency,2718,"eric Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing when unbundling.; --bundle-align=<uint> - Alignment of bundle for binary files; --check-input-archive - Check if input heterogeneous archive is valid in terms of TargetID rules.; --inputs=<string> - [<input file>,...]; --list - List bundle IDs in the bundled file.; --outputs=<string> - [<output file>,...]; --targets=<string> - [<offload kind>-<target triple>,...]; --type=<string> - Type of the files to be bundled/unbundled.; Current supported types are:; i - cpp-output; ii - c++-cpp-output; cui - cuda/hip-output; d - dependency; ll - llvm; bc - llvm-bc; s - assembler; o - object; a - archive of bundled files; gch - precompiled-header; ast - clang AST file; --unbundle - Unbundle bundled file into several output files. Usage; =====. This tool can be used as follows for bundling:. ::. clang-offload-bundler -targets=triple1,triple2 -type=ii -inputs=a.triple1.ii,a.triple2.ii -outputs=a.ii. or, it can be used as follows for unbundling:. ::. clang-offload-bundler -targets=triple1,triple2 -type=ii -outputs=a.triple1.ii,a.triple2.ii -inputs=a.ii -unbundle. Supported File Formats; ======================. Multiple text and binary file formats are supported for bundling/unbundling. See; :ref:`supported-file-formats-table` for a list of currently supported input; formats. Use the ``File Type`` column to determine the value to pass to the; ``--type`` option based on the type of input files while bundling/unbundling. .. table:: Supported File Formats; :name: supported-file-formats-table. +--------------------------+----------------+-------------+; | File Format | Fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:11024,Modifiability,config,configuration,11024,"lang-target-id`. .. _code-object-composition:. Bundled Code Object Composition; -------------------------------. * Each entry of a bundled code object must have a different bundle entry ID.; * There can be multiple entries for the same processor provided they differ; in target feature settings.; * If there is an entry with a target feature specified as *Any*, then all; entries must specify that target feature as *Any* for the same processor. There may be additional target specific restrictions. .. _compatibility-bundle-entry-id:. Compatibility Rules for Bundle Entry ID; ---------------------------------------. A code object, specified using its Bundle Entry ID, can be loaded and; executed on a target processor, if:. * Their offload kinds are the same.; * Their target triples are compatible.; * Their Target IDs are compatible as defined in :ref:`compatibility-target-id`. .. _clang-target-id:. Target ID; =========. A target ID is used to indicate the processor and optionally its configuration,; expressed by a set of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12103,Modifiability,config,configured,12103," of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12324,Modifiability,config,configured,12324,"oad-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12541,Modifiability,config,configured,12541,"x is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; internal passing of information between tools. Only the primary and not; alternative processor name is used and the target features are specified in; alphabetic order. Command line tools convert non-canonical form to ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:366,Performance,perform,perform,366,"=====================; Clang Offload Bundler; =====================. .. contents::; :local:. .. _clang-offload-bundler:. Introduction; ============. For heterogeneous single source programming languages, use one or more; ``--offload-arch=<target-id>`` Clang options to specify the target IDs of the; code to generate for the offload code regions. The tool chain may perform multiple compilations of a translation unit to; produce separate code objects for the host and potentially multiple offloaded; devices. The ``clang-offload-bundler`` tool may be used as part of the tool; chain to combine these multiple code objects into a single bundled code object. The tool chain may use a bundled code object as an intermediate step so that; each tool chain step consumes and produces a single file as in traditional; non-heterogeneous tool chains. The bundled code object contains the code objects; for the host and all the offload devices. A bundled code object may also be used to bundle just the offloaded code; objects, and embedded as data into the host code object. The host compilation; includes an ``init`` function that will use the runtime corresponding to the; offload kind (see :ref:`clang-offload-kind-table`) to load the offload code; objects appropriate to the devices present when the host program is executed. :program:`clang-offload-bundler` is located in; `clang/tools/clang-offload-bundler`. .. code-block:: console. $ clang-offload-bundler -help; OVERVIEW: A tool to bundle several input files of the specified type <type>; referring to the same source file but different targets into a single; one. The resulting file can also be unbundled into different files by; this tool if -unbundle is provided. USAGE: clang-offload-bundler [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:1221,Performance,load,load,1221,"languages, use one or more; ``--offload-arch=<target-id>`` Clang options to specify the target IDs of the; code to generate for the offload code regions. The tool chain may perform multiple compilations of a translation unit to; produce separate code objects for the host and potentially multiple offloaded; devices. The ``clang-offload-bundler`` tool may be used as part of the tool; chain to combine these multiple code objects into a single bundled code object. The tool chain may use a bundled code object as an intermediate step so that; each tool chain step consumes and produces a single file as in traditional; non-heterogeneous tool chains. The bundled code object contains the code objects; for the host and all the offload devices. A bundled code object may also be used to bundle just the offloaded code; objects, and embedded as data into the host code object. The host compilation; includes an ``init`` function that will use the runtime corresponding to the; offload kind (see :ref:`clang-offload-kind-table`) to load the offload code; objects appropriate to the devices present when the host program is executed. :program:`clang-offload-bundler` is located in; `clang/tools/clang-offload-bundler`. .. code-block:: console. $ clang-offload-bundler -help; OVERVIEW: A tool to bundle several input files of the specified type <type>; referring to the same source file but different targets into a single; one. The resulting file can also be unbundled into different files by; this tool if -unbundle is provided. USAGE: clang-offload-bundler [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:8746,Performance,load,loaded,8746," .. code::. <bundle-entry-id> ::== <offload-kind> ""-"" <target-triple> [ ""-"" <target-id> ]. Where:. **offload-kind**; The runtime responsible for managing the bundled entry code object. See; :ref:`clang-offload-kind-table`. .. table:: Bundled Code Object Offload Kind; :name: clang-offload-kind-table. ============= ==============================================================; Offload Kind Description; ============= ==============================================================; host Host code object. ``clang-offload-bundler`` always includes; this entry as the first bundled code object entry. For an; embedded bundled code object this entry is not used by the; runtime and so is generally an empty code object. hip Offload code object for the HIP language. Used for all; HIP language offload code objects when the; ``clang-offload-bundler`` is used to bundle code objects as; intermediate steps of the tool chain. Also used for AMD GPU; code objects before ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. hipv4 Offload code object for the HIP language. Used for AMD GPU; code objects with at least ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. openmp Offload code object for the OpenMP language extension.; ============= ==============================================================. **target-triple**; The target triple of the code object. See `Target Triple; <https://clang.llvm.org/docs/CrossCompilation.html#target-triple>`_. The bundler accepts target triples with or without the optional environment; field:. ``<arch><sub>-<vendor>-<sys>``, or; ``<arch><sub>-<ven",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:8796,Performance,load,loaded,8796,"managing the bundled entry code object. See; :ref:`clang-offload-kind-table`. .. table:: Bundled Code Object Offload Kind; :name: clang-offload-kind-table. ============= ==============================================================; Offload Kind Description; ============= ==============================================================; host Host code object. ``clang-offload-bundler`` always includes; this entry as the first bundled code object entry. For an; embedded bundled code object this entry is not used by the; runtime and so is generally an empty code object. hip Offload code object for the HIP language. Used for all; HIP language offload code objects when the; ``clang-offload-bundler`` is used to bundle code objects as; intermediate steps of the tool chain. Also used for AMD GPU; code objects before ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. hipv4 Offload code object for the HIP language. Used for AMD GPU; code objects with at least ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. openmp Offload code object for the OpenMP language extension.; ============= ==============================================================. **target-triple**; The target triple of the code object. See `Target Triple; <https://clang.llvm.org/docs/CrossCompilation.html#target-triple>`_. The bundler accepts target triples with or without the optional environment; field:. ``<arch><sub>-<vendor>-<sys>``, or; ``<arch><sub>-<vendor>-<sys>-<env>``. However, in order to standardize outputs for tools that consume bitcode; bundles, bundles written by the bundler internally ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:9098,Performance,load,loaded,9098,"==========================; Offload Kind Description; ============= ==============================================================; host Host code object. ``clang-offload-bundler`` always includes; this entry as the first bundled code object entry. For an; embedded bundled code object this entry is not used by the; runtime and so is generally an empty code object. hip Offload code object for the HIP language. Used for all; HIP language offload code objects when the; ``clang-offload-bundler`` is used to bundle code objects as; intermediate steps of the tool chain. Also used for AMD GPU; code objects before ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. hipv4 Offload code object for the HIP language. Used for AMD GPU; code objects with at least ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. openmp Offload code object for the OpenMP language extension.; ============= ==============================================================. **target-triple**; The target triple of the code object. See `Target Triple; <https://clang.llvm.org/docs/CrossCompilation.html#target-triple>`_. The bundler accepts target triples with or without the optional environment; field:. ``<arch><sub>-<vendor>-<sys>``, or; ``<arch><sub>-<vendor>-<sys>-<env>``. However, in order to standardize outputs for tools that consume bitcode; bundles, bundles written by the bundler internally use only the 4-field; target triple:. ``<arch><sub>-<vendor>-<sys>-<env>``. **target-id**; The canonical target ID of the code object. Present only if the target; supports a target ID. See :ref:`clang-target",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:9148,Performance,load,loaded,9148," object. ``clang-offload-bundler`` always includes; this entry as the first bundled code object entry. For an; embedded bundled code object this entry is not used by the; runtime and so is generally an empty code object. hip Offload code object for the HIP language. Used for all; HIP language offload code objects when the; ``clang-offload-bundler`` is used to bundle code objects as; intermediate steps of the tool chain. Also used for AMD GPU; code objects before ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. hipv4 Offload code object for the HIP language. Used for AMD GPU; code objects with at least ABI version V4 when the; ``clang-offload-bundler`` is used to create a *fat binary*; to be loaded by the HIP runtime. The fat binary can be; loaded directly from a file, or be embedded in the host code; object as a data section with the name ``.hip_fatbin``. openmp Offload code object for the OpenMP language extension.; ============= ==============================================================. **target-triple**; The target triple of the code object. See `Target Triple; <https://clang.llvm.org/docs/CrossCompilation.html#target-triple>`_. The bundler accepts target triples with or without the optional environment; field:. ``<arch><sub>-<vendor>-<sys>``, or; ``<arch><sub>-<vendor>-<sys>-<env>``. However, in order to standardize outputs for tools that consume bitcode; bundles, bundles written by the bundler internally use only the 4-field; target triple:. ``<arch><sub>-<vendor>-<sys>-<env>``. **target-id**; The canonical target ID of the code object. Present only if the target; supports a target ID. See :ref:`clang-target-id`. .. _code-object-composition:. Bundled Code Object Composition; -------------------------------. * Each entry of a bundled code object must ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:10709,Performance,load,loaded,10709,"<env>``. However, in order to standardize outputs for tools that consume bitcode; bundles, bundles written by the bundler internally use only the 4-field; target triple:. ``<arch><sub>-<vendor>-<sys>-<env>``. **target-id**; The canonical target ID of the code object. Present only if the target; supports a target ID. See :ref:`clang-target-id`. .. _code-object-composition:. Bundled Code Object Composition; -------------------------------. * Each entry of a bundled code object must have a different bundle entry ID.; * There can be multiple entries for the same processor provided they differ; in target feature settings.; * If there is an entry with a target feature specified as *Any*, then all; entries must specify that target feature as *Any* for the same processor. There may be additional target specific restrictions. .. _compatibility-bundle-entry-id:. Compatibility Rules for Bundle Entry ID; ---------------------------------------. A code object, specified using its Bundle Entry ID, can be loaded and; executed on a target processor, if:. * Their offload kinds are the same.; * Their target triples are compatible.; * Their Target IDs are compatible as defined in :ref:`compatibility-target-id`. .. _clang-target-id:. Target ID; =========. A target ID is used to indicate the processor and optionally its configuration,; expressed by a set of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12067,Performance,load,loaded,12067," of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12302,Performance,load,loaded,12302,"oad-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12519,Performance,load,loaded,12519,"x is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; internal passing of information between tools. Only the primary and not; alternative processor name is used and the target features are specified in; alphabetic order. Command line tools convert non-canonical form to ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:18941,Safety,redund,redundancies,18941,"ndler --unbundle --inputs=libFatArchive.a -type=a \; -targets=openmp-amdgcn-amdhsa-gfx906:sramecc+:xnack+, \; openmp-amdgcn-amdhsa-gfx908:sramecc-:xnack+ \; -outputs=devicelib-gfx906.a,deviceLib-gfx908.a. .. _additional-options-archive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a device binary from HDA and bundle entry ID of a given target processor; (see :ref:`compatibility-bundle-entry-id`). Compression and Decompression; =============================. ``clang-offload-bundler`` provides features to compress and decompress the full; bundle, leveraging inherent redundancies within the bundle entries. Use the; `-compress` command-line option to enable this compression capability. The compressed offload bundle begins with a header followed by the compressed binary data:. - **Magic Number (4 bytes)**:; This is a unique identifier to distinguish compressed offload bundles. The value is the string 'CCOB' (Compressed Clang Offload Bundle). - **Version Number (16-bit unsigned int)**:; This denotes the version of the compressed offload bundle format. The current version is `1`. - **Compression Method (16-bit unsigned int)**:; This field indicates the compression method used. The value corresponds to either `zlib` or `zstd`, represented as a 16-bit unsigned integer cast from the LLVM compression enumeration. - **Uncompressed Binary Size (32-bit unsigned int)**:; This is the size (in bytes) of the binary data before it was compressed. - **Hash (64-bit unsigned int)**:; This is a 64-bit truncated MD5 hash of the uncomp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:19888,Security,hash,hash,19888,"rchive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a device binary from HDA and bundle entry ID of a given target processor; (see :ref:`compatibility-bundle-entry-id`). Compression and Decompression; =============================. ``clang-offload-bundler`` provides features to compress and decompress the full; bundle, leveraging inherent redundancies within the bundle entries. Use the; `-compress` command-line option to enable this compression capability. The compressed offload bundle begins with a header followed by the compressed binary data:. - **Magic Number (4 bytes)**:; This is a unique identifier to distinguish compressed offload bundles. The value is the string 'CCOB' (Compressed Clang Offload Bundle). - **Version Number (16-bit unsigned int)**:; This denotes the version of the compressed offload bundle format. The current version is `1`. - **Compression Method (16-bit unsigned int)**:; This field indicates the compression method used. The value corresponds to either `zlib` or `zstd`, represented as a 16-bit unsigned integer cast from the LLVM compression enumeration. - **Uncompressed Binary Size (32-bit unsigned int)**:; This is the size (in bytes) of the binary data before it was compressed. - **Hash (64-bit unsigned int)**:; This is a 64-bit truncated MD5 hash of the uncompressed binary data. It serves for verification and caching purposes. - **Compressed Data**:; The actual compressed binary data follows the header. Its size can be inferred from the total size of the file minus the header size.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:2108,Testability,test,testing,2108,". The host compilation; includes an ``init`` function that will use the runtime corresponding to the; offload kind (see :ref:`clang-offload-kind-table`) to load the offload code; objects appropriate to the devices present when the host program is executed. :program:`clang-offload-bundler` is located in; `clang/tools/clang-offload-bundler`. .. code-block:: console. $ clang-offload-bundler -help; OVERVIEW: A tool to bundle several input files of the specified type <type>; referring to the same source file but different targets into a single; one. The resulting file can also be unbundled into different files by; this tool if -unbundle is provided. USAGE: clang-offload-bundler [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing when unbundling.; --bundle-align=<uint> - Alignment of bundle for binary files; --check-input-archive - Check if input heterogeneous archive is valid in terms of TargetID rules.; --inputs=<string> - [<input file>,...]; --list - List bundle IDs in the bundled file.; --outputs=<string> - [<output file>,...]; --targets=<string> - [<offload kind>-<target triple>,...]; --type=<string> - Type of the files to be bundled/unbundled.; Current supported types are:; i - cpp-output; ii - c++-cpp-output; cui - cuda/hip-output; d - dependency; ll - llvm; bc - llvm-bc; s - assembler; o - object; a - archive of bundled files; gch - precompiled-header; ast - clang AST file; --unbundle - Unbundle bundled file into several output files. Usage; =====. This tool can be used as follows for bundling:. ::. clang-offload-bundler -targets=triple1,triple2 -type=ii -inputs=a.triple1.ii,a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:17133,Testability,test,testing,17133,"t=amdgcn-amd-amdhsa -march=gfx906:sramecc-:xnack+ \; -Xopenmp-target=amdgcn-amd-amdhsa -march=gfx906:sramecc+:xnack+ \; -Xopenmp-target=nvptx64-nvidia-cuda -march=sm_70 \; -Xopenmp-target=nvptx64-nvidia-cuda -march=sm_80 \; -c func_2.c -o func_2.o. 2. Create a heterogeneous device archive by combining all the object file(s). ::. llvm-ar cr libFatArchive.a func_1.o func_2.o. Extracting a Device Specific Archive; ------------------------------------. UnbundleArchive takes a heterogeneous device archive file ("".a"") as input; containing bundled device binary files, and a list of offload targets (not; host), and extracts the device binaries into a new archive file for each; offload target. Each resulting archive file contains all device binaries; compatible with that particular offload target. Compatibility between a; device binary in HDA and a target is based on the compatibility between their; bundle entry IDs as defined in :ref:`compatibility-bundle-entry-id`. Following cases may arise during compatibility testing:. * A binary is compatible with one or more targets: Insert the binary into the; device-specific archive of each compatible target.; * A binary is not compatible with any target: Skip the binary.; * One or more binaries are compatible with a target: Insert all binaries into; the device-specific archive of the target. The insertion need not be ordered.; * No binary is compatible with a target: If ``allow-missing-bundles`` option is; present then create an empty archive for the target. Otherwise, produce an; error without creating an archive. The created archive file does not contain an index of the symbols and device; binary files are named as <<Parent Bundle Name>-<DeviceBinary's TargetID>>,; with ':' replaced with '_'. Usage; -----. ::. clang-offload-bundler --unbundle --inputs=libFatArchive.a -type=a \; -targets=openmp-amdgcn-amdhsa-gfx906:sramecc+:xnack+, \; openmp-amdgcn-amdhsa-gfx908:sramecc-:xnack+ \; -outputs=devicelib-gfx906.a,deviceLib-gfx908.a. .. _",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8133,Availability,avail,available,8133,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8207,Availability,avail,available,8207,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:347,Integrability,wrap,wrapping,347,"======================; Clang Offload Packager; ======================. .. contents::; :local:. .. _clang-offload-packager:. Introduction; ============. This tool bundles device files into a single image containing necessary; metadata. We use a custom binary format for bundling all the device images; together. The image format is a small header wrapping around a string map. This; tool creates bundled binaries so that they can be embedded into the host to; create a fat-binary. Binary Format; =============. The binary format is marked by the ``0x10FF10AD`` magic bytes, followed by a; version. Each created binary contains its own magic bytes. This allows us to; locate all the embedded offloading sections even after they may have been merged; by the linker, such as when using relocatable linking. Conceptually, this binary; format is a serialization of a string map and an image buffer. The binary header; is described in the following :ref:`table<table-binary_header>`. .. table:: Offloading Binary Header; :name: table-binary_header. +----------+--------------+----------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+====================================================+; | uint8_t | magic | The magic bytes for the binary format (0x10FF10AD) |; +----------+--------------+----------------------------------------------------+; | uint32_t | version | Version of this format (currently version 1) |; +----------+--------------+----------------------------------------------------+; | uint64_t | size | Size of this binary in bytes |; +----------+--------------+----------------------------------------------------+; | uint64_t | entry offset | Absolute offset of the offload entries in bytes |; +----------+--------------+----------------------------------------------------+; | uint64_t | entry size | Size of the offload entries in bytes |; +----------+--------------+----------------------------------------------------+. Once ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:7326,Modifiability,extend,extend,7326,"--+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8766,Performance,perform,performed,8766,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:6805,Usability,simpl,simply,6805,"--+---------------------------------------+. The flags are used to signify certain conditions, such as the presence of; debugging information or whether or not LTO was used. The string entry table is; used to generically contain any arbitrary key-value pair. This is stored as an; array of the :ref:`string entry<table-binary_string>` format. .. table:: Offloading String Entry; :name: table-binary_string. +----------+--------------+-------------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:6908,Usability,simpl,simply,6908," the presence of; debugging information or whether or not LTO was used. The string entry table is; used to generically contain any arbitrary key-value pair. This is stored as an; array of the :ref:`string entry<table-binary_string>` format. .. table:: Offloading String Entry; :name: table-binary_string. +----------+--------------+-------------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:7425,Usability,simpl,simply,7425,"=========================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Requir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8510,Usability,simpl,simply,8510,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5663,Availability,down,downside,5663,"n. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5772,Deployability,configurat,configuration,5772,"n. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7338,Energy Efficiency,reduce,reduce,7338,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7628,Energy Efficiency,reduce,reduces,7628,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:3388,Integrability,depend,depending,3388,"turn AttributeApplied;; }; };. static ParsedAttrInfoRegistry::Add<ExampleAttrInfo> Z(""example_attr"",""example attribute description"");. The members of ``ParsedAttrInfo`` that a plugin attribute must define are:. * ``Spellings``, which must be populated with every `Spelling; </doxygen/structclang_1_1ParsedAttrInfo_1_1Spelling.html>`_ of the; attribute, each of which consists of an attribute syntax and how the; attribute name is spelled for that syntax. If the syntax allows a scope then; the spelling must be ""scope::attr"" if a scope is present or ""::attr"" if not.; * ``handleDeclAttribute``, which is the function that applies the attribute to; a declaration. It is responsible for checking that the attribute's arguments; are valid, and typically applies the attribute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:492,Modifiability,plugin,plugin,492,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:646,Modifiability,plugin,plugin,646,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:779,Modifiability,plugin,plugin,779,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1053,Modifiability,plugin,plugin,1053,"ake it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1085,Modifiability,plugin,plugin,1085,"a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1168,Modifiability,plugin,plugin,1168,"write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1301,Modifiability,plugin,plugin-name,1301,"ee the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo() {; Spellings.push_back({ParsedAttr::AS_GNU,""example""});; }; AttrHandling handleDeclAttribute(Sema &S, D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1319,Modifiability,plugin,plugin,1319,"ee the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo() {; Spellings.push_back({ParsedAttr::AS_GNU,""example""});; }; AttrHandling handleDeclAttribute(Sema &S, D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:2549,Modifiability,plugin,plugin,2549,"andler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo() {; Spellings.push_back({ParsedAttr::AS_GNU,""example""});; }; AttrHandling handleDeclAttribute(Sema &S, Decl *D,; const ParsedAttr &Attr) const override {; // Handle the attribute; return AttributeApplied;; }; };. static ParsedAttrInfoRegistry::Add<ExampleAttrInfo> Z(""example_attr"",""example attribute description"");. The members of ``ParsedAttrInfo`` that a plugin attribute must define are:. * ``Spellings``, which must be populated with every `Spelling; </doxygen/structclang_1_1ParsedAttrInfo_1_1Spelling.html>`_ of the; attribute, each of which consists of an attribute syntax and how the; attribute name is spelled for that syntax. If the syntax allows a scope then; the spelling must be ""scope::attr"" if a scope is present or ""::attr"" if not.; * ``handleDeclAttribute``, which is the function that applies the attribute to; a declaration. It is responsible for checking that the attribute's arguments; are valid, and typically applies the attribute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagApperta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:3925,Modifiability,plugin,plugin,3925,"nt or ""::attr"" if not.; * ``handleDeclAttribute``, which is the function that applies the attribute to; a declaration. It is responsible for checking that the attribute's arguments; are valid, and typically applies the attribute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4131,Modifiability,plugin,plugin,4131,"ibute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4419,Modifiability,plugin,plugin,4419,"`NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional para",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4559,Modifiability,plugin,plugin,4559,"`diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4574,Modifiability,plugin,plugins,4574,"tion and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4665,Modifiability,plugin,plugin,4665,"tion and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4722,Modifiability,plugin,plugin,4722,"guage mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4796,Modifiability,plugin,plugin,4796,"guage mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5004,Modifiability,plugin,plugin,5004,"`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5051,Modifiability,plugin,plugin,5051,"`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5175,Modifiability,plugin,plugin,5175,"y; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5218,Modifiability,plugin,plugin,5218,"y; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5306,Modifiability,plugin,plugins,5306,"ang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/includ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5359,Modifiability,plugin,plugins,5359,"ang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/includ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5395,Modifiability,plugin,plugin,5395,"ang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/includ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5441,Modifiability,plugin,plugins,5441,"the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5471,Modifiability,plugin,plugin-arg,5471,"the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5483,Modifiability,plugin,plugin-name,5483,"the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5679,Modifiability,config,configuring,5679,"n. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5772,Modifiability,config,configuration,5772,"n. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5941,Modifiability,plugin,plugin,5941,"n-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5994,Modifiability,plugin,plugin,5994,"n-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6031,Modifiability,plugin,plugin,6031,"n-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6489,Modifiability,plugin,plugin,6489,">`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; havin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6548,Modifiability,plugin,plugin,6548,". There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatica",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6747,Modifiability,plugin,plugin,6747,"ommand; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6792,Modifiability,plugin,plugin,6792,"ommand; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6866,Modifiability,plugin,plugin,6866,"run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6929,Modifiability,plugin,plugin,6929,"run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6983,Modifiability,plugin,plugin,6983,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7061,Modifiability,plugin,plugin,7061,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7118,Modifiability,plugin,plugin,7118,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7380,Modifiability,plugin,plugins,7380,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7500,Modifiability,plugin,plugins,7500,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7821,Modifiability,plugin,plugins,7821,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1095,Performance,load,loaded,1095,"a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4552,Performance,load,load,4552,"`diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5243,Performance,load,loaded,5243,"y; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5260,Performance,load,load,5260,"y; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5297,Performance,load,load,5297,"ang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/includ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6434,Performance,load,load,6434,"e plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6828,Performance,load,load,6828,"ommand; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7718,Performance,optimiz,optimizations,7718,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4986,Testability,test,test,4986,"https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:479,Usability,simpl,simple,479,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7259,Usability,clear,clear-ast-before-backend,7259,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7570,Usability,clear,clear-ast-before-backend,7570,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7601,Usability,clear,clear-ast-before-backend,7601,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7652,Usability,clear,clearing,7652,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:7862,Usability,clear,clear-ast-before-backend,7862,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangPlugins.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:820,Availability,avail,available,820,"===========; Clang-Repl; ===========. **Clang-Repl** is an interactive C++ interpreter that allows for incremental; compilation. It supports interactive programming for C++ in a; read-evaluate-print-loop (REPL) style. It uses Clang as a library to compile the; high level programming language into LLVM IR. Then the LLVM IR is executed by; the LLVM just-in-time (JIT) infrastructure. Clang-Repl is suitable for exploratory programming and in places where time; to insight is important. Clang-Repl is a project inspired by the work in; `Cling <https://github.com/root-project/cling>`_, a LLVM-based C/C++ interpreter; developed by the field of high energy physics and used by the scientific data; analysis framework `ROOT <https://root.cern/>`_. Clang-Repl allows to move parts; of Cling upstream, making them useful and available to a broader audience. Clang-Repl Basic Data Flow; ==========================. .. image:: ClangRepl_design.png; :align: center; :alt: ClangRepl design. Clang-Repl data flow can be divided into roughly 8 phases:. 1. Clang-Repl controls the input infrastructure by an interactive prompt or by; an interface allowing the incremental processing of input. 2. Then it sends the input to the underlying incremental facilities in Clang; infrastructure. 3. Clang compiles the input into an AST representation. 4. When required the AST can be further transformed in order to attach specific; behavior. 5. The AST representation is then lowered to LLVM IR. 6. The LLVM IR is the input format for LLVM’s JIT compilation infrastructure.; The tool will instruct the JIT to run specified functions, translating them; into machine code targeting the underlying device architecture (eg. Intel; x86 or NVPTX). 7. The LLVM JIT lowers the LLVM IR to machine code. 8. The machine code is then executed. Build Instructions:; ===================. .. code-block:: console. $ cd llvm-project; $ mkdir build; $ cd build; $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_ENABLE_PROJECTS=clang -G ""U",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:18504,Availability,error,error,18504," Err;. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }; return llvm::Error::success();; }. The ``dump()`` function (in ``value.cpp``) calls the ``print()`` function. Printing the Data and Type are handled in their respective functions:; ``ReplPrintDataImpl()`` and ``ReplPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user input; (expression statement). This helps store and return the expression statement; effectively, so that it can be printed (displayed to the user automatically). **Note:** This logic is only available for C++ for now, since part of the; implementation itself requires C++ features. Future versions may support more; languages. .. code-block:: console. Token *CurTok = nullptr;; // If the semicolon is missing at the end of REPL input, consider if; // we want to do value printing. Note this is only enabled in C++ mode; // since part of the implementation requires C++ language features.; // Note we shouldn't eat the token since the callback needs it.; if (Tok.is(tok::annot_repl_input_end) && Actions.getLangOpts().CPlusPlus); CurTok = &Tok;; else; // Otherwise, eat the semicolon.; ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);. StmtResult R = handleExprStmt(Expr, Stm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:18834,Availability,avail,available,18834,"lPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user input; (expression statement). This helps store and return the expression statement; effectively, so that it can be printed (displayed to the user automatically). **Note:** This logic is only available for C++ for now, since part of the; implementation itself requires C++ features. Future versions may support more; languages. .. code-block:: console. Token *CurTok = nullptr;; // If the semicolon is missing at the end of REPL input, consider if; // we want to do value printing. Note this is only enabled in C++ mode; // since part of the implementation requires C++ language features.; // Note we shouldn't eat the token since the callback needs it.; if (Tok.is(tok::annot_repl_input_end) && Actions.getLangOpts().CPlusPlus); CurTok = &Tok;; else; // Otherwise, eat the semicolon.; ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);. StmtResult R = handleExprStmt(Expr, StmtCtx);; if (CurTok && !R.isInvalid()); CurTok->setAnnotationValue(R.get());. return R;; }. AST Transformation; -------------------. When Sema encounters the ``annot_repl_input_end`` token, it knows to transform; the AST before the real CodeGen process. It will consume the token and set a; 'semi missing' bit in the respective decl. .. co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5214,Deployability,integrat,integrated,5214,"ontinuation of the statements in the next line. Lamdas:; =======. .. code-block:: text. clang-repl> #include <iostream>; clang-repl> using namespace std;; clang-repl> auto welcome = []() { std::cout << ""Welcome to REPL"" << std::endl;};; clang-repl> welcome();; Welcome to REPL. Using Dynamic Library:; ======================. .. code-block:: text. clang-repl> %lib print.so; clang-repl> #include""print.hpp""; clang-repl> print(9);; 9. **Generation of dynamic library**. .. code-block:: text. // print.cpp; #include <iostream>; #include ""print.hpp"". void print(int a); {; std::cout << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:20506,Deployability,patch,patches,20506,"t to do value printing. Note this is only enabled in C++ mode; // since part of the implementation requires C++ language features.; // Note we shouldn't eat the token since the callback needs it.; if (Tok.is(tok::annot_repl_input_end) && Actions.getLangOpts().CPlusPlus); CurTok = &Tok;; else; // Otherwise, eat the semicolon.; ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);. StmtResult R = handleExprStmt(Expr, StmtCtx);; if (CurTok && !R.isInvalid()); CurTok->setAnnotationValue(R.get());. return R;; }. AST Transformation; -------------------. When Sema encounters the ``annot_repl_input_end`` token, it knows to transform; the AST before the real CodeGen process. It will consume the token and set a; 'semi missing' bit in the respective decl. .. code-block:: console. if (Tok.is(tok::annot_repl_input_end) &&; Tok.getAnnotationValue() != nullptr) {; ConsumeAnnotationToken();; cast<TopLevelStmtDecl>(DeclsInGroup.back())->setSemiMissing();; }. In the AST Consumer, traverse all the Top Level Decls, to look for expressions; to synthesize. If the current Decl is the Top Level Statement; Decl(``TopLevelStmtDecl``) and has a semicolon missing, then ask the interpreter; to synthesize another expression (an internal function call) to replace this; original expression. Detailed RFC and Discussion:; ----------------------------. For more technical details, community discussion and links to patches related; to these features,; Please visit: `RFC on LLVM Discourse <https://discourse.llvm.org/t/rfc-handle-execution-results-in-clang-repl/68493>`_. Some logic presented in the RFC (e.g. ValueGetter()) may be outdated,; compared to the final developed solution. Related Reading; ===============; `Cling Transitions to LLVM's Clang-Repl <https://root.cern/blog/cling-in-llvm/>`_. `Moving (parts of) the Cling REPL in Clang <https://lists.llvm.org/pipermail/llvm-dev/2020-July/143257.html>`_. `GPU Accelerated Automatic Differentiation With Clad <https://arxiv.org/pdf/2203.06139.pdf>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:648,Energy Efficiency,energy,energy,648,"===========; Clang-Repl; ===========. **Clang-Repl** is an interactive C++ interpreter that allows for incremental; compilation. It supports interactive programming for C++ in a; read-evaluate-print-loop (REPL) style. It uses Clang as a library to compile the; high level programming language into LLVM IR. Then the LLVM IR is executed by; the LLVM just-in-time (JIT) infrastructure. Clang-Repl is suitable for exploratory programming and in places where time; to insight is important. Clang-Repl is a project inspired by the work in; `Cling <https://github.com/root-project/cling>`_, a LLVM-based C/C++ interpreter; developed by the field of high energy physics and used by the scientific data; analysis framework `ROOT <https://root.cern/>`_. Clang-Repl allows to move parts; of Cling upstream, making them useful and available to a broader audience. Clang-Repl Basic Data Flow; ==========================. .. image:: ClangRepl_design.png; :align: center; :alt: ClangRepl design. Clang-Repl data flow can be divided into roughly 8 phases:. 1. Clang-Repl controls the input infrastructure by an interactive prompt or by; an interface allowing the incremental processing of input. 2. Then it sends the input to the underlying incremental facilities in Clang; infrastructure. 3. Clang compiles the input into an AST representation. 4. When required the AST can be further transformed in order to attach specific; behavior. 5. The AST representation is then lowered to LLVM IR. 6. The LLVM IR is the input format for LLVM’s JIT compilation infrastructure.; The tool will instruct the JIT to run specified functions, translating them; into machine code targeting the underlying device architecture (eg. Intel; x86 or NVPTX). 7. The LLVM JIT lowers the LLVM IR to machine code. 8. The machine code is then executed. Build Instructions:; ===================. .. code-block:: console. $ cd llvm-project; $ mkdir build; $ cd build; $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_ENABLE_PROJECTS=clang -G ""U",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8873,Energy Efficiency,allocate,allocated,8873,"oc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-buffer optimization.; In case of objects, the ``Value`` class provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:1125,Integrability,interface,interface,1125,"al; compilation. It supports interactive programming for C++ in a; read-evaluate-print-loop (REPL) style. It uses Clang as a library to compile the; high level programming language into LLVM IR. Then the LLVM IR is executed by; the LLVM just-in-time (JIT) infrastructure. Clang-Repl is suitable for exploratory programming and in places where time; to insight is important. Clang-Repl is a project inspired by the work in; `Cling <https://github.com/root-project/cling>`_, a LLVM-based C/C++ interpreter; developed by the field of high energy physics and used by the scientific data; analysis framework `ROOT <https://root.cern/>`_. Clang-Repl allows to move parts; of Cling upstream, making them useful and available to a broader audience. Clang-Repl Basic Data Flow; ==========================. .. image:: ClangRepl_design.png; :align: center; :alt: ClangRepl design. Clang-Repl data flow can be divided into roughly 8 phases:. 1. Clang-Repl controls the input infrastructure by an interactive prompt or by; an interface allowing the incremental processing of input. 2. Then it sends the input to the underlying incremental facilities in Clang; infrastructure. 3. Clang compiles the input into an AST representation. 4. When required the AST can be further transformed in order to attach specific; behavior. 5. The AST representation is then lowered to LLVM IR. 6. The LLVM IR is the input format for LLVM’s JIT compilation infrastructure.; The tool will instruct the JIT to run specified functions, translating them; into machine code targeting the underlying device architecture (eg. Intel; x86 or NVPTX). 7. The LLVM JIT lowers the LLVM IR to machine code. 8. The machine code is then executed. Build Instructions:; ===================. .. code-block:: console. $ cd llvm-project; $ mkdir build; $ cd build; $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_ENABLE_PROJECTS=clang -G ""Unix Makefiles"" ../llvm. **Note here**, above RelWithDebInfo - Debug / Release. .. code-block:: console. cmake -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5214,Integrability,integrat,integrated,5214,"ontinuation of the statements in the next line. Lamdas:; =======. .. code-block:: text. clang-repl> #include <iostream>; clang-repl> using namespace std;; clang-repl> auto welcome = []() { std::cout << ""Welcome to REPL"" << std::endl;};; clang-repl> welcome();; Welcome to REPL. Using Dynamic Library:; ======================. .. code-block:: text. clang-repl> %lib print.so; clang-repl> #include""print.hpp""; clang-repl> print(9);; 9. **Generation of dynamic library**. .. code-block:: text. // print.cpp; #include <iostream>; #include ""print.hpp"". void print(int a); {; std::cout << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5545,Integrability,interoperab,interoperability,5545,"ang-repl> welcome();; Welcome to REPL. Using Dynamic Library:; ======================. .. code-block:: text. clang-repl> %lib print.so; clang-repl> #include""print.hpp""; clang-repl> print(9);; 9. **Generation of dynamic library**. .. code-block:: text. // print.cpp; #include <iostream>; #include ""print.hpp"". void print(int a); {; std::cout << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. Capture Execution Results; ============================. In many cases, it is useful to bring back the program execution result to the; compiled program. This result can be stored in an object of type **Value**. How Execution Results are ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5831,Integrability,interface,interface,5831,"out << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. Capture Execution Results; ============================. In many cases, it is useful to bring back the program execution result to the; compiled program. This result can be stored in an object of type **Value**. How Execution Results are captured (Value Synthesis):; -----------------------------------------------------. The synthesizer chooses which expression to synthesize, and then it replaces; the original expression with the synthesized expression. Depending on the; expression type, it may choose to save an object (``LastValue``) of type 'value'; while allocating mem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10376,Integrability,wrap,wrapping,10376,"g builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11341,Integrability,interoperab,interoperability,11341,"----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11955,Integrability,wrap,wraps,11955,"C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------. In Clang-Repl there is **interpreted code**, and this feature adds a 'value'; runtime that can talk to the **compiled code**. Following is an example where the compiled code interacts with the interpreter; code. The execution results of an expression are stored in the object 'V' of;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:13506,Integrability,interoperab,interoperability,13506,"onsumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------. In Clang-Repl there is **interpreted code**, and this feature adds a 'value'; runtime that can talk to the **compiled code**. Following is an example where the compiled code interacts with the interpreter; code. The execution results of an expression are stored in the object 'V' of; type Value. This value is then printed, effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph """,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5779,Modifiability,extend,extend,5779,"out << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. Capture Execution Results; ============================. In many cases, it is useful to bring back the program execution result to the; compiled program. This result can be stored in an object of type **Value**. How Execution Results are captured (Value Synthesis):; -----------------------------------------------------. The synthesizer chooses which expression to synthesize, and then it replaces; the original expression with the synthesized expression. Depending on the; expression type, it may choose to save an object (``LastValue``) of type 'value'; while allocating mem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8025,Modifiability,variab,variable,8025,"hesis"" {; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. start [label="" Create an Object \n 'Last Value' \n of type 'Value' "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; assign [label="" Assign the result \n to the 'LastValue' \n (based on respective \n Memory Allocation \n scenario) "", shape=""box""]; print [label="" Pretty Print \n the Value Object "", shape=""Msquare"", fillcolor=""yellow"", style=filled];; start -> assign;; assign -> print;. subgraph SynthesizeExpression {; synth [label="" SynthesizeExpr() "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11167,Modifiability,inherit,inheritance,11167,"lp improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this conditi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:14083,Modifiability,variab,variable,14083," effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:15216,Modifiability,extend,extended,15216,"angInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; science applications. This is useful, for example, when you want to experiment with a set of values; against a set of functions, and you'd like to know the results right away.; This is similar to how Python works (hence its popularity in data science; research), but the superior performance of C++, along with this flexibility; makes it a more attractive option. Implementation Details; ======================. Parsing mechanism:; ------------------. The Interpreter in Clang-Repl (``Interpreter.cpp``) includes the function; ``ParseAndExecute()`` that can accept a 'Value' parameter to capture the result.; But if the value parameter is made optional and it is omitted (i.e., that the; user does not want to utilize it elsewhere), then the last value can be; validated and pushed into the ``dump()`` function. .. graphviz::; :name: parsing; :caption: Parsing Mechanism; :alt: Shows the Parsing Mechanism for Pretty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:9051,Performance,optimiz,optimization,9051,"ucture \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-buffer optimization.; In case of objects, the ``Value`` class provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:12013,Performance,perform,performs,12013,"C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------. In Clang-Repl there is **interpreted code**, and this feature adds a 'value'; runtime that can talk to the **compiled code**. Following is an example where the compiled code interacts with the interpreter; code. The execution results of an expression are stored in the object 'V' of;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:15599,Performance,perform,performance,15599,"""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; science applications. This is useful, for example, when you want to experiment with a set of values; against a set of functions, and you'd like to know the results right away.; This is similar to how Python works (hence its popularity in data science; research), but the superior performance of C++, along with this flexibility; makes it a more attractive option. Implementation Details; ======================. Parsing mechanism:; ------------------. The Interpreter in Clang-Repl (``Interpreter.cpp``) includes the function; ``ParseAndExecute()`` that can accept a 'Value' parameter to capture the result.; But if the value parameter is made optional and it is omitted (i.e., that the; user does not want to utilize it elsewhere), then the last value can be; validated and pushed into the ``dump()`` function. .. graphviz::; :name: parsing; :caption: Parsing Mechanism; :alt: Shows the Parsing Mechanism for Pretty Printing; :align: center. digraph ""prettyprint"" {; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Verdana"", fontsize=""9""];. parse [label="" ParseAndExecute() \n in Clang "", shape=""box""];; capture [label="" Capture 'Value' parameter \n for processing? "", shape=""diamond""];; use [label",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8583,Security,access,accessed,8583,"gn;; assign -> print;. subgraph SynthesizeExpression {; synth [label="" SynthesizeExpr() "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-buffer optimization.; In case of objects, the ``Value`` class provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` heade",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:16080,Security,validat,validated,16080,"---. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; science applications. This is useful, for example, when you want to experiment with a set of values; against a set of functions, and you'd like to know the results right away.; This is similar to how Python works (hence its popularity in data science; research), but the superior performance of C++, along with this flexibility; makes it a more attractive option. Implementation Details; ======================. Parsing mechanism:; ------------------. The Interpreter in Clang-Repl (``Interpreter.cpp``) includes the function; ``ParseAndExecute()`` that can accept a 'Value' parameter to capture the result.; But if the value parameter is made optional and it is omitted (i.e., that the; user does not want to utilize it elsewhere), then the last value can be; validated and pushed into the ``dump()`` function. .. graphviz::; :name: parsing; :caption: Parsing Mechanism; :alt: Shows the Parsing Mechanism for Pretty Printing; :align: center. digraph ""prettyprint"" {; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Verdana"", fontsize=""9""];. parse [label="" ParseAndExecute() \n in Clang "", shape=""box""];; capture [label="" Capture 'Value' parameter \n for processing? "", shape=""diamond""];; use [label="" Use for processing "", shape=""box""];; dump [label="" Validate and push \n to dump()"", shape=""box""];; callp [label="" call print() function "", shape=""box""];; type [label="" Print the Type \n ReplPrintTypeImpl()"", shape=""box""];; data [label="" Print the Data \n ReplPrintDataImpl() "", shape=""box""];; output [label="" Output Pretty Print \n to the user "", shape=""box"", fontcolor=white, fillcolor=""#3333ff"", style=filled];. parse -> capture [label=""Optional 'Value' Parameter""];; ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10081,Testability,log,logic,10081,"ss provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:18820,Testability,log,logic,18820,"lPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user input; (expression statement). This helps store and return the expression statement; effectively, so that it can be printed (displayed to the user automatically). **Note:** This logic is only available for C++ for now, since part of the; implementation itself requires C++ features. Future versions may support more; languages. .. code-block:: console. Token *CurTok = nullptr;; // If the semicolon is missing at the end of REPL input, consider if; // we want to do value printing. Note this is only enabled in C++ mode; // since part of the implementation requires C++ language features.; // Note we shouldn't eat the token since the callback needs it.; if (Tok.is(tok::annot_repl_input_end) && Actions.getLangOpts().CPlusPlus); CurTok = &Tok;; else; // Otherwise, eat the semicolon.; ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);. StmtResult R = handleExprStmt(Expr, StmtCtx);; if (CurTok && !R.isInvalid()); CurTok->setAnnotationValue(R.get());. return R;; }. AST Transformation; -------------------. When Sema encounters the ``annot_repl_input_end`` token, it knows to transform; the AST before the real CodeGen process. It will consume the token and set a; 'semi missing' bit in the respective decl. .. co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:20668,Testability,log,logic,20668,"t to do value printing. Note this is only enabled in C++ mode; // since part of the implementation requires C++ language features.; // Note we shouldn't eat the token since the callback needs it.; if (Tok.is(tok::annot_repl_input_end) && Actions.getLangOpts().CPlusPlus); CurTok = &Tok;; else; // Otherwise, eat the semicolon.; ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);. StmtResult R = handleExprStmt(Expr, StmtCtx);; if (CurTok && !R.isInvalid()); CurTok->setAnnotationValue(R.get());. return R;; }. AST Transformation; -------------------. When Sema encounters the ``annot_repl_input_end`` token, it knows to transform; the AST before the real CodeGen process. It will consume the token and set a; 'semi missing' bit in the respective decl. .. code-block:: console. if (Tok.is(tok::annot_repl_input_end) &&; Tok.getAnnotationValue() != nullptr) {; ConsumeAnnotationToken();; cast<TopLevelStmtDecl>(DeclsInGroup.back())->setSemiMissing();; }. In the AST Consumer, traverse all the Top Level Decls, to look for expressions; to synthesize. If the current Decl is the Top Level Statement; Decl(``TopLevelStmtDecl``) and has a semicolon missing, then ask the interpreter; to synthesize another expression (an internal function call) to replace this; original expression. Detailed RFC and Discussion:; ----------------------------. For more technical details, community discussion and links to patches related; to these features,; Please visit: `RFC on LLVM Discourse <https://discourse.llvm.org/t/rfc-handle-execution-results-in-clang-repl/68493>`_. Some logic presented in the RFC (e.g. ValueGetter()) may be outdated,; compared to the final developed solution. Related Reading; ===============; `Cling Transitions to LLVM's Clang-Repl <https://root.cern/blog/cling-in-llvm/>`_. `Moving (parts of) the Cling REPL in Clang <https://lists.llvm.org/pipermail/llvm-dev/2020-July/143257.html>`_. `GPU Accelerated Automatic Differentiation With Clad <https://arxiv.org/pdf/2203.06139.pdf>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10180,Usability,user experience,user experience,10180,"Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11726,Usability,clear,clear,11726,"es use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:13941,Usability,simpl,simplified,13941,"ution results of an expression are stored in the object 'V' of; type Value. This value is then printed, effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&qu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:14312,Usability,simpl,simply,14312," Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; scie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:17601,Usability,clear,clear,17601,"Validate and push \n to dump()"", shape=""box""];; callp [label="" call print() function "", shape=""box""];; type [label="" Print the Type \n ReplPrintTypeImpl()"", shape=""box""];; data [label="" Print the Data \n ReplPrintDataImpl() "", shape=""box""];; output [label="" Output Pretty Print \n to the user "", shape=""box"", fontcolor=white, fillcolor=""#3333ff"", style=filled];. parse -> capture [label=""Optional 'Value' Parameter""];; capture -> use [label=""Yes""];; use -> End;; capture -> dump [label=""No""];; dump -> callp;; callp -> type;; callp -> data;; type -> output;; data -> output;; }. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. llvm::Error Interpreter::ParseAndExecute(llvm::StringRef Code, Value *V) {. auto PTU = Parse(Code);; if (!PTU); return PTU.takeError();; if (PTU->TheModule); if (llvm::Error Err = Execute(*PTU)); return Err;. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }; return llvm::Error::success();; }. The ``dump()`` function (in ``value.cpp``) calls the ``print()`` function. Printing the Data and Type are handled in their respective functions:; ``ReplPrintDataImpl()`` and ``ReplPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangRepl.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3686,Deployability,integrat,integrations,3686,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3673,Energy Efficiency,power,powerful,3673,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:2875,Integrability,interface,interface,2875,"long side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed dur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3686,Integrability,integrat,integrations,3686,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:302,Modifiability,refactor,refactoring,302,"========; Overview; ========. Clang Tools are standalone command line (and potentially GUI) tools; designed for use by C++ developers who are already using and enjoying; Clang as their compiler. These tools provide developer-oriented; functionality such as fast syntax checking, automatic formatting,; refactoring, etc. Only a couple of the most basic and fundamental tools are kept in the; primary Clang tree. The rest of the tools are kept in a separate; directory tree, `clang-tools-extra; <https://github.com/llvm/llvm-project/tree/main/clang-tools-extra>`_. This document describes a high-level overview of the organization of; Clang Tools within the project as well as giving an introduction to some; of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1401,Modifiability,refactor,refactoring,1401,"most basic and fundamental tools are kept in the; primary Clang tree. The rest of the tools are kept in a separate; directory tree, `clang-tools-extra; <https://github.com/llvm/llvm-project/tree/main/clang-tools-extra>`_. This document describes a high-level overview of the organization of; Clang Tools within the project as well as giving an introduction to some; of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1667,Modifiability,refactor,refactoring,1667,"of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3421,Modifiability,config,configurable,3421,"y those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3722,Modifiability,refactor,refactoring,3722,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4372,Modifiability,portab,portability,4372," tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4388,Modifiability,maintainab,maintainability,4388," tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4358,Performance,perform,performance,4358," tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4317,Safety,detect,detecting,4317," tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4803,Safety,detect,detect,4803,"xtra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will convert ``auto`` to an explicit type or add; comments with deduced types. The motivation is that there are developers; that don't want to use ``auto`` because they are afraid that they might lose; control over their code. * C++14: less verbose operator function objects (`N3421; <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm>`_).; For example:. .. code-block:: c++. sort(v.begin(), v.end(), greater<ValueType>());. should be rewritten to:. .. code-block:: c++. sort(v.be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1351,Testability,log,logic,1351,"most basic and fundamental tools are kept in the; primary Clang tree. The rest of the tools are kept in a separate; directory tree, `clang-tools-extra; <https://github.com/llvm/llvm-project/tree/main/clang-tools-extra>`_. This document describes a high-level overview of the organization of; Clang Tools within the project as well as giving an introduction to some; of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1846,Testability,test,test,1846," Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by synt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:2627,Testability,test,testing,2627,"r much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace aroun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3440,Usability,guid,guides,3440,"y those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTools.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9069,Availability,avail,available,9069,"o; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:17196,Deployability,configurat,configuration,17196,"ule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original name and the target. For details, see; `clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h <https://github.com/llvm/llvm-project/blob/main/clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h>`_. Related Reading; ---------------. A good place to start understanding the clang AST and its matchers is with the; introductions on clang's site:. * :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>`; * :doc:`Matching the Clang AST <LibASTMatchers>`; * `AST Matcher Reference <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_. .. rubric:: Footnotes. .. [#f1] Technically, it binds it to the string ""str"", to which our; variable ``s`` is bound. But, the choice of that id string is; irrelevant, so elide the difference.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:2048,Integrability,depend,depends,2048," target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3804,Integrability,message,message,3804,"ho are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3851,Integrability,message,message,3851,"ho are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:4000,Integrability,message,message,4000," ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:4973,Integrability,message,message,4973,"lly, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX;`` |; +--------------------------+----------------------------+. Example: method to function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Next, let's write a rule to replace a method call with a (free) function call,; applied to the original method call's target object. Specifically, ""change; ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``."" We start with a simpler; change that ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9964,Integrability,bridg,bridge,9964,"s. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code locations and other, low-level syntactic; details. Range Selectors; ^^^^^^^^^^^^^^^. Transformer provides a small API for describing source ranges: the; ``RangeSelector`` combinators. These ranges are most commonly used to specify the; source code affected by an edit and to extract source code in constructing new; text. Roughly, there are two kinds of range combinators: ones that select a source; range based on the AST, and others that combine existing ranges into new ranges.; For example, ``node`` selects the range of source spanned by a particular AST; node, as we've seen, while ``after`` selects the (empty) range located immediately; after its argument range. So, ``after(node(""id""))`` is the empty range immediately; following the AST node bound to ``id``. For the full collection of ``RangeSelector``\ s, see the header,; `clang/Tooling/Transformer/RangeSelector.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12020,Integrability,message,messages,12020,"g/Tooling/Transformer/RangeSelector.h>`_. Stencils; ^^^^^^^^. Transformer offers a large and growing collection of combinators for; constructing output. Above, we demonstrated ``cat``, the core function for; constructing stencils. It takes a series of arguments, of three possible kinds:. #. Raw text, to be copied directly to the output.; #. Selector: specified with a ``RangeSelector``, indicates a range of source text; to copy to the output.; #. Builder: an operation that constructs a code snippet from its arguments. For; example, the ``access`` function we saw above. Data of these different types are all represented (generically) by a ``Stencil``.; ``cat`` takes text and ``RangeSelector``\ s directly as arguments, rather than; requiring that they be constructed with a builder; other builders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/inc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:531,Modifiability,rewrite,rewrite,531,"==========================; Clang Transformer Tutorial; ==========================. A tutorial on how to write a source-to-source translation tool using Clang Transformer. .. contents::; :local:. What is Clang Transformer?; --------------------------. Clang Transformer is a framework for writing C++ diagnostics and program; transformations. It is built on the clang toolchain and the LibTooling library,; but aims to hide much of the complexity of clang's native, low-level libraries. The core abstraction of Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:1206,Modifiability,variab,variables,1206,"lation tool using Clang Transformer. .. contents::; :local:. What is Clang Transformer?; --------------------------. Clang Transformer is a framework for writing C++ diagnostics and program; transformations. It is built on the clang toolchain and the LibTooling library,; but aims to hide much of the complexity of clang's native, low-level libraries. The core abstraction of Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3220,Modifiability,rewrite,rewrite,3220,"d 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3456,Modifiability,rewrite,rewrite,3456,"Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:4431,Modifiability,extend,extend,4431,"es. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6816,Modifiability,rewrite,rewrite,6816,"hat ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7970,Modifiability,rewrite,rewrite,7970,"he rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8048,Modifiability,rewrite,rewrite,8048,"keRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8259,Modifiability,rewrite,rewrite,8259,"avor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9016,Modifiability,rewrite,rewrite,9016,".foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9289,Modifiability,rewrite,rewrite,9289,"To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code locations and other, low-level syntactic; details. Range Selectors; ^^^^^^^^^^^^^^^. Transformer provides a small API for describing source ranges: the; ``RangeSelector`` combinators. These ranges are most c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9481,Modifiability,rewrite,rewrite,9481,"as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code locations and other, low-level syntactic; details. Range Selectors; ^^^^^^^^^^^^^^^. Transformer provides a small API for describing source ranges: the; ``RangeSelector`` combinators. These ranges are most commonly used to specify the; source code affected by an edit and to extract source code in constructing new; text. Roughly, there are two kinds of range combin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:15300,Modifiability,rewrite,rewrite,15300,"de/clang/Tooling/Transformer/RewriteRule.h#L165-L167>`_; ``EditGenerator``\ s, like list flattening. For the full list, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Rules; ^^^^^. We can also compose multiple *rules*, rather than just edits within a rule,; using ``applyFirst``: it composes a list of rules as an ordered choice, where; Transformer applies the first rule whose pattern matches, ignoring others in the; list that follow. If the matchers are independent then order doesn't matter. In; that case, ``applyFirst`` is simply joining the set of rules into one. The benefit of ``applyFirst`` is that, for some problems, it allows the user to; more concisely formulate later rules in the list, since their patterns need not; explicitly exclude the earlier patterns of the list. For example, consider a set; of rules that rewrite compound statements, where one rule handles the case of an; empty compound statement and the other handles non-empty compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this end, users can modify rules to specify include; directives with ``addInclude``. For additional documentation on these functions, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; ---------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:16418,Modifiability,rewrite,rewrite,16418," compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this end, users can modify rules to specify include; directives with ``addInclude``. For additional documentation on these functions, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:17132,Modifiability,config,configured,17132,"ule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original name and the target. For details, see; `clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h <https://github.com/llvm/llvm-project/blob/main/clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h>`_. Related Reading; ---------------. A good place to start understanding the clang AST and its matchers is with the; introductions on clang's site:. * :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>`; * :doc:`Matching the Clang AST <LibASTMatchers>`; * `AST Matcher Reference <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_. .. rubric:: Footnotes. .. [#f1] Technically, it binds it to the string ""str"", to which our; variable ``s`` is bound. But, the choice of that id string is; irrelevant, so elide the difference.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:17196,Modifiability,config,configuration,17196,"ule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original name and the target. For details, see; `clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h <https://github.com/llvm/llvm-project/blob/main/clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h>`_. Related Reading; ---------------. A good place to start understanding the clang AST and its matchers is with the; introductions on clang's site:. * :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>`; * :doc:`Matching the Clang AST <LibASTMatchers>`; * `AST Matcher Reference <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_. .. rubric:: Footnotes. .. [#f1] Technically, it binds it to the string ""str"", to which our; variable ``s`` is bound. But, the choice of that id string is; irrelevant, so elide the difference.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:17394,Modifiability,parameteriz,parameterized,17394,"ule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original name and the target. For details, see; `clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h <https://github.com/llvm/llvm-project/blob/main/clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h>`_. Related Reading; ---------------. A good place to start understanding the clang AST and its matchers is with the; introductions on clang's site:. * :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>`; * :doc:`Matching the Clang AST <LibASTMatchers>`; * `AST Matcher Reference <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_. .. rubric:: Footnotes. .. [#f1] Technically, it binds it to the string ""str"", to which our; variable ``s`` is bound. But, the choice of that id string is; irrelevant, so elide the difference.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:18086,Modifiability,variab,variable,18086,"ule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original name and the target. For details, see; `clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h <https://github.com/llvm/llvm-project/blob/main/clang-tools-extra/clang-tidy/utils/TransformerClangTidyCheck.h>`_. Related Reading; ---------------. A good place to start understanding the clang AST and its matchers is with the; introductions on clang's site:. * :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>`; * :doc:`Matching the Clang AST <LibASTMatchers>`; * `AST Matcher Reference <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_. .. rubric:: Footnotes. .. [#f1] Technically, it binds it to the string ""str"", to which our; variable ``s`` is bound. But, the choice of that id string is; irrelevant, so elide the difference.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7851,Security,access,accessor,7851,"those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8331,Security,access,access,8331,"^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8394,Security,access,access,8394,"^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8429,Security,access,access,8429," string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8476,Security,access,access,8476,", if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8549,Security,access,accessed,8549,"ck:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8846,Security,access,access,8846,"is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:11571,Security,access,access,11571,"e, ``node`` selects the range of source spanned by a particular AST; node, as we've seen, while ``after`` selects the (empty) range located immediately; after its argument range. So, ``after(node(""id""))`` is the empty range immediately; following the AST node bound to ``id``. For the full collection of ``RangeSelector``\ s, see the header,; `clang/Tooling/Transformer/RangeSelector.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RangeSelector.h>`_. Stencils; ^^^^^^^^. Transformer offers a large and growing collection of combinators for; constructing output. Above, we demonstrated ``cat``, the core function for; constructing stencils. It takes a series of arguments, of three possible kinds:. #. Raw text, to be copied directly to the output.; #. Selector: specified with a ``RangeSelector``, indicates a range of source text; to copy to the output.; #. Builder: an operation that constructs a code snippet from its arguments. For; example, the ``access`` function we saw above. Data of these different types are all represented (generically) by a ``Stencil``.; ``cat`` takes text and ``RangeSelector``\ s directly as arguments, rather than; requiring that they be constructed with a builder; other builders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could ch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:1545,Usability,simpl,simply,1545,"f Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3054,Usability,guid,guide,3054," repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:5822,Usability,simpl,simpler,5822,"it (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX;`` |; +--------------------------+----------------------------+. Example: method to function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Next, let's write a rule to replace a method call with a (free) function call,; applied to the original method call's target object. Specifically, ""change; ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``."" We start with a simpler; change that ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6923,Usability,simpl,simply,6923,"thod is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12781,Usability,simpl,simpler,12781,"ilders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. We are not limited one edit per match found. Some situations require making; multiple edits for each match. For example, suppose we wanted to swap two; arguments of a function call. For this, we provide an overload of ``makeRule`` that takes a list of edits,; rather than just a single one. Our example might look like:. .. code-block:: c++. makeRule(callExpr(...),; 	 {changeTo(node(arg0), cat(node(arg2))),; 	 changeTo(node(arg2), cat(node(arg0)))},; 	 cat(""swap the first and third arguments of the call""));. ``EditGenerator``\ s (Advanced); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The particular edits we've seen so far are all instances of the ``ASTEdit`` class,; or a list of such. But, not all edits can be expressed as ``ASTEdit``\ s. So, we; als",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:15000,Usability,simpl,simply,15000,"unction that maps a ``MatchResult`` to a set; of edits, or fails. This signature supports a very general form of computation; over match results. Transformer provides a number of functions for working with; ``EditGenerator``\ s, most notably; `flatten <https://github.com/llvm/llvm-project/blob/1fabe6e51917bcd7a1242294069c682fe6dffa45/clang/include/clang/Tooling/Transformer/RewriteRule.h#L165-L167>`_; ``EditGenerator``\ s, like list flattening. For the full list, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Rules; ^^^^^. We can also compose multiple *rules*, rather than just edits within a rule,; using ``applyFirst``: it composes a list of rules as an ordered choice, where; Transformer applies the first rule whose pattern matches, ignoring others in the; list that follow. If the matchers are independent then order doesn't matter. In; that case, ``applyFirst`` is simply joining the set of rules into one. The benefit of ``applyFirst`` is that, for some problems, it allows the user to; more concisely formulate later rules in the list, since their patterns need not; explicitly exclude the earlier patterns of the list. For example, consider a set; of rules that rewrite compound statements, where one rule handles the case of an; empty compound statement and the other handles non-empty compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this en",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:428,Availability,error,error,428,"====================; Constant Interpreter; ====================. .. contents::; :local:. Introduction; ============. The constexpr interpreter aims to replace the existing tree evaluator in; clang, improving performance on constructs which are executed inefficiently; by the evaluator. The interpreter is activated using the following flags:. * ``-fexperimental-new-constant-interpreter`` enables the interpreter,; emitting an error if an unsupported feature is encountered. Bytecode Compilation; ====================. Bytecode compilation is handled in ``ByteCodeStmtGen.h`` for statements; and ``ByteCodeExprGen.h`` for expressions. The compiler has two different; backends: one to generate bytecode for functions (``ByteCodeEmitter``) and; one to directly evaluate expressions as they are compiled, without; generating bytecode (``EvalEmitter``). All functions are compiled to; bytecode, while toplevel expressions used in constant contexts are directly; evaluated since the bytecode would never be reused. This mechanism aims to; pave the way towards replacing the evaluator, improving its performance on; functions and loops, while being just as fast on single-use toplevel; expressions. The interpreter relies on stack-based, strongly-typed opcodes. The glue; logic between the code generator, along with the enumeration and; description of opcodes, can be found in ``Opcodes.td``. The opcodes are; implemented as generic template methods in ``Interp.h`` and instantiated; with the relevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:5269,Availability,alive,alive,5269,"ibe blocks and subobjects nested inside blocks. Blocks; ------. Blocks contain data interleaved with metadata. They are allocated either; statically in the code generator (globals, static members, dummy parameter; values etc.) or dynamically in the interpreter, when creating the frame; containing the local variables of a function. Blocks are associated with a; descriptor that characterises the entire allocation, along with a few; additional attributes:. * ``IsStatic`` indicates whether the block has static duration in the; interpreter, i.e. it is not a local in a frame. * ``DeclID`` identifies each global declaration (it is set to an invalid; and irrelevant value for locals) in order to prevent illegal writes and; reads involving globals and temporaries with static storage duration. Static blocks are never deallocated, but local ones might be deallocated; even when there are live pointers to them. Pointers are only valid as; long as the blocks they point to are valid, so a block with pointers to; it whose lifetime ends is kept alive until all pointers to it go out of; scope. Since the frame is destroyed on function exit, such blocks are; turned into a ``DeadBlock`` and copied to storage managed by the; interpreter itself, not the frame. Reads and writes to these blocks are; illegal and cause an appropriate diagnostic to be emitted. When the last; pointer goes out of scope, dead blocks are also deallocated. The lifetime of blocks is managed through 3 methods stored in the; descriptor of the block:. * **CtorFn**: initializes the metadata which is store in the block,; alongside actual data. Invokes the default constructors of objects; which are not trivial (``Pointer``, ``RealFP``, etc.). * **DtorFn**: invokes the destructors of non-trivial objects. * **MoveFn**: moves a block to dead storage. Non-static blocks track all the pointers into them through an intrusive; doubly-linked list, required to adjust and invalidate all pointers when; transforming a block into a dead ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8781,Availability,avail,available,8781," to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dummy pointer created by an invalid operation which; allows the interpreter to continue execution. Does not allow pointer; arithmetic or dereferencing. Besides the previously mentioned union, a number of other pointer-like types; have their own type:. * **ObjCBlockPointer** tracks Objective-C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:14521,Availability,failure,failure,14521,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:2458,Energy Efficiency,allocate,allocated,2458,"elevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these types is required by opcodes to; share an implementation with fixed integrals. * ``PT_Bool``. Representation for boolean types, essentially a 1-bit unsigned; ``Integral``. * ``PT_RealFP``. Arbitrary, but fixed precision floating point numbers. Could be; specialised in the future similarly to integers in order to improve; floating point performance. * ``PT_Ptr``. Pointer type, defined in ``""Pointer.h""``. A pointer can be either null,; reference interpreter-allocated memory (``BlockPointer``) or point to an; address which can be derived, but not accessed (``ExternPointer``). * ``PT_FnPtr``. Function pointer type, can also be a null function pointer. Defined; in ``""FnPointer.h""``. * ``PT_MemPtr``. Member pointer type, can also be a null member pointer. Defined; in ``""MemberPointer.h""``. * ``PT_VoidPtr``. Void pointer type, can be used for round-trip casts. Represented as; the union of all pointers which can be cast to void.; Defined in ``""VoidPointer.h""``. * ``PT_ObjCBlockPtr``. Pointer type for ObjC blocks. Defined in ``""ObjCBlockPointer.h""``. Composite types; ---------------. The interpreter distinguishes two kinds of composite types: arrays and; records (structs and classes). Unions are represented as records, except; at most a single field can be marked as active. The contents of inactive; fields are kept until they are reactivated and overwritten.; Complex numbers (``_Complex``) and vectors; (``__attribute((vector_size(16)))``) are treated as arrays. Bytecode Executi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:4346,Energy Efficiency,allocate,allocated,4346,"mplex``) and vectors; (``__attribute((vector_size(16)))``) are treated as arrays. Bytecode Execution; ==================. Bytecode is executed using a stack-based interpreter. The execution; context consists of an ``InterpStack``, along with a chain of; ``InterpFrame`` objects storing the call frames. Frames are built by; call instructions and destroyed by return instructions. They perform; one allocation to reserve space for all locals in a single block.; These objects store all the required information to emit stack traces; whenever evaluation fails. Memory Organisation; ===================. Memory management in the interpreter relies on 3 data structures: ``Block``; objects which store the data and associated inline metadata, ``Pointer``; objects which refer to or into blocks, and ``Descriptor`` structures which; describe blocks and subobjects nested inside blocks. Blocks; ------. Blocks contain data interleaved with metadata. They are allocated either; statically in the code generator (globals, static members, dummy parameter; values etc.) or dynamically in the interpreter, when creating the frame; containing the local variables of a function. Blocks are associated with a; descriptor that characterises the entire allocation, along with a few; additional attributes:. * ``IsStatic`` indicates whether the block has static duration in the; interpreter, i.e. it is not a local in a frame. * ``DeclID`` identifies each global declaration (it is set to an invalid; and irrelevant value for locals) in order to prevent illegal writes and; reads involving globals and temporaries with static storage duration. Static blocks are never deallocated, but local ones might be deallocated; even when there are live pointers to them. Pointers are only valid as; long as the blocks they point to are valid, so a block with pointers to; it whose lifetime ends is kept alive until all pointers to it go out of; scope. Since the frame is destroyed on function exit, such blocks are; turned into ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8859,Energy Efficiency,allocate,allocated,8859,"e used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dummy pointer created by an invalid operation which; allows the interpreter to continue execution. Does not allow pointer; arithmetic or dereferencing. Besides the previously mentioned union, a number of other pointer-like types; have their own type:. * **ObjCBlockPointer** tracks Objective-C blocks; * **FnPointer** tracks functions and lazily caches their compiled version; * **MemberPointer** tracks C++ object members. Void pointers, which can be bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:4534,Modifiability,variab,variables,4534,"=========. Bytecode is executed using a stack-based interpreter. The execution; context consists of an ``InterpStack``, along with a chain of; ``InterpFrame`` objects storing the call frames. Frames are built by; call instructions and destroyed by return instructions. They perform; one allocation to reserve space for all locals in a single block.; These objects store all the required information to emit stack traces; whenever evaluation fails. Memory Organisation; ===================. Memory management in the interpreter relies on 3 data structures: ``Block``; objects which store the data and associated inline metadata, ``Pointer``; objects which refer to or into blocks, and ``Descriptor`` structures which; describe blocks and subobjects nested inside blocks. Blocks; ------. Blocks contain data interleaved with metadata. They are allocated either; statically in the code generator (globals, static members, dummy parameter; values etc.) or dynamically in the interpreter, when creating the frame; containing the local variables of a function. Blocks are associated with a; descriptor that characterises the entire allocation, along with a few; additional attributes:. * ``IsStatic`` indicates whether the block has static duration in the; interpreter, i.e. it is not a local in a frame. * ``DeclID`` identifies each global declaration (it is set to an invalid; and irrelevant value for locals) in order to prevent illegal writes and; reads involving globals and temporaries with static storage duration. Static blocks are never deallocated, but local ones might be deallocated; even when there are live pointers to them. Pointers are only valid as; long as the blocks they point to are valid, so a block with pointers to; it whose lifetime ends is kept alive until all pointers to it go out of; scope. Since the frame is destroyed on function exit, such blocks are; turned into a ``DeadBlock`` and copied to storage managed by the; interpreter itself, not the frame. Reads and writes to th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:12898,Modifiability,variab,variable,12898,"t). All the relevant attributes can be read; from either the inline descriptor or the descriptor of the block. Array elements are identified by the ``Offset`` field of pointers,; pointing to past the inline descriptors for composites and before; the actual data in the case of primitive arrays. The ``Offset``; points to the offset where primitives can be read from. As an example,; ``a.c + 1`` would have the same base as ``a.c`` since it is an element; of ``a.c``, but its offset would point to ``&a.c[1]``. The; array-to-pointer decay operation adjusts a pointer to an array (where; the offset is equal to the base) to a pointer to the first element. ExternPointer; ~~~~~~~~~~~~~. Extern pointers can be derived, pointing into symbols which are not; readable from constexpr. An external pointer consists of a base; declaration, along with a path designating a subobject, similar to; the ``LValuePath`` of an APValue. Extern pointers can be converted; to block pointers if the underlying variable is defined after the; pointer is created, as is the case in the following example:. .. code-block:: c. extern const int a;; constexpr const int *p = &a;; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:209,Performance,perform,performance,209,"====================; Constant Interpreter; ====================. .. contents::; :local:. Introduction; ============. The constexpr interpreter aims to replace the existing tree evaluator in; clang, improving performance on constructs which are executed inefficiently; by the evaluator. The interpreter is activated using the following flags:. * ``-fexperimental-new-constant-interpreter`` enables the interpreter,; emitting an error if an unsupported feature is encountered. Bytecode Compilation; ====================. Bytecode compilation is handled in ``ByteCodeStmtGen.h`` for statements; and ``ByteCodeExprGen.h`` for expressions. The compiler has two different; backends: one to generate bytecode for functions (``ByteCodeEmitter``) and; one to directly evaluate expressions as they are compiled, without; generating bytecode (``EvalEmitter``). All functions are compiled to; bytecode, while toplevel expressions used in constant contexts are directly; evaluated since the bytecode would never be reused. This mechanism aims to; pave the way towards replacing the evaluator, improving its performance on; functions and loops, while being just as fast on single-use toplevel; expressions. The interpreter relies on stack-based, strongly-typed opcodes. The glue; logic between the code generator, along with the enumeration and; description of opcodes, can be found in ``Opcodes.td``. The opcodes are; implemented as generic template methods in ``Interp.h`` and instantiated; with the relevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:1095,Performance,perform,performance,1095,"n; ============. The constexpr interpreter aims to replace the existing tree evaluator in; clang, improving performance on constructs which are executed inefficiently; by the evaluator. The interpreter is activated using the following flags:. * ``-fexperimental-new-constant-interpreter`` enables the interpreter,; emitting an error if an unsupported feature is encountered. Bytecode Compilation; ====================. Bytecode compilation is handled in ``ByteCodeStmtGen.h`` for statements; and ``ByteCodeExprGen.h`` for expressions. The compiler has two different; backends: one to generate bytecode for functions (``ByteCodeEmitter``) and; one to directly evaluate expressions as they are compiled, without; generating bytecode (``EvalEmitter``). All functions are compiled to; bytecode, while toplevel expressions used in constant contexts are directly; evaluated since the bytecode would never be reused. This mechanism aims to; pave the way towards replacing the evaluator, improving its performance on; functions and loops, while being just as fast on single-use toplevel; expressions. The interpreter relies on stack-based, strongly-typed opcodes. The glue; logic between the code generator, along with the enumeration and; description of opcodes, can be found in ``Opcodes.td``. The opcodes are; implemented as generic template methods in ``Interp.h`` and instantiated; with the relevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these types is required by opcodes to; share an implementation with fixed integrals. * ``PT_Bool``. Representa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:2336,Performance,perform,performance,2336,"rator, along with the enumeration and; description of opcodes, can be found in ``Opcodes.td``. The opcodes are; implemented as generic template methods in ``Interp.h`` and instantiated; with the relevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these types is required by opcodes to; share an implementation with fixed integrals. * ``PT_Bool``. Representation for boolean types, essentially a 1-bit unsigned; ``Integral``. * ``PT_RealFP``. Arbitrary, but fixed precision floating point numbers. Could be; specialised in the future similarly to integers in order to improve; floating point performance. * ``PT_Ptr``. Pointer type, defined in ``""Pointer.h""``. A pointer can be either null,; reference interpreter-allocated memory (``BlockPointer``) or point to an; address which can be derived, but not accessed (``ExternPointer``). * ``PT_FnPtr``. Function pointer type, can also be a null function pointer. Defined; in ``""FnPointer.h""``. * ``PT_MemPtr``. Member pointer type, can also be a null member pointer. Defined; in ``""MemberPointer.h""``. * ``PT_VoidPtr``. Void pointer type, can be used for round-trip casts. Represented as; the union of all pointers which can be cast to void.; Defined in ``""VoidPointer.h""``. * ``PT_ObjCBlockPtr``. Pointer type for ObjC blocks. Defined in ``""ObjCBlockPointer.h""``. Composite types; ---------------. The interpreter distinguishes two kinds of composite types: arrays and; records (structs and classes). Unions are represented as records, except; at most a single field can be marked as active. The content",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:3778,Performance,perform,perform,3778,"oid pointer type, can be used for round-trip casts. Represented as; the union of all pointers which can be cast to void.; Defined in ``""VoidPointer.h""``. * ``PT_ObjCBlockPtr``. Pointer type for ObjC blocks. Defined in ``""ObjCBlockPointer.h""``. Composite types; ---------------. The interpreter distinguishes two kinds of composite types: arrays and; records (structs and classes). Unions are represented as records, except; at most a single field can be marked as active. The contents of inactive; fields are kept until they are reactivated and overwritten.; Complex numbers (``_Complex``) and vectors; (``__attribute((vector_size(16)))``) are treated as arrays. Bytecode Execution; ==================. Bytecode is executed using a stack-based interpreter. The execution; context consists of an ``InterpStack``, along with a chain of; ``InterpFrame`` objects storing the call frames. Frames are built by; call instructions and destroyed by return instructions. They perform; one allocation to reserve space for all locals in a single block.; These objects store all the required information to emit stack traces; whenever evaluation fails. Memory Organisation; ===================. Memory management in the interpreter relies on 3 data structures: ``Block``; objects which store the data and associated inline metadata, ``Pointer``; objects which refer to or into blocks, and ``Descriptor`` structures which; describe blocks and subobjects nested inside blocks. Blocks; ------. Blocks contain data interleaved with metadata. They are allocated either; statically in the code generator (globals, static members, dummy parameter; values etc.) or dynamically in the interpreter, when creating the frame; containing the local variables of a function. Blocks are associated with a; descriptor that characterises the entire allocation, along with a few; additional attributes:. * ``IsStatic`` indicates whether the block has static duration in the; interpreter, i.e. it is not a local in a frame. * ``DeclI",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:9835,Performance,cache,caches,9835,"nter**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dummy pointer created by an invalid operation which; allows the interpreter to continue execution. Does not allow pointer; arithmetic or dereferencing. Besides the previously mentioned union, a number of other pointer-like types; have their own type:. * **ObjCBlockPointer** tracks Objective-C blocks; * **FnPointer** tracks functions and lazily caches their compiled version; * **MemberPointer** tracks C++ object members. Void pointers, which can be built by casting any of the aforementioned; pointers, are implemented as a union of all pointer types. The ``BitCast``; opcode is responsible for performing all legal conversions between these; types and primitive integers. BlockPointer; ~~~~~~~~~~~~. Block pointers track a ``Pointee``, the block to which they point, along; with a ``Base`` and an ``Offset``. The base identifies the innermost field,; while the offset points to an array element relative to the base (including; one-past-end pointers). The offset identifies the array element or field; which is referenced, while the base points to the outer object or array which; contains the field. These two fields allow all pointers to be uniquely; identified, disambiguated and characterised. As an example, consider the following structure:. .. code-block:: c. struct A {; struct B {; int x;; int y;; } b;; struct C {; int a;; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:10087,Performance,perform,performing,10087,"tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dummy pointer created by an invalid operation which; allows the interpreter to continue execution. Does not allow pointer; arithmetic or dereferencing. Besides the previously mentioned union, a number of other pointer-like types; have their own type:. * **ObjCBlockPointer** tracks Objective-C blocks; * **FnPointer** tracks functions and lazily caches their compiled version; * **MemberPointer** tracks C++ object members. Void pointers, which can be built by casting any of the aforementioned; pointers, are implemented as a union of all pointer types. The ``BitCast``; opcode is responsible for performing all legal conversions between these; types and primitive integers. BlockPointer; ~~~~~~~~~~~~. Block pointers track a ``Pointee``, the block to which they point, along; with a ``Base`` and an ``Offset``. The base identifies the innermost field,; while the offset points to an array element relative to the base (including; one-past-end pointers). The offset identifies the array element or field; which is referenced, while the base points to the outer object or array which; contains the field. These two fields allow all pointers to be uniquely; identified, disambiguated and characterised. As an example, consider the following structure:. .. code-block:: c. struct A {; struct B {; int x;; int y;; } b;; struct C {; int a;; int b;; } c[2];; int z;; };; constexpr A a;. On the target, ``&a`` and ``&a.b.x`` are equal. So are ``&a.c[0]`` and; ``&a.c[0].a``. In the interpreter, all these pointers must be; distinguished since the are all allowed to address distinct range of; memory. In the interpreter, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:2548,Security,access,accessed,2548,"elevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these types is required by opcodes to; share an implementation with fixed integrals. * ``PT_Bool``. Representation for boolean types, essentially a 1-bit unsigned; ``Integral``. * ``PT_RealFP``. Arbitrary, but fixed precision floating point numbers. Could be; specialised in the future similarly to integers in order to improve; floating point performance. * ``PT_Ptr``. Pointer type, defined in ``""Pointer.h""``. A pointer can be either null,; reference interpreter-allocated memory (``BlockPointer``) or point to an; address which can be derived, but not accessed (``ExternPointer``). * ``PT_FnPtr``. Function pointer type, can also be a null function pointer. Defined; in ``""FnPointer.h""``. * ``PT_MemPtr``. Member pointer type, can also be a null member pointer. Defined; in ``""MemberPointer.h""``. * ``PT_VoidPtr``. Void pointer type, can be used for round-trip casts. Represented as; the union of all pointers which can be cast to void.; Defined in ``""VoidPointer.h""``. * ``PT_ObjCBlockPtr``. Pointer type for ObjC blocks. Defined in ``""ObjCBlockPointer.h""``. Composite types; ---------------. The interpreter distinguishes two kinds of composite types: arrays and; records (structs and classes). Unions are represented as records, except; at most a single field can be marked as active. The contents of inactive; fields are kept until they are reactivated and overwritten.; Complex numbers (``_Complex``) and vectors; (``__attribute((vector_size(16)))``) are treated as arrays. Bytecode Executi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8387,Security,access,access,8387," to arrays of composites: each field and base; class is preceded by an inline descriptor. The ``InlineDescriptor``; has the following fields:. * **Offset**: byte offset into the array or record, used to step back to the; parent array or record.; * **IsConst**: flag indicating if the field is const-qualified.; * **IsInitialized**: flag indicating whether the field or element was; initialized. For non-primitive fields, this is only relevant to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8506,Security,access,access,8506,"t**: byte offset into the array or record, used to step back to the; parent array or record.; * **IsConst**: flag indicating if the field is const-qualified.; * **IsInitialized**: flag indicating whether the field or element was; initialized. For non-primitive fields, this is only relevant to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:1267,Testability,log,logic,1267,"ng the following flags:. * ``-fexperimental-new-constant-interpreter`` enables the interpreter,; emitting an error if an unsupported feature is encountered. Bytecode Compilation; ====================. Bytecode compilation is handled in ``ByteCodeStmtGen.h`` for statements; and ``ByteCodeExprGen.h`` for expressions. The compiler has two different; backends: one to generate bytecode for functions (``ByteCodeEmitter``) and; one to directly evaluate expressions as they are compiled, without; generating bytecode (``EvalEmitter``). All functions are compiled to; bytecode, while toplevel expressions used in constant contexts are directly; evaluated since the bytecode would never be reused. This mechanism aims to; pave the way towards replacing the evaluator, improving its performance on; functions and loops, while being just as fast on single-use toplevel; expressions. The interpreter relies on stack-based, strongly-typed opcodes. The glue; logic between the code generator, along with the enumeration and; description of opcodes, can be found in ``Opcodes.td``. The opcodes are; implemented as generic template methods in ``Interp.h`` and instantiated; with the relevant primitive types by the interpreter loop or by the; evaluating emitter. Primitive Types; ---------------. * ``PT_{U|S}int{8|16|32|64}``. Signed or unsigned integers of a specific bit width, implemented using; the ```Integral``` type. * ``PT_{U|S}intFP``. Signed or unsigned integers of an arbitrary, but fixed width used to; implement integral types which are required by the target, but are not; supported by the host. Under the hood, they rely on APValue. The; ``Integral`` specialisation for these types is required by opcodes to; share an implementation with fixed integrals. * ``PT_Bool``. Representation for boolean types, essentially a 1-bit unsigned; ``Integral``. * ``PT_RealFP``. Arbitrary, but fixed precision floating point numbers. Could be; specialised in the future similarly to integers in order to improve;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:14626,Usability,resume,resume,14626,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:14677,Usability,resume,resume,14677,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:15049,Usability,clear,cleared,15049,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:556,Availability,avail,available,556,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:645,Availability,avail,available,645,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:2899,Availability,down,down,2899,"-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3606,Availability,error,error,3606,"`: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4004,Availability,recover,recover,4004,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:10168,Availability,failure,failures,10168," with ``-fsanitize=cfi-icall`` enabled,; or whose address was taken by a function in a translation unit compiled with; ``-fsanitize=cfi-icall``. If a function in a translation unit compiled with ``-fsanitize=cfi-icall``; takes the address of a function not compiled with ``-fsanitize=cfi-icall``,; that address may differ from the address taken by a function in a translation; unit not compiled with ``-fsanitize=cfi-icall``. This is technically a; violation of the C and C++ standards, but it should not affect most programs. Each translation unit compiled with ``-fsanitize=cfi-icall`` must be; statically linked into the program or shared library, and calls across; shared library boundaries are handled as if the callee was not compiled with; ``-fsanitize=cfi-icall``. This scheme is currently supported on a limited set of targets: x86,; x86_64, arm, arch64 and wasm. ``-fsanitize-cfi-icall-generalize-pointers``; --------------------------------------------. Mismatched pointer types are a common cause of cfi-icall check failures.; Translation units compiled with the ``-fsanitize-cfi-icall-generalize-pointers``; flag relax pointer type checking for call sites in that translation unit,; applied across all functions compiled with ``-fsanitize=cfi-icall``. Specifically, pointers in return and argument types are treated as equivalent as; long as the qualifiers for the type they point to match. For example, ``char*``,; ``char**``, and ``int*`` are considered equivalent types. However, ``char*`` and; ``const char*`` are considered separate types. ``-fsanitize-cfi-icall-generalize-pointers`` is not compatible with; ``-fsanitize-cfi-cross-dso``. .. _cfi-icall-experimental-normalize-integers:. ``-fsanitize-cfi-icall-experimental-normalize-integers``; --------------------------------------------------------. This option enables normalizing integer types as vendor extended types for; cross-language LLVM CFI/KCFI support with other languages that can't represent; and encode C/C++ integer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13010,Availability,avail,available,13010,"roperty allows code that; was not compiled with ``-fsanitize=cfi-icall`` to take a CFI-valid address; of a function, but it comes with a couple of caveats that are especially; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CF",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13168,Availability,mainten,maintenance,13168,"; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:522,Deployability,release,release,522,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:14801,Deployability,deploy,deployed,14801,"quality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will pass CFI checks. ``-fsanitize=cfi-icall`` and ``-fsanitize=function``; ----------------------------------------------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function addr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:14813,Deployability,release,release,14813,"quality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will pass CFI checks. ``-fsanitize=cfi-icall`` and ``-fsanitize=function``; ----------------------------------------------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function addr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:14982,Deployability,deploy,deployment,14982,"anitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will pass CFI checks. ``-fsanitize=cfi-icall`` and ``-fsanitize=function``; ----------------------------------------------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function address equality. These properties make KCFI easier to; adopt in low-level software. KCFI is limited to checking only function; pointers, and isn't compatible with executable-only memory. Member Function Pointer Call Checking",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:916,Energy Efficiency,efficient,efficiently,916,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:6577,Energy Efficiency,allocate,allocate,6577,"ity vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` member function of a standard library allocator). Such; functions may be :ref:`ignored <cfi-ignorelist>`. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Non-Virtual Member Function Call Checking; =========================================. This scheme checks that non-virtual calls take place using an object of; the correct dynamic type; that is, the dynamic type of the called object; must be a derived class of the static type of the object used to make the; call. The checks are currently only introduced where the object is of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-nvcall``. For this scheme to work, all translation units containing the definition; of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13086,Integrability,wrap,wrapper,13086,"; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13132,Integrability,wrap,wrappers,13132,"; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:868,Modifiability,plugin,plugin,868,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:2005,Modifiability,plugin,plugin,2005,"I; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3909,Modifiability,config,configure,3909,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5486,Modifiability,polymorphi,polymorphic,5486,"ion units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:7427,Modifiability,polymorphi,polymorphic,7427,"at; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` member function of a standard library allocator). Such; functions may be :ref:`ignored <cfi-ignorelist>`. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Non-Virtual Member Function Call Checking; =========================================. This scheme checks that non-virtual calls take place using an object of; the correct dynamic type; that is, the dynamic type of the called object; must be a derived class of the static type of the object used to make the; call. The checks are currently only introduced where the object is of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-nvcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. .. _cfi-strictness:. Strictness; ----------. If a class has a single non-virtual base and does not introduce or override; virtual member functions or fields other than an implicitly defined virtual; destructor, it will have the same layout and virtual function semantics as; its base. By default, casts to such classes are checked as if they were made; to the least derived such class. Casting an instance of a base class to such a derived class is technically; undefined behavior, but it is a relatively common hack for intro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:11017,Modifiability,extend,extended,11017,"s``; --------------------------------------------. Mismatched pointer types are a common cause of cfi-icall check failures.; Translation units compiled with the ``-fsanitize-cfi-icall-generalize-pointers``; flag relax pointer type checking for call sites in that translation unit,; applied across all functions compiled with ``-fsanitize=cfi-icall``. Specifically, pointers in return and argument types are treated as equivalent as; long as the qualifiers for the type they point to match. For example, ``char*``,; ``char**``, and ``int*`` are considered equivalent types. However, ``char*`` and; ``const char*`` are considered separate types. ``-fsanitize-cfi-icall-generalize-pointers`` is not compatible with; ``-fsanitize-cfi-cross-dso``. .. _cfi-icall-experimental-normalize-integers:. ``-fsanitize-cfi-icall-experimental-normalize-integers``; --------------------------------------------------------. This option enables normalizing integer types as vendor extended types for; cross-language LLVM CFI/KCFI support with other languages that can't represent; and encode C/C++ integer types. Specifically, integer types are encoded as their defined representations (e.g.,; 8-bit signed integer, 16-bit signed integer, 32-bit signed integer, ...) for; compatibility with languages that define explicitly-sized integer types (e.g.,; i8, i16, i32, ..., in Rust). ``-fsanitize-cfi-icall-experimental-normalize-integers`` is compatible with; ``-fsanitize-cfi-icall-generalize-pointers``. This option is currently experimental. .. _cfi-canonical-jump-tables:. ``-fsanitize-cfi-canonical-jump-tables``; ----------------------------------------. The default behavior of Clang's indirect function call checker will replace; the address of each CFI-checked function in the output file's symbol table; with the address of a jump table entry which will pass CFI checks. We refer; to this as making the jump table `canonical`. This property allows code that; was not compiled with ``-fsanitize=cfi-icall`` to t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:456,Performance,optimiz,optimized,456,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:470,Performance,perform,performance,470,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:742,Performance,optimiz,optimization,742,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4798,Performance,perform,performance,4798,"gnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4968,Performance,perform,performance,4968,"ecover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference betwe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5096,Performance,optimiz,optimized,5096,"===. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, whil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:6507,Performance,perform,perform,6507,"ad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` member function of a standard library allocator). Such; functions may be :ref:`ignored <cfi-ignorelist>`. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Non-Virtual Member Function Call Checking; =========================================. This scheme checks that non-virtual calls take place using an object of; the correct dynamic type; that is, the dynamic type of the called object; must be a derived class of the static type of the object used to make the; call. The checks are currently only introduced where the object is of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:12204,Performance,perform,performance,12204,"ger types (e.g.,; i8, i16, i32, ..., in Rust). ``-fsanitize-cfi-icall-experimental-normalize-integers`` is compatible with; ``-fsanitize-cfi-icall-generalize-pointers``. This option is currently experimental. .. _cfi-canonical-jump-tables:. ``-fsanitize-cfi-canonical-jump-tables``; ----------------------------------------. The default behavior of Clang's indirect function call checker will replace; the address of each CFI-checked function in the output file's symbol table; with the address of a jump table entry which will pass CFI checks. We refer; to this as making the jump table `canonical`. This property allows code that; was not compiled with ``-fsanitize=cfi-icall`` to take a CFI-valid address; of a function, but it comes with a couple of caveats that are especially; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:18463,Performance,perform,performed,18463,"o=thin``; enabled and be statically linked into the program. This scheme is currently not compatible with cross-DSO CFI or the; Microsoft ABI. .. _cfi-ignorelist:. Ignorelist; ==========. A :doc:`SanitizerSpecialCaseList` can be used to relax CFI checks for certain; source files, functions and types using the ``src``, ``fun`` and ``type``; entity types. Specific CFI modes can be be specified using ``[section]``; headers. .. code-block:: bash. # Suppress all CFI checking for code in a file.; src:bad_file.cpp; src:bad_header.h; # Ignore all functions with names containing MyFooBar.; fun:*MyFooBar*; # Ignore all types in the standard library.; type:std::*; # Disable only unrelated cast checks for this function; [cfi-unrelated-cast]; fun:*UnrelatedCast*; # Disable CFI call checks for this function without affecting cast checks; [cfi-vcall|cfi-nvcall|cfi-icall]; fun:*BadCall*. .. _cfi-cross-dso:. Shared library support; ======================. Use **-f[no-]sanitize-cfi-cross-dso** to enable the cross-DSO control; flow integrity mode, which allows all CFI schemes listed above to; apply across DSO boundaries. As in the regular CFI, each DSO must be; built with ``-flto`` or ``-flto=thin``. Normally, CFI checks will only be performed for classes that have hidden LTO; visibility. With this flag enabled, the compiler will emit cross-DSO CFI; checks for all classes, except for those which appear in the CFI ignorelist; or which use a ``no_sanitize`` attribute. Design; ======. Please refer to the :doc:`design document<ControlFlowIntegrityDesign>`. Publications; ============. `Control-Flow Integrity: Principles, Implementations, and Applications <https://research.microsoft.com/pubs/64250/ccs05.pdf>`_.; Martin Abadi, Mihai Budiu, Úlfar Erlingsson, Jay Ligatti. `Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM <http://www.pcc.me.uk/~peter/acad/usenix14.pdf>`_.; Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway,; Úlfar Erlingsson, Luis Lozano, Geoff Pike.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:285,Safety,abort,abort,285,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:308,Safety,detect,detecting,308,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3304,Safety,abort,abort,3304,"-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3339,Safety,detect,detecting,3339,"-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3545,Safety,abort,aborts,3545,"n object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3965,Safety,abort,aborting,3965,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4004,Safety,recover,recover,4004,"uild your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Anot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:237,Security,integrity,integrity,237,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:382,Security,attack,attackers,382,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:1845,Security,integrity,integrity,1845,"ld plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:2873,Security,sanitiz,sanitize,2873,"-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3004,Security,sanitiz,sanitize,3004,"ocs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3365,Security,integrity,integrity,3365,"-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3413,Security,sanitiz,sanitize-trap,3413,"n object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3626,Security,integrity,integrity,3626,"`: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5550,Security,integrity,integrity,5550,"relist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` membe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5598,Security,secur,security,5598,"relist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` membe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:8527,Security,secur,security,8527," of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-nvcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. .. _cfi-strictness:. Strictness; ----------. If a class has a single non-virtual base and does not introduce or override; virtual member functions or fields other than an implicitly defined virtual; destructor, it will have the same layout and virtual function semantics as; its base. By default, casts to such classes are checked as if they were made; to the least derived such class. Casting an instance of a base class to such a derived class is technically; undefined behavior, but it is a relatively common hack for introducing; member functions on class instances with specific properties that works under; most compilers and should not have security implications, so we allow it by; default. It can be disabled with ``-fsanitize=cfi-cast-strict``. Indirect Function Call Checking; ===============================. This scheme checks that function calls take place using a function of the; correct dynamic type; that is, the dynamic type of the function must match; the static type used at the call. This CFI scheme can be enabled on its own; using ``-fsanitize=cfi-icall``. For this scheme to work, each indirect function call in the program, other; than calls in :ref:`ignored <cfi-ignorelist>` functions, must call a; function which was either compiled with ``-fsanitize=cfi-icall`` enabled,; or whose address was taken by a function in a translation unit compiled with; ``-fsanitize=cfi-icall``. If a function in a translation unit compiled with ``-fsanitize=cfi-icall``; takes the address of a function not compiled with ``-fsaniti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13358,Security,sanitiz,sanitize-cfi-canonical-jump-tables,13358,"iated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:14757,Security,secur,security,14757,"quality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will pass CFI checks. ``-fsanitize=cfi-icall`` and ``-fsanitize=function``; ----------------------------------------------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function addr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:15415,Security,integrity,integrity,15415,"-------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function address equality. These properties make KCFI easier to; adopt in low-level software. KCFI is limited to checking only function; pointers, and isn't compatible with executable-only memory. Member Function Pointer Call Checking; =====================================. This scheme checks that indirect calls via a member function pointer; take place using an object of the correct dynamic type. Specifically, we; check that the dynamic type of the member function referenced by the member; function pointer matches the ""function pointer"" part of the member function; pointer, and that the member function's class type is related to the base; type of the member function. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-mfcall``. The c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:18194,Security,sanitiz,sanitize-cfi-cross-dso,18194,"o=thin``; enabled and be statically linked into the program. This scheme is currently not compatible with cross-DSO CFI or the; Microsoft ABI. .. _cfi-ignorelist:. Ignorelist; ==========. A :doc:`SanitizerSpecialCaseList` can be used to relax CFI checks for certain; source files, functions and types using the ``src``, ``fun`` and ``type``; entity types. Specific CFI modes can be be specified using ``[section]``; headers. .. code-block:: bash. # Suppress all CFI checking for code in a file.; src:bad_file.cpp; src:bad_header.h; # Ignore all functions with names containing MyFooBar.; fun:*MyFooBar*; # Ignore all types in the standard library.; type:std::*; # Disable only unrelated cast checks for this function; [cfi-unrelated-cast]; fun:*UnrelatedCast*; # Disable CFI call checks for this function without affecting cast checks; [cfi-vcall|cfi-nvcall|cfi-icall]; fun:*BadCall*. .. _cfi-cross-dso:. Shared library support; ======================. Use **-f[no-]sanitize-cfi-cross-dso** to enable the cross-DSO control; flow integrity mode, which allows all CFI schemes listed above to; apply across DSO boundaries. As in the regular CFI, each DSO must be; built with ``-flto`` or ``-flto=thin``. Normally, CFI checks will only be performed for classes that have hidden LTO; visibility. With this flag enabled, the compiler will emit cross-DSO CFI; checks for all classes, except for those which appear in the CFI ignorelist; or which use a ``no_sanitize`` attribute. Design; ======. Please refer to the :doc:`design document<ControlFlowIntegrityDesign>`. Publications; ============. `Control-Flow Integrity: Principles, Implementations, and Applications <https://research.microsoft.com/pubs/64250/ccs05.pdf>`_.; Martin Abadi, Mihai Budiu, Úlfar Erlingsson, Jay Ligatti. `Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM <http://www.pcc.me.uk/~peter/acad/usenix14.pdf>`_.; Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway,; Úlfar Erlingsson, Luis Lozano, Geoff Pike.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:18257,Security,integrity,integrity,18257,"o=thin``; enabled and be statically linked into the program. This scheme is currently not compatible with cross-DSO CFI or the; Microsoft ABI. .. _cfi-ignorelist:. Ignorelist; ==========. A :doc:`SanitizerSpecialCaseList` can be used to relax CFI checks for certain; source files, functions and types using the ``src``, ``fun`` and ``type``; entity types. Specific CFI modes can be be specified using ``[section]``; headers. .. code-block:: bash. # Suppress all CFI checking for code in a file.; src:bad_file.cpp; src:bad_header.h; # Ignore all functions with names containing MyFooBar.; fun:*MyFooBar*; # Ignore all types in the standard library.; type:std::*; # Disable only unrelated cast checks for this function; [cfi-unrelated-cast]; fun:*UnrelatedCast*; # Disable CFI call checks for this function without affecting cast checks; [cfi-vcall|cfi-nvcall|cfi-icall]; fun:*BadCall*. .. _cfi-cross-dso:. Shared library support; ======================. Use **-f[no-]sanitize-cfi-cross-dso** to enable the cross-DSO control; flow integrity mode, which allows all CFI schemes listed above to; apply across DSO boundaries. As in the regular CFI, each DSO must be; built with ``-flto`` or ``-flto=thin``. Normally, CFI checks will only be performed for classes that have hidden LTO; visibility. With this flag enabled, the compiler will emit cross-DSO CFI; checks for all classes, except for those which appear in the CFI ignorelist; or which use a ``no_sanitize`` attribute. Design; ======. Please refer to the :doc:`design document<ControlFlowIntegrityDesign>`. Publications; ============. `Control-Flow Integrity: Principles, Implementations, and Applications <https://research.microsoft.com/pubs/64250/ccs05.pdf>`_.; Martin Abadi, Mihai Budiu, Úlfar Erlingsson, Jay Ligatti. `Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM <http://www.pcc.me.uk/~peter/acad/usenix14.pdf>`_.; Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway,; Úlfar Erlingsson, Luis Lozano, Geoff Pike.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4877,Testability,benchmark,benchmark,4877,"gnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:4980,Testability,benchmark,benchmark,4980,"ecover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference betwe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:1801,Availability,mask,mask,1801,"2();; virtual void f3();; };. struct B : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. struct C : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. The scheme will cause the virtual tables for A, B and C to be laid out; consecutively:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A::offset-to-top, &A::rtti, &A::f1, &A::f2, &A::f3, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, C::offset-to-top, &C::rtti, &C::f1, &C::f2, &C::f3. The bit vector for static types A, B and C will look like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0; B, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0; C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0. Bit vectors are represented in the object file as byte arrays. By loading; from indexed offsets into the byte array and applying a mask, a program can; test bits from the bit set with a relatively short instruction sequence. Bit; vectors may overlap so long as they use different bits. For the full details,; see the `ByteArrayBuilder`_ class. In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in; bit 1 and C at offset 0 in bit 2, the byte array would look like this:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9390,Availability,redundant,redundant,9390,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21220,Availability,error,error,21220,"etail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrume",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21354,Availability,recover,recover,21354," the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21393,Availability,error,error,21393," the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21510,Availability,error,error,21510,"an; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrumented DSO, a shadow value encodes the address of the; __cfi_check function for all call targets in the corresponding memory; page. If Addr is the target ad",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:29763,Availability,failure,failure,29763,"ould check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSize' is a ~20-bit constant.; // 'kRangeBeg' is a PC-relative constant (~28 bits); // pointing to the beginning of the allowed range for 'Ptr'.; // 'kFailedCheckTarget': is a PC-relative constant (~28 bits); // representing the target to branch to when the check fails.; // If kFailedCheckTarget==0, the process will trap; // (monolithic binary scheme).; // Otherwise it will jump to a handler that implements `CFI_SlowPath`; // (cross-DSO scheme).; CFI_Check(Ptr, kAlignment, kRangeSize, kRangeBeg, kFailedCheckTarget) {; if (Ptr < kRangeBeg ||; Ptr >= kRangeBeg + (kRangeSize << kAlignment) ||; Ptr & ((1 << kAlignment) - 1)); Jump(kFailedCheckTarget);; }. An alternative and more compact encoding would not use `kFailedCheckTarget`,; and will trap on check failure instead.; This will allow us to fit the instruction into **8-9 bytes**.; The cross-DSO checks will be performed by a trap handler and; performance-critical ones will have to be black-listed and checked using the; software-only scheme. Note that such hardware extension would be complementary to checks; at the callee side, such as e.g. **Intel ENDBRANCH**.; Moreover, CFI would have two benefits over ENDBRANCH: a) precision and b); ability to protect against invalid casts between polymorphic types.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:27743,Deployability,release,release-new-technology-specifications-protect-rop-attacks,27743,"p table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:6817,Energy Efficiency,efficient,efficiently,6817,"3 25 jae 11f5 <main+0xb5>; 11d0: 48 89 df mov %rbx,%rdi; 11d3: ff 10 callq *(%rax); [...]; 11f5: 0f 0b ud2. If the bit vector consists of a single bit, there is only one possible; virtual table, and the check can consist of a single equality comparison:. .. code-block:: none. 9a2: 48 8b 03 mov (%rbx),%rax; 9a5: 48 8d 0d a4 13 00 00 lea 0x13a4(%rip),%rcx; 9ac: 48 39 c8 cmp %rcx,%rax; 9af: 75 25 jne 9d6 <main+0x86>; 9b1: 48 89 df mov %rbx,%rdi; 9b4: ff 10 callq *(%rax); [...]; 9d6: 0f 0b ud2. Virtual Table Layout; ~~~~~~~~~~~~~~~~~~~~. The compiler lays out classes of disjoint hierarchies in separate regions; of the object file. At worst, bit vectors in disjoint hierarchies only; need to cover their disjoint hierarchy. But the closer that classes in; sub-hierarchies are laid out to each other, the smaller the bit vectors for; those sub-hierarchies need to be (see ""Stripping Leading/Trailing Zeros in Bit; Vectors"" above). The `GlobalLayoutBuilder`_ class is responsible for laying; out the globals efficiently to minimize the sizes of the underlying bitsets. .. _GlobalLayoutBuilder: https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h. Alignment; ~~~~~~~~~. If all gaps between address points in a particular bit vector are multiples; of powers of 2, the compiler can compress the bit vector by strengthening; the alignment requirements of the virtual table pointer. For example, given; this class hierarchy:. .. code-block:: c++. struct A {; virtual void f1();; virtual void f2();; };. struct B : A {; virtual void f1();; virtual void f2();; virtual void f3();; virtual void f4();; virtual void f5();; virtual void f6();; };. struct C : A {; virtual void f1();; virtual void f2();; };. The virtual tables will be laid out like this:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. A::offset-to-top, &A::rtti, &A::f1, &A::f2, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, &",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:7103,Energy Efficiency,power,powers,7103," 0d a4 13 00 00 lea 0x13a4(%rip),%rcx; 9ac: 48 39 c8 cmp %rcx,%rax; 9af: 75 25 jne 9d6 <main+0x86>; 9b1: 48 89 df mov %rbx,%rdi; 9b4: ff 10 callq *(%rax); [...]; 9d6: 0f 0b ud2. Virtual Table Layout; ~~~~~~~~~~~~~~~~~~~~. The compiler lays out classes of disjoint hierarchies in separate regions; of the object file. At worst, bit vectors in disjoint hierarchies only; need to cover their disjoint hierarchy. But the closer that classes in; sub-hierarchies are laid out to each other, the smaller the bit vectors for; those sub-hierarchies need to be (see ""Stripping Leading/Trailing Zeros in Bit; Vectors"" above). The `GlobalLayoutBuilder`_ class is responsible for laying; out the globals efficiently to minimize the sizes of the underlying bitsets. .. _GlobalLayoutBuilder: https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h. Alignment; ~~~~~~~~~. If all gaps between address points in a particular bit vector are multiples; of powers of 2, the compiler can compress the bit vector by strengthening; the alignment requirements of the virtual table pointer. For example, given; this class hierarchy:. .. code-block:: c++. struct A {; virtual void f1();; virtual void f2();; };. struct B : A {; virtual void f1();; virtual void f2();; virtual void f3();; virtual void f4();; virtual void f5();; virtual void f6();; };. struct C : A {; virtual void f1();; virtual void f2();; };. The virtual tables will be laid out like this:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. A::offset-to-top, &A::rtti, &A::f1, &A::f2, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, &B::f4, &B::f5, &B::f6, C::offset-to-top, &C::rtti, &C::f1, &C::f2. Notice that each address point for A is separated by 4 words. This lets us; emit a compressed bit vector for A that looks like this:. .. csv-table::; :header: 2, 6, 10, 14. 1, 1, 0, 1. At call sites, the compiler will strengthen the alignment requirem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:8646,Energy Efficiency,power,power,8646,"like this:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. A::offset-to-top, &A::rtti, &A::f1, &A::f2, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, &B::f4, &B::f5, &B::f6, C::offset-to-top, &C::rtti, &C::f1, &C::f2. Notice that each address point for A is separated by 4 words. This lets us; emit a compressed bit vector for A that looks like this:. .. csv-table::; :header: 2, 6, 10, 14. 1, 1, 0, 1. At call sites, the compiler will strengthen the alignment requirements by; using a different rotate count. For example, on a 64-bit machine where the; address points are 4-word aligned (as in A from our example), the ``rol``; instruction may look like this:. .. code-block:: none. dd2: 48 c1 c1 3b rol $0x3b,%rcx. Padding to Powers of 2; ~~~~~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving V",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:8727,Energy Efficiency,power,power,8727,", &B::f2, &B::f3, &B::f4, &B::f5, &B::f6, C::offset-to-top, &C::rtti, &C::f1, &C::f2. Notice that each address point for A is separated by 4 words. This lets us; emit a compressed bit vector for A that looks like this:. .. csv-table::; :header: 2, 6, 10, 14. 1, 1, 0, 1. At call sites, the compiler will strengthen the alignment requirements by; using a different rotate count. For example, on a 64-bit machine where the; address points are 4-word aligned (as in A from our example), the ``rol``; instruction may look like this:. .. code-block:: none. dd2: 48 c1 c1 3b rol $0x3b,%rcx. Padding to Powers of 2; ~~~~~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9777,Energy Efficiency,efficient,efficient,9777,"ppear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtua",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9894,Energy Efficiency,efficient,efficient,9894,"pace overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtual tables for a class into a combined virtual table (virtual table group).; The interleaving scheme, however, can only work with individual virtual tables so it must split",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:11089,Energy Efficiency,efficient,efficient,11089," a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtual tables for a class into a combined virtual table (virtual table group).; The interleaving scheme, however, can only work with individual virtual tables so it must split the combined virtual tables first.; In comparison, the old scheme does not require the splitting but it is more efficient when the combined virtual tables have been split.; The `GlobalSplit`_ pass is responsible for splitting combined virtual tables into individual ones. .. _GlobalSplit: https://github.com/llvm/llvm-project/blob/main/llvm/lib/Transforms/IPO/GlobalSplit.cpp. Order virtual tables by a pre-order traversal of the class hierarchy; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This step is common to both the old scheme described above and the interleaving scheme.; For the interleaving scheme, since the combined virtual tables have been split in the previous step,; this step ensures that for any class all the compatible virtual tables will appear consecutively.; For the old scheme, the same property may not hold since it may work on combined virtual tables. For example, consider the following four C++ classes:. .. code-block:: c++. struct A {; virtual void f1();; };. struct B : A {; virtual void f1();; virtual void f2();; };. struct C : A {; virtual voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18329,Energy Efficiency,power,power,18329,"table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance pen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:27878,Energy Efficiency,efficient,efficiently,27878,"ns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function whic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:28086,Energy Efficiency,efficient,efficiently,28086,"table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSiz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:16949,Integrability,depend,depend,16949,"e second property, let us look at f2 as an example. In the interleaved layout,; there are two entries for f2: B::f2 and D::f2. The distance between &B::f2; and its address point D::offset-to-top (the entry immediately after &B::rtti) is 5 entry-length, so is the distance between &D::f2 and C::offset-to-top (the entry immediately after &D::rtti). Forward-Edge CFI for Indirect Function Calls; ============================================. Under forward-edge CFI for indirect function calls, each unique function; type has its own bit vector, and at each call site we need to check that the; function pointer is a member of the function type's bit vector. This scheme; works in a similar way to forward-edge CFI for virtual calls, the distinction; being that we need to build bit vectors of function entry points rather than; of virtual tables. Unlike when re-arranging global variables, we cannot re-arrange functions; in a particular order and base our calculations on the layout of the; functions' entry points, as we have no idea how large a particular function; will end up being (the function sizes could even depend on how we arrange; the functions). Instead, we build a jump table, which is a block of code; consisting of one branch instruction for each of the functions in the bit; set that branches to the target function, and redirect any taken function; addresses to the corresponding jump table entry. In this way, the distance; between function entry points is predictable and controllable. In the object; file's symbol table, the symbols for the target functions also refer to the; jump table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21792,Integrability,rout,route,21792,"plements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrumented DSO, a shadow value encodes the address of the; __cfi_check function for all call targets in the corresponding memory; page. If Addr is the target address, and V is the shadow value, then; the address of __cfi_check is calculated as. .. code-block:: none. __cfi_check = AlignUpTo(Addr, 4096) - (V + 1) * 4096. This works as long as __cfi_check is aligned by 4096 bytes and located; below any call targets in its DSO, but not more than 256MB apart from; them. CFI_SlowPath; ------------. The slow path check is implemente",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:10410,Modifiability,enhance,enhancements,10410,"dant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtual tables for a class into a combined virtual table (virtual table group).; The interleaving scheme, however, can only work with individual virtual tables so it must split the combined virtual tables first.; In comparison, the old scheme does not require the splitting but it is more efficient when the combined virtual tables have been split.; The `GlobalSplit`_ pass is responsible for splitting combined virtual tables into individual ones. .. _GlobalSplit: https://github.com/llvm/llvm-project/blob/main/llvm/lib/Transforms/IPO/GlobalSplit.cpp. Order virtual tables by a pre-order trave",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:16710,Modifiability,variab,variables,16710,"e second property, let us look at f2 as an example. In the interleaved layout,; there are two entries for f2: B::f2 and D::f2. The distance between &B::f2; and its address point D::offset-to-top (the entry immediately after &B::rtti) is 5 entry-length, so is the distance between &D::f2 and C::offset-to-top (the entry immediately after &D::rtti). Forward-Edge CFI for Indirect Function Calls; ============================================. Under forward-edge CFI for indirect function calls, each unique function; type has its own bit vector, and at each call site we need to check that the; function pointer is a member of the function type's bit vector. This scheme; works in a similar way to forward-edge CFI for virtual calls, the distinction; being that we need to build bit vectors of function entry points rather than; of virtual tables. Unlike when re-arranging global variables, we cannot re-arrange functions; in a particular order and base our calculations on the layout of the; functions' entry points, as we have no idea how large a particular function; will end up being (the function sizes could even depend on how we arrange; the functions). Instead, we build a jump table, which is a block of code; consisting of one branch instruction for each of the functions in the bit; set that branches to the target function, and redirect any taken function; addresses to the corresponding jump table entry. In this way, the distance; between function entry points is predictable and controllable. In the object; file's symbol table, the symbols for the target functions also refer to the; jump table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25864,Modifiability,extend,extend,25864,"P` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-preci",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:30253,Modifiability,polymorphi,polymorphic,30253,"ould check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSize' is a ~20-bit constant.; // 'kRangeBeg' is a PC-relative constant (~28 bits); // pointing to the beginning of the allowed range for 'Ptr'.; // 'kFailedCheckTarget': is a PC-relative constant (~28 bits); // representing the target to branch to when the check fails.; // If kFailedCheckTarget==0, the process will trap; // (monolithic binary scheme).; // Otherwise it will jump to a handler that implements `CFI_SlowPath`; // (cross-DSO scheme).; CFI_Check(Ptr, kAlignment, kRangeSize, kRangeBeg, kFailedCheckTarget) {; if (Ptr < kRangeBeg ||; Ptr >= kRangeBeg + (kRangeSize << kAlignment) ||; Ptr & ((1 << kAlignment) - 1)); Jump(kFailedCheckTarget);; }. An alternative and more compact encoding would not use `kFailedCheckTarget`,; and will trap on check failure instead.; This will allow us to fit the instruction into **8-9 bytes**.; The cross-DSO checks will be performed by a trap handler and; performance-critical ones will have to be black-listed and checked using the; software-only scheme. Note that such hardware extension would be complementary to checks; at the callee side, such as e.g. **Intel ENDBRANCH**.; Moreover, CFI would have two benefits over ENDBRANCH: a) precision and b); ability to protect against invalid casts between polymorphic types.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:1736,Performance,load,loading,1736,"2();; virtual void f3();; };. struct B : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. struct C : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. The scheme will cause the virtual tables for A, B and C to be laid out; consecutively:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A::offset-to-top, &A::rtti, &A::f1, &A::f2, &A::f3, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, C::offset-to-top, &C::rtti, &C::f1, &C::f2, &C::f3. The bit vector for static types A, B and C will look like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0; B, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0; C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0. Bit vectors are represented in the object file as byte arrays. By loading; from indexed offsets into the byte array and applying a mask, a program can; test bits from the bit set with a relatively short instruction sequence. Bit; vectors may overlap so long as they use different bits. For the full details,; see the `ByteArrayBuilder`_ class. In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in; bit 1 and C at offset 0 in bit 2, the byte array would look like this:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:3197,Performance,optimiz,optimization,3197,"s:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 06 lea 0x6f70bc0(%rip),%rdx; ca7fe2: f6 04 10 10 testb $0x10,(%rax,%rdx,1); ca7fe6: 0f 84 25 05 00 00 je ca8511; ca7fec: ff 91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of the; compiler, you will probably find that it will not use the described virtual; table layout or machine instructions. Some of the optimizations we are about; to introduce cause the compiler to use a different layout or a different; sequence of machine instructions. Stripping Leading/Trailing Zeros in Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If a bit vector contains leading or trailing zeros",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:3624,Performance,optimiz,optimizations,3624,"8 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 06 lea 0x6f70bc0(%rip),%rdx; ca7fe2: f6 04 10 10 testb $0x10,(%rax,%rdx,1); ca7fe6: 0f 84 25 05 00 00 je ca8511; ca7fec: ff 91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of the; compiler, you will probably find that it will not use the described virtual; table layout or machine instructions. Some of the optimizations we are about; to introduce cause the compiler to use a different layout or a different; sequence of machine instructions. Stripping Leading/Trailing Zeros in Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If a bit vector contains leading or trailing zeros, we can strip them from; the vector. The compiler will emit code to check if the pointer is in range; of the region covered by ones, and perform the bit vector check using a; truncated version of the bit vector. For example, the bit vectors for our; example class hierarchy will be emitted like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, , , 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ,; B, ,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:3664,Performance,perform,performance,3664,"8 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 06 lea 0x6f70bc0(%rip),%rdx; ca7fe2: f6 04 10 10 testb $0x10,(%rax,%rdx,1); ca7fe6: 0f 84 25 05 00 00 je ca8511; ca7fec: ff 91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of the; compiler, you will probably find that it will not use the described virtual; table layout or machine instructions. Some of the optimizations we are about; to introduce cause the compiler to use a different layout or a different; sequence of machine instructions. Stripping Leading/Trailing Zeros in Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If a bit vector contains leading or trailing zeros, we can strip them from; the vector. The compiler will emit code to check if the pointer is in range; of the region covered by ones, and perform the bit vector check using a; truncated version of the bit vector. For example, the bit vectors for our; example class hierarchy will be emitted like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, , , 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ,; B, ,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:3875,Performance,optimiz,optimizations,3875,"91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of the; compiler, you will probably find that it will not use the described virtual; table layout or machine instructions. Some of the optimizations we are about; to introduce cause the compiler to use a different layout or a different; sequence of machine instructions. Stripping Leading/Trailing Zeros in Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If a bit vector contains leading or trailing zeros, we can strip them from; the vector. The compiler will emit code to check if the pointer is in range; of the region covered by ones, and perform the bit vector check using a; truncated version of the bit vector. For example, the bit vectors for our; example class hierarchy will be emitted like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, , , 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ,; B, , , , , , , , 1, , , , , , ,; C, , , , , , , , , , , , , 1, ,. Short Inline Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~. If the vector is sufficiently short, we can represent it as an inline constant; on x86. This saves us a few instructions when reading the correct element; of the bit vector. If the bit vector fits in 32 bits",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:4297,Performance,perform,perform,4297,"able-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of the; compiler, you will probably find that it will not use the described virtual; table layout or machine instructions. Some of the optimizations we are about; to introduce cause the compiler to use a different layout or a different; sequence of machine instructions. Stripping Leading/Trailing Zeros in Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If a bit vector contains leading or trailing zeros, we can strip them from; the vector. The compiler will emit code to check if the pointer is in range; of the region covered by ones, and perform the bit vector check using a; truncated version of the bit vector. For example, the bit vectors for our; example class hierarchy will be emitted like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, , , 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ,; B, , , , , , , , 1, , , , , , ,; C, , , , , , , , , , , , , 1, ,. Short Inline Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~. If the vector is sufficiently short, we can represent it as an inline constant; on x86. This saves us a few instructions when reading the correct element; of the bit vector. If the bit vector fits in 32 bits, the code looks like this:. .. code-block:: none. dc2: 48 8b 03 mov (%rbx),%rax; dc5: 48 8d 15 14 1e 00 00 lea 0x1e14(%rip),%rdx; dcc: 48 89 c1 mov %rax,%rcx; dcf: 48 29 d1 sub %rdx,%rcx; dd2: 48 c1 c1 3d rol $0x3d,%rcx; dd6: 48 83 f9 03 cmp $0x3,%rcx; dda: 77 2f ja e0b <main+0x9b>; ddc: ba 09 00 00 00 mov $0x9,%edx; de1: 0f a3 ca bt %ecx,%edx; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9916,Performance,perform,performance,9916,"pace overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtual tables for a class into a combined virtual table (virtual table group).; The interleaving scheme, however, can only work with individual virtual tables so it must split",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18519,Performance,optimiz,optimizations,18519,"table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance pen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19420,Performance,perform,performance,19420," we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19581,Performance,perform,performance,19581,"ifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21134,Performance,perform,performs,21134,"; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:23095,Performance,load,loads,23095,"dow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrumented DSO, a shadow value encodes the address of the; __cfi_check function for all call targets in the corresponding memory; page. If Addr is the target address, and V is the shadow value, then; the address of __cfi_check is calculated as. .. code-block:: none. __cfi_check = AlignUpTo(Addr, 4096) - (V + 1) * 4096. This works as long as __cfi_check is aligned by 4096 bytes and located; below any call targets in its DSO, but not more than 256MB apart from; them. CFI_SlowPath; ------------. The slow path check is implemented in a runtime support library as. .. code-block:: none. void __cfi_slowpath(uint64 CallSiteTypeId, void *TargetAddr); void __cfi_slowpath_diag(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). These functions loads a shadow value for ``TargetAddr``, finds the; address of ``__cfi_check`` as described above and calls; that. ``DiagData`` is an opaque pointer to diagnostic data which is; passed verbatim to ``__cfi_check``, and ``__cfi_slowpath`` passes; ``nullptr`` instead. Compiler-RT library contains reference implementations of slowpath; functions, but they have unresolvable issues with correctness and; performance in the handling of dlopen(). It is recommended that; platforms provide their own implementations, usually as part of libc; or libdl. Position-independent executable requirement; -------------------------------------------. Cross-DSO CFI mode requires that the main executable is built as PIE.; In non-PIE executables the address of an external function (taken from; the main executable) is the address of that function’s PLT record in; the main executable. This would break the CFI checks. Backward-edge CFI for return statements (RCFI); ==============================================. This section is a proposal. As of March 2017 it is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:23496,Performance,perform,performance,23496,"n the corresponding memory; page. If Addr is the target address, and V is the shadow value, then; the address of __cfi_check is calculated as. .. code-block:: none. __cfi_check = AlignUpTo(Addr, 4096) - (V + 1) * 4096. This works as long as __cfi_check is aligned by 4096 bytes and located; below any call targets in its DSO, but not more than 256MB apart from; them. CFI_SlowPath; ------------. The slow path check is implemented in a runtime support library as. .. code-block:: none. void __cfi_slowpath(uint64 CallSiteTypeId, void *TargetAddr); void __cfi_slowpath_diag(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). These functions loads a shadow value for ``TargetAddr``, finds the; address of ``__cfi_check`` as described above and calls; that. ``DiagData`` is an opaque pointer to diagnostic data which is; passed verbatim to ``__cfi_check``, and ``__cfi_slowpath`` passes; ``nullptr`` instead. Compiler-RT library contains reference implementations of slowpath; functions, but they have unresolvable issues with correctness and; performance in the handling of dlopen(). It is recommended that; platforms provide their own implementations, usually as part of libc; or libdl. Position-independent executable requirement; -------------------------------------------. Cross-DSO CFI mode requires that the main executable is built as PIE.; In non-PIE executables the address of an external function (taken from; the main executable) is the address of that function’s PLT record in; the main executable. This would break the CFI checks. Backward-edge CFI for return statements (RCFI); ==============================================. This section is a proposal. As of March 2017 it is not implemented. Backward-edge control flow (`RET` instructions) can be hijacked; via overwriting the return address (`RA`) on stack.; Various mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_); try to detect or prevent `RA` corruption on stack. RCFI enforces the expected control flow in s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:26740,Performance,load,load,26740,"ons called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technolo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:27972,Performance,perform,perform,27972,"table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSiz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:29873,Performance,perform,performed,29873,"ould check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSize' is a ~20-bit constant.; // 'kRangeBeg' is a PC-relative constant (~28 bits); // pointing to the beginning of the allowed range for 'Ptr'.; // 'kFailedCheckTarget': is a PC-relative constant (~28 bits); // representing the target to branch to when the check fails.; // If kFailedCheckTarget==0, the process will trap; // (monolithic binary scheme).; // Otherwise it will jump to a handler that implements `CFI_SlowPath`; // (cross-DSO scheme).; CFI_Check(Ptr, kAlignment, kRangeSize, kRangeBeg, kFailedCheckTarget) {; if (Ptr < kRangeBeg ||; Ptr >= kRangeBeg + (kRangeSize << kAlignment) ||; Ptr & ((1 << kAlignment) - 1)); Jump(kFailedCheckTarget);; }. An alternative and more compact encoding would not use `kFailedCheckTarget`,; and will trap on check failure instead.; This will allow us to fit the instruction into **8-9 bytes**.; The cross-DSO checks will be performed by a trap handler and; performance-critical ones will have to be black-listed and checked using the; software-only scheme. Note that such hardware extension would be complementary to checks; at the callee side, such as e.g. **Intel ENDBRANCH**.; Moreover, CFI would have two benefits over ENDBRANCH: a) precision and b); ability to protect against invalid casts between polymorphic types.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:29906,Performance,perform,performance-critical,29906,"ould check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the given target (slow path).; //; // 'Ptr' is a register, pointing to the virtual function table; // or to the function which we need to check. We may require an explicit; // fixed register to be used.; // 'kAlignment' is a 4-bit constant.; // 'kRangeSize' is a ~20-bit constant.; // 'kRangeBeg' is a PC-relative constant (~28 bits); // pointing to the beginning of the allowed range for 'Ptr'.; // 'kFailedCheckTarget': is a PC-relative constant (~28 bits); // representing the target to branch to when the check fails.; // If kFailedCheckTarget==0, the process will trap; // (monolithic binary scheme).; // Otherwise it will jump to a handler that implements `CFI_SlowPath`; // (cross-DSO scheme).; CFI_Check(Ptr, kAlignment, kRangeSize, kRangeBeg, kFailedCheckTarget) {; if (Ptr < kRangeBeg ||; Ptr >= kRangeBeg + (kRangeSize << kAlignment) ||; Ptr & ((1 << kAlignment) - 1)); Jump(kFailedCheckTarget);; }. An alternative and more compact encoding would not use `kFailedCheckTarget`,; and will trap on check failure instead.; This will allow us to fit the instruction into **8-9 bytes**.; The cross-DSO checks will be performed by a trap handler and; performance-critical ones will have to be black-listed and checked using the; software-only scheme. Note that such hardware extension would be complementary to checks; at the callee side, such as e.g. **Intel ENDBRANCH**.; Moreover, CFI would have two benefits over ENDBRANCH: a) precision and b); ability to protect against invalid casts between polymorphic types.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9390,Safety,redund,redundant,9390,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:17308,Safety,predict,predictable,17308,"CFI for indirect function calls, each unique function; type has its own bit vector, and at each call site we need to check that the; function pointer is a member of the function type's bit vector. This scheme; works in a similar way to forward-edge CFI for virtual calls, the distinction; being that we need to build bit vectors of function entry points rather than; of virtual tables. Unlike when re-arranging global variables, we cannot re-arrange functions; in a particular order and base our calculations on the layout of the; functions' entry points, as we have no idea how large a particular function; will end up being (the function sizes could even depend on how we arrange; the functions). Instead, we build a jump table, which is a block of code; consisting of one branch instruction for each of the functions in the bit; set that branches to the target function, and redirect any taken function; addresses to the corresponding jump table entry. In this way, the distance; between function entry points is predictable and controllable. In the object; file's symbol table, the symbols for the target functions also refer to the; jump table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19666,Safety,detect,detected,19666,"==========. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that wo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:19800,Safety,abort,abort,19800,"rtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21354,Safety,recover,recover,21354," the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21400,Safety,abort,abort,21400," the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:24360,Safety,detect,detect,24360,". Compiler-RT library contains reference implementations of slowpath; functions, but they have unresolvable issues with correctness and; performance in the handling of dlopen(). It is recommended that; platforms provide their own implementations, usually as part of libc; or libdl. Position-independent executable requirement; -------------------------------------------. Cross-DSO CFI mode requires that the main executable is built as PIE.; In non-PIE executables the address of an external function (taken from; the main executable) is the address of that function’s PLT record in; the main executable. This would break the CFI checks. Backward-edge CFI for return statements (RCFI); ==============================================. This section is a proposal. As of March 2017 it is not implemented. Backward-edge control flow (`RET` instructions) can be hijacked; via overwriting the return address (`RA`) on stack.; Various mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_); try to detect or prevent `RA` corruption on stack. RCFI enforces the expected control flow in several different ways described below.; RCFI heavily relies on LTO. Leaf Functions; --------------; If `f()` is a leaf function (i.e. it has no calls; except maybe no-return calls) it can be called using a special calling convention; that stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25687,Safety,abort,abort,25687,"t stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spill",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:26177,Safety,abort,abort,26177,"ment (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18922,Security,sanitiz,sanitize-cfi-cross-dso,18922,"int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTy",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:20415,Security,hash,hash,20415,"performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:20485,Security,hash,hash,20485,").; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnost",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:20599,Security,hash,hashing,20599," Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21029,Security,access,access,21029,"er of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for ever",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:27793,Security,attack,attacks,27793,"p table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:1822,Testability,test,test,1822,"2();; virtual void f3();; };. struct B : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. struct C : A {; virtual void f1();; virtual void f2();; virtual void f3();; };. The scheme will cause the virtual tables for A, B and C to be laid out; consecutively:. .. csv-table:: Virtual Table Layout for A, B, C; :header: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A::offset-to-top, &A::rtti, &A::f1, &A::f2, &A::f3, B::offset-to-top, &B::rtti, &B::f1, &B::f2, &B::f3, C::offset-to-top, &C::rtti, &C::f1, &C::f2, &C::f3. The bit vector for static types A, B and C will look like this:. .. csv-table:: Bit Vectors for A, B, C; :header: Class, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. A, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0; B, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0; C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0. Bit vectors are represented in the object file as byte arrays. By loading; from indexed offsets into the byte array and applying a mask, a program can; test bits from the bit set with a relatively short instruction sequence. Bit; vectors may overlap so long as they use different bits. For the full details,; see the `ByteArrayBuilder`_ class. In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in; bit 1 and C at offset 0 in bit 2, the byte array would look like this:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:2861,Testability,test,testb,2861," from indexed offsets into the byte array and applying a mask, a program can; test bits from the bit set with a relatively short instruction sequence. Bit; vectors may overlap so long as they use different bits. For the full details,; see the `ByteArrayBuilder`_ class. In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in; bit 1 and C at offset 0 in bit 2, the byte array would look like this:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 06 lea 0x6f70bc0(%rip),%rdx; ca7fe2: f6 04 10 10 testb $0x10,(%rax,%rdx,1); ca7fe6: 0f 84 25 05 00 00 je ca8511; ca7fec: ff 91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21158,Testability,test,test,21158,"ure. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:9404,Usability,simpl,simply,9404,"~~~~~~~~~~~~~~~~~~. Of course, this alignment scheme works best if the address points are; in fact aligned correctly. To make this more likely to happen, we insert; padding between virtual tables that in many cases aligns address points to; a power of 2. Specifically, our padding aligns virtual tables to the next; highest power of 2 bytes; because address points for specific base classes; normally appear at fixed offsets within the virtual table, this normally; has the effect of aligning the address points as well. This scheme introduces tradeoffs between decreased space overhead for; instructions and bit vectors and increased overhead in the form of padding. We; therefore limit the amount of padding so that we align to no more than 128; bytes. This number was found experimentally to provide a good tradeoff. Eliminating Bit Vector Checks for All-Ones Bit Vectors; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If the bit vector is all ones, the bit vector check is redundant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18538,Usability,simpl,simplifying,18538,"table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Our jump table will (conceptually) look like this:. .. code-block:: none. f:; jmp .Ltmp0 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance pen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25126,Usability,simpl,simpler,25126,"flow (`RET` instructions) can be hijacked; via overwriting the return address (`RA`) on stack.; Various mitigation techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_); try to detect or prevent `RA` corruption on stack. RCFI enforces the expected control flow in several different ways described below.; RCFI heavily relies on LTO. Leaf Functions; --------------; If `f()` is a leaf function (i.e. it has no calls; except maybe no-return calls) it can be called using a special calling convention; that stores `RA` in a dedicated register `R` before the `CALL` instruction.; `f()` does not spill `R` and does not use the `RET` instruction,; instead it uses the value in `R` to `JMP` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:1261,Availability,down,download,1261,"ady know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:2350,Availability,avail,available,2350,"point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won'",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:4250,Availability,avail,available,4250,"* need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option is to define the target architecture. For that, use; ``-target <triple>``. If you don't specify the target, CPU names won't; match (since Clang assumes the host triple), and the compilation will; go ahead, creating code for the host platform, which will break later; on when assembling or linking. The triple has the general format ``<arch><sub>-<vendor>-<sys>-<env>``, where:; * ``arch`` = ``x86_64``, ``i386``, ``arm``, ``thumb``, ``mips``, etc.; * ``sub`` = for ex. on ARM: ``v5``, ``v6m``, ``v7a``, ``v7m``, etc.; * ``vendor`` = ``pc``, ``apple``, ``nvidia``, ``ibm``, etc.; * ``sys`` = ``none``, ``linux``, ``win32``, ``darwin``, ``cuda``, etc.; * ``env`` = ``eabi``, ``gnu``, ``android``, ``macho``, ``elf``, etc. The sub-architecture options are available for their own architectures,; of course, so ""x86v7a"" doesn't make sense. The vendor needs to be; specified only if there's a relevant change, for instance between PC; and Apple. Most of the time it can be omitted (and Unknown); will be assumed, which sets the defaults for the specified architecture.; The system name is generally the OS (linux, darwin), but could be special; like the bare-metal ""none"". When a parameter is not important, it can be omitted, or you can; choose ``unknown`` and the defaults will be used. If you choose a parameter; that Clang doesn't know, like ``blerg``, it'll ignore and assume; ``unknown``, which is not always desired, so be careful. Finally, the env (environment) option is something that will pick default; CPU/FPU, define the specific behaviour of your code (PCS, extensions),; and also choose the correct library calls, etc. CPU, FPU, ABI; -------------. Once your target is specified, it's time to pick the hardware you'll; be compiling to. For every architecture, a defau",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:5511,Availability,avail,available,5511," be assumed, which sets the defaults for the specified architecture.; The system name is generally the OS (linux, darwin), but could be special; like the bare-metal ""none"". When a parameter is not important, it can be omitted, or you can; choose ``unknown`` and the defaults will be used. If you choose a parameter; that Clang doesn't know, like ``blerg``, it'll ignore and assume; ``unknown``, which is not always desired, so be careful. Finally, the env (environment) option is something that will pick default; CPU/FPU, define the specific behaviour of your code (PCS, extensions),; and also choose the correct library calls, etc. CPU, FPU, ABI; -------------. Once your target is specified, it's time to pick the hardware you'll; be compiling to. For every architecture, a default set of CPU/FPU/ABI; will be chosen, so you'll almost always have to change it via flags. Typical flags include:; * ``-mcpu=<cpu-name>``, like x86-64, swift, cortex-a15; * ``-mfpu=<fpu-name>``, like SSE3, NEON, controlling the FP unit available; * ``-mfloat-abi=<fabi>``, like soft, hard, controlling which registers; to use for floating-point. The default is normally the common denominator, so that Clang doesn't; generate code that breaks. But that also means you won't get the best; code for your specific hardware, which may mean orders of magnitude; slower than you expect. For example, if your target is ``arm-none-eabi``, the default CPU will; be ``arm7tdmi`` using soft float, which is extremely slow on modern cores,; whereas if your triple is ``armv7a-none-eabi``, it'll be Cortex-A8 with; NEON, but still using soft-float, which is much better, but still not; great. Toolchain Options; -----------------. There are three main options to control access to your cross-compiler:; ``--sysroot``, ``-I``, and ``-L``. The two last ones are well known,; but they're particularly important for additional libraries; and headers that are specific to your target. There are two main ways to have a cross-compiler:. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7050,Availability,avail,available,7050,"`, it'll be Cortex-A8 with; NEON, but still using soft-float, which is much better, but still not; great. Toolchain Options; -----------------. There are three main options to control access to your cross-compiler:; ``--sysroot``, ``-I``, and ``-L``. The two last ones are well known,; but they're particularly important for additional libraries; and headers that are specific to your target. There are two main ways to have a cross-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8203,Availability,avail,available,8203,"lues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnuea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8301,Availability,down,download,8301,"lues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnuea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:9359,Availability,error,errors,9359,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:9534,Availability,error,errors,9534,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:9573,Availability,down,down,9573,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:2515,Deployability,install,installed,2515," cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:2853,Deployability,install,installed,2853,"ain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option is to define the target architecture. For that, use; ``-target <triple>``. If you don't specify the target, CPU names won't; match (since Clang assumes the host triple), and the compilation will; go ahead, creating code for the host platform, which will break later; on w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:6960,Deployability,install,installed,6960,"`, it'll be Cortex-A8 with; NEON, but still using soft-float, which is much better, but still not; great. Toolchain Options; -----------------. There are three main options to control access to your cross-compiler:; ``--sysroot``, ``-I``, and ``-L``. The two last ones are well known,; but they're particularly important for additional libraries; and headers that are specific to your target. There are two main ways to have a cross-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8537,Deployability,configurat,configuration,8537,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8659,Deployability,configurat,configuration,8659,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8901,Deployability,configurat,configuration,8901,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7758,Integrability,depend,dependencies,7758,"additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMak",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7993,Integrability,depend,dependency,7993,"ager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have mult",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8498,Integrability,depend,dependencies,8498,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8565,Integrability,depend,dependencies,8565,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:3143,Modifiability,flexible,flexible,3143,"ers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option is to define the target architecture. For that, use; ``-target <triple>``. If you don't specify the target, CPU names won't; match (since Clang assumes the host triple), and the compilation will; go ahead, creating code for the host platform, which will break later; on when assembling or linking. The triple has the general format ``<arch><sub>-<vendor>-<sys>-<env>``, where:; * ``arch`` = ``x86_64``, ``i386``, ``arm``, ``thumb``, ``mips``, etc.; * ``sub`` = for ex. on ARM: ``v5``, ``v6m``, ``v7a``, ``v7m``, etc.; * ``vendor`` = ``pc``, ``apple``, ``nvidia``, ``ibm``, etc.; * ``sys`` = ``none``, ``linux``, ``win32``, ``darwin``, ``cuda``, etc.; * ``env`` = ``eabi``, ``gnu``, ``android``, ``macho``, ``elf``, etc.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8066,Modifiability,config,configure,8066,"ager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have mult",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8537,Modifiability,config,configuration,8537,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8659,Modifiability,config,configuration,8659,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8800,Modifiability,config,configure,8800,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8901,Modifiability,config,configuration,8901,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:1053,Performance,perform,performing,1053,"===================================================================; Cross-compilation using Clang; ===================================================================. Introduction; ============. This document will guide you in choosing the right Clang options; for cross-compiling your code to a different architecture. It assumes you; already know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7448,Safety,safe,safer,7448,"oss-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:6233,Security,access,access,6233,"r every architecture, a default set of CPU/FPU/ABI; will be chosen, so you'll almost always have to change it via flags. Typical flags include:; * ``-mcpu=<cpu-name>``, like x86-64, swift, cortex-a15; * ``-mfpu=<fpu-name>``, like SSE3, NEON, controlling the FP unit available; * ``-mfloat-abi=<fabi>``, like soft, hard, controlling which registers; to use for floating-point. The default is normally the common denominator, so that Clang doesn't; generate code that breaks. But that also means you won't get the best; code for your specific hardware, which may mean orders of magnitude; slower than you expect. For example, if your target is ``arm-none-eabi``, the default CPU will; be ``arm7tdmi`` using soft float, which is extremely slow on modern cores,; whereas if your triple is ``armv7a-none-eabi``, it'll be Cortex-A8 with; NEON, but still using soft-float, which is much better, but still not; great. Toolchain Options; -----------------. There are three main options to control access to your cross-compiler:; ``--sysroot``, ``-I``, and ``-L``. The two last ones are well known,; but they're particularly important for additional libraries; and headers that are specific to your target. There are two main ways to have a cross-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:2696,Testability,log,logical,2696,"ain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option is to define the target architecture. For that, use; ``-target <triple>``. If you don't specify the target, CPU names won't; match (since Clang assumes the host triple), and the compilation will; go ahead, creating code for the host platform, which will break later; on w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:216,Usability,guid,guide,216,"===================================================================; Cross-compilation using Clang; ===================================================================. Introduction; ============. This document will guide you in choosing the right Clang options; for cross-compiling your code to a different architecture. It assumes you; already know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:1251,Usability,simpl,simple,1251,"ady know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CrossCompilation.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:13302,Availability,down,down,13302,"et_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x86\_64 Linux. Design; ======. Please refer to the :doc:`design document<DataFlowSanitizerDesign>`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:13565,Availability,down,down,13565,"et_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x86\_64 Linux. Design; ======. Please refer to the :doc:`design document<DataFlowSanitizerDesign>`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3190,Deployability,update,updates,3190,"omes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:10496,Energy Efficiency,allocate,allocated,10496,"inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:10808,Energy Efficiency,power,powers,10808,"bvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:2951,Integrability,message,message,2951," to a specific function should use the operating system's native; ABI or whether it should use a variant of this ABI that also propagates labels; through function parameters and return values. The ABI list file also controls; how labels are propagated in the former case. DataFlowSanitizer comes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3541,Integrability,wrap,wrapper,3541," a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(int x);; void __dfsw_f(int x, dfsan_label x_label);. void *memcpy(void *dest, const void *src, size_t n);; void *__dfsw_memcpy(void *dest, const void *src, size_t n,; dfsan_label dest_label, dfsan_label src_label,; dfsan_label n_label, dfsan_label *ret_label);. If a function defined in the translation unit being compiled belongs to the; `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3633,Integrability,wrap,wrap,3633,"t file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(int x);; void __dfsw_f(int x, dfsan_label x_label);. void *memcpy(void *dest, const void *src, size_t n);; void *__dfsw_memcpy(void *dest, const void *src, size_t n,; dfsan_label dest_label, dfsan_label src_label,; dfsan_label n_label, dfsan_label *ret_label);. If a function defined in the translation unit being compiled belongs to the; ``uninstrumented`` category, it will be compiled so as to conform to the; native ABI. Its arguments will be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:5508,Integrability,wrap,wrapper,5508,"l *ret_label);. If a function defined in the translation unit being compiled belongs to the; ``uninstrumented`` category, it will be compiled so as to conform to the; native ABI. Its arguments will be assumed to be unlabelled, but it will; propagate labels in shadow memory. For example:. .. code-block:: none. # main is called by the C runtime using the native ABI.; fun:main=uninstrumented; fun:main=discard. # malloc only writes to its internal data structures, not user-accessible memory.; fun:malloc=uninstrumented; fun:malloc=discard. # tolower is a pure function.; fun:tolower=uninstrumented; fun:tolower=functional. # memcpy needs to copy the shadow from the source to the destination region.; # This is done in a custom function.; fun:memcpy=uninstrumented; fun:memcpy=custom. For instrumented functions, the ABI list supports a ``force_zero_labels``; category, which will make all stores and return values set zero labels.; Functions should never be labelled with both ``force_zero_labels``; and ``uninstrumented`` or any of the uninstrumented wrapper kinds. For example:. .. code-block:: none. # e.g. void writes_data(char* out_buf, int out_buf_len) {...}; # Applying force_zero_labels will force out_buf shadow to zero.; fun:writes_data=force_zero_labels. Compilation Flags; -----------------. * ``-dfsan-abilist`` -- The additional ABI list files that control how shadow; parameters are passed. File names are separated by comma.; * ``-dfsan-combine-pointer-labels-on-load`` -- Controls whether to include or; ignore the labels of pointers in load instructions. Its default value is true.; For example:. .. code-block:: c++. v = *p;. If the flag is true, the label of ``v`` is the union of the label of ``p`` and; the label of ``*p``. If the flag is false, the label of ``v`` is the label of; just ``*p``. * ``-dfsan-combine-pointer-labels-on-store`` -- Controls whether to include or; ignore the labels of pointers in store instructions. Its default value is; false. For example:. .. co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:9798,Integrability,depend,dependency,9798,"ns inside signal; handlers, as this is prone to deadlock. Tainted values used in conditional; expressions inside signal handlers will instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. B",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:9914,Integrability,depend,dependent,9914," instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:2345,Modifiability,extend,extend,2345,"s, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it should use a variant of this ABI that also propagates labels; through function parameters and return values. The ABI list file also controls; how labels are propagated in the former case. DataFlowSanitizer comes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:5935,Performance,load,load,5935,"nstrumented; fun:malloc=discard. # tolower is a pure function.; fun:tolower=uninstrumented; fun:tolower=functional. # memcpy needs to copy the shadow from the source to the destination region.; # This is done in a custom function.; fun:memcpy=uninstrumented; fun:memcpy=custom. For instrumented functions, the ABI list supports a ``force_zero_labels``; category, which will make all stores and return values set zero labels.; Functions should never be labelled with both ``force_zero_labels``; and ``uninstrumented`` or any of the uninstrumented wrapper kinds. For example:. .. code-block:: none. # e.g. void writes_data(char* out_buf, int out_buf_len) {...}; # Applying force_zero_labels will force out_buf shadow to zero.; fun:writes_data=force_zero_labels. Compilation Flags; -----------------. * ``-dfsan-abilist`` -- The additional ABI list files that control how shadow; parameters are passed. File names are separated by comma.; * ``-dfsan-combine-pointer-labels-on-load`` -- Controls whether to include or; ignore the labels of pointers in load instructions. Its default value is true.; For example:. .. code-block:: c++. v = *p;. If the flag is true, the label of ``v`` is the union of the label of ``p`` and; the label of ``*p``. If the flag is false, the label of ``v`` is the label of; just ``*p``. * ``-dfsan-combine-pointer-labels-on-store`` -- Controls whether to include or; ignore the labels of pointers in store instructions. Its default value is; false. For example:. .. code-block:: c++. *p = v;. If the flag is true, the label of ``*p`` is the union of the label of ``p`` and; the label of ``v``. If the flag is false, the label of ``*p`` is the label of; just ``v``. * ``-dfsan-combine-offset-labels-on-gep`` -- Controls whether to propagate; labels of offsets in GEP instructions. Its default value is true. For example:. .. code-block:: c++. p += i;. If the flag is true, the label of ``p`` is the union of the label of ``p`` and; the label of ``i``. If the flag is false, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:6010,Performance,load,load,6010,"nstrumented; fun:malloc=discard. # tolower is a pure function.; fun:tolower=uninstrumented; fun:tolower=functional. # memcpy needs to copy the shadow from the source to the destination region.; # This is done in a custom function.; fun:memcpy=uninstrumented; fun:memcpy=custom. For instrumented functions, the ABI list supports a ``force_zero_labels``; category, which will make all stores and return values set zero labels.; Functions should never be labelled with both ``force_zero_labels``; and ``uninstrumented`` or any of the uninstrumented wrapper kinds. For example:. .. code-block:: none. # e.g. void writes_data(char* out_buf, int out_buf_len) {...}; # Applying force_zero_labels will force out_buf shadow to zero.; fun:writes_data=force_zero_labels. Compilation Flags; -----------------. * ``-dfsan-abilist`` -- The additional ABI list files that control how shadow; parameters are passed. File names are separated by comma.; * ``-dfsan-combine-pointer-labels-on-load`` -- Controls whether to include or; ignore the labels of pointers in load instructions. Its default value is true.; For example:. .. code-block:: c++. v = *p;. If the flag is true, the label of ``v`` is the union of the label of ``p`` and; the label of ``*p``. If the flag is false, the label of ``v`` is the label of; just ``*p``. * ``-dfsan-combine-pointer-labels-on-store`` -- Controls whether to include or; ignore the labels of pointers in store instructions. Its default value is; false. For example:. .. code-block:: c++. *p = v;. If the flag is true, the label of ``*p`` is the union of the label of ``p`` and; the label of ``v``. If the flag is false, the label of ``*p`` is the label of; just ``v``. * ``-dfsan-combine-offset-labels-on-gep`` -- Controls whether to propagate; labels of offsets in GEP instructions. Its default value is true. For example:. .. code-block:: c++. p += i;. If the flag is true, the label of ``p`` is the union of the label of ``p`` and; the label of ``i``. If the flag is false, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:7520,Performance,load,loads,7520,"p`` is the union of the label of ``p`` and; the label of ``v``. If the flag is false, the label of ``*p`` is the label of; just ``v``. * ``-dfsan-combine-offset-labels-on-gep`` -- Controls whether to propagate; labels of offsets in GEP instructions. Its default value is true. For example:. .. code-block:: c++. p += i;. If the flag is true, the label of ``p`` is the union of the label of ``p`` and; the label of ``i``. If the flag is false, the label of ``p`` is unchanged. * ``-dfsan-track-select-control-flow`` -- Controls whether to track the control; flow of select instructions. Its default value is true. For example:. .. code-block:: c++. v = b? v1: v2;. If the flag is true, the label of ``v`` is the union of the labels of ``b``,; ``v1`` and ``v2``. If the flag is false, the label of ``v`` is the union of the; labels of just ``v1`` and ``v2``. * ``-dfsan-event-callbacks`` -- An experimental feature that inserts callbacks for; certain data events. Currently callbacks are only inserted for loads, stores,; memory transfers (i.e. memcpy and memmove), and comparisons. Its default value; is false. If this flag is set to true, a user must provide definitions for the; following callback functions:. .. code-block:: c++. void __dfsan_load_callback(dfsan_label Label, void* Addr);; void __dfsan_store_callback(dfsan_label Label, void* Addr);; void __dfsan_mem_transfer_callback(dfsan_label *Start, size_t Len);; void __dfsan_cmp_callback(dfsan_label CombinedLabel);. * ``-dfsan-conditional-callbacks`` -- An experimental feature that inserts; callbacks for control flow conditional expressions.; This can be used to find where tainted values can control execution. In addition to this compilation flag, a callback handler must be registered; using ``dfsan_set_conditional_callback(my_callback);``, where my_callback is; a function with a signature matching; ``void my_callback(dfsan_label l, dfsan_origin o);``.; This signature is the same when origin tracking is disabled - in this case; th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:9266,Performance,load,load,9266,"ust be registered; using ``dfsan_set_conditional_callback(my_callback);``, where my_callback is; a function with a signature matching; ``void my_callback(dfsan_label l, dfsan_origin o);``.; This signature is the same when origin tracking is disabled - in this case; the dfsan_origin passed in it will always be 0. The callback will only be called when a tainted value reaches a conditional; expression for control flow (such as an if's condition).; The callback will be skipped for conditional expressions inside signal; handlers, as this is prone to deadlock. Tainted values used in conditional; expressions inside signal handlers will instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:13512,Performance,load,loads,13512,"et_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x86\_64 Linux. Design; ======. Please refer to the :doc:`design document<DataFlowSanitizerDesign>`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:280,Safety,detect,detect,280,"=================; DataFlowSanitizer; =================. .. toctree::; :hidden:. DataFlowSanitizerDesign. .. contents::; :local:. Introduction; ============. DataFlowSanitizer is a generalised dynamic data flow analysis. Unlike other Sanitizer tools, this tool is not designed to detect a; specific class of bugs on its own. Instead, it provides a generic; dynamic data flow analysis framework to be used by clients to help; detect application-specific issues within their own code. How to build libc++ with DFSan; ==============================. DFSan requires either all of your code to be instrumented or for uninstrumented; functions to be listed as ``uninstrumented`` in the `ABI list`_. If you'd like to have instrumented libc++ functions, then you need to build it; with DFSan instrumentation from source. Here is an example of how to build; libc++ and the libc++ ABI with data flow sanitizer instrumentation. .. code-block:: console. mkdir libcxx-build; cd libcxx-build. # An example using ninja; cmake -GNinja -S <monorepo-root>/runtimes \; -DCMAKE_C_COMPILER=clang \; -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZER=""DataFlow"" \; -DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi"". ninja cxx cxxabi. Note: Ensure you are building with a sufficiently new version of Clang. Usage; =====. With no program changes, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:425,Safety,detect,detect,425,"=================; DataFlowSanitizer; =================. .. toctree::; :hidden:. DataFlowSanitizerDesign. .. contents::; :local:. Introduction; ============. DataFlowSanitizer is a generalised dynamic data flow analysis. Unlike other Sanitizer tools, this tool is not designed to detect a; specific class of bugs on its own. Instead, it provides a generic; dynamic data flow analysis framework to be used by clients to help; detect application-specific issues within their own code. How to build libc++ with DFSan; ==============================. DFSan requires either all of your code to be instrumented or for uninstrumented; functions to be listed as ``uninstrumented`` in the `ABI list`_. If you'd like to have instrumented libc++ functions, then you need to build it; with DFSan instrumentation from source. Here is an example of how to build; libc++ and the libc++ ABI with data flow sanitizer instrumentation. .. code-block:: console. mkdir libcxx-build; cd libcxx-build. # An example using ninja; cmake -GNinja -S <monorepo-root>/runtimes \; -DCMAKE_C_COMPILER=clang \; -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZER=""DataFlow"" \; -DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi"". ninja cxx cxxabi. Note: Ensure you are building with a sufficiently new version of Clang. Usage; =====. With no program changes, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:890,Security,sanitiz,sanitizer,890,"=================; DataFlowSanitizer; =================. .. toctree::; :hidden:. DataFlowSanitizerDesign. .. contents::; :local:. Introduction; ============. DataFlowSanitizer is a generalised dynamic data flow analysis. Unlike other Sanitizer tools, this tool is not designed to detect a; specific class of bugs on its own. Instead, it provides a generic; dynamic data flow analysis framework to be used by clients to help; detect application-specific issues within their own code. How to build libc++ with DFSan; ==============================. DFSan requires either all of your code to be instrumented or for uninstrumented; functions to be listed as ``uninstrumented`` in the `ABI list`_. If you'd like to have instrumented libc++ functions, then you need to build it; with DFSan instrumentation from source. Here is an example of how to build; libc++ and the libc++ ABI with data flow sanitizer instrumentation. .. code-block:: console. mkdir libcxx-build; cd libcxx-build. # An example using ninja; cmake -GNinja -S <monorepo-root>/runtimes \; -DCMAKE_C_COMPILER=clang \; -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZER=""DataFlow"" \; -DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi"". ninja cxx cxxabi. Note: Ensure you are building with a sufficiently new version of Clang. Usage; =====. With no program changes, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:1682,Security,sanitiz,sanitizer,1682,"in the `ABI list`_. If you'd like to have instrumented libc++ functions, then you need to build it; with DFSan instrumentation from source. Here is an example of how to build; libc++ and the libc++ ABI with data flow sanitizer instrumentation. .. code-block:: console. mkdir libcxx-build; cd libcxx-build. # An example using ninja; cmake -GNinja -S <monorepo-root>/runtimes \; -DCMAKE_C_COMPILER=clang \; -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZER=""DataFlow"" \; -DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi"". ninja cxx cxxabi. Note: Ensure you are building with a sufficiently new version of Clang. Usage; =====. With no program changes, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it should use a variant of this ABI that also propagates labels; through function parameters and return values. The ABI list file also controls; how labels are propagated in the former case. DataFlowSanitizer comes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`Sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3161,Security,access,accessible,3161,"omes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3303,Security,access,accessible,3303,"omes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3780,Security,access,accessible,3780,"ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(int x);; void __dfsw_f(int x, dfsan_label x_label);. void *memcpy(void *dest, const void *src, size_t n);; void *__dfsw_memcpy(void *dest, const void *src, size_t n,; dfsan_label dest_label, dfsan_label src_label,; dfsan_label n_label, dfsan_label *ret_label);. If a function defined in the translation unit being compiled belongs to the; ``uninstrumented`` category, it will be compiled so as to conform to the; native ABI. Its arguments will be assumed to be unlabelled, but it will; propagate labels in shadow memory. For example:. .. code-block:: none. # main is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:4928,Security,access,accessible,4928,"``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(int x);; void __dfsw_f(int x, dfsan_label x_label);. void *memcpy(void *dest, const void *src, size_t n);; void *__dfsw_memcpy(void *dest, const void *src, size_t n,; dfsan_label dest_label, dfsan_label src_label,; dfsan_label n_label, dfsan_label *ret_label);. If a function defined in the translation unit being compiled belongs to the; ``uninstrumented`` category, it will be compiled so as to conform to the; native ABI. Its arguments will be assumed to be unlabelled, but it will; propagate labels in shadow memory. For example:. .. code-block:: none. # main is called by the C runtime using the native ABI.; fun:main=uninstrumented; fun:main=discard. # malloc only writes to its internal data structures, not user-accessible memory.; fun:malloc=uninstrumented; fun:malloc=discard. # tolower is a pure function.; fun:tolower=uninstrumented; fun:tolower=functional. # memcpy needs to copy the shadow from the source to the destination region.; # This is done in a custom function.; fun:memcpy=uninstrumented; fun:memcpy=custom. For instrumented functions, the ABI list supports a ``force_zero_labels``; category, which will make all stores and return values set zero labels.; Functions should never be labelled with both ``force_zero_labels``; and ``uninstrumented`` or any of the uninstrumented wrapper kinds. For example:. .. code-block:: none. # e.g. void writes_data(char* out_buf, int out_buf_len) {...}; # Applying force_zero_labels will force out_buf shadow to zero.; fun:writes_data=force_zero_labels. Compilation Flags; -----------------. * ``-dfsan-abilist`` -- The additional ABI list files that control how shadow; parameters are passed. File names are separated by comma.; * ``-df",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:8936,Security,access,accessed,8936,"_label *Start, size_t Len);; void __dfsan_cmp_callback(dfsan_label CombinedLabel);. * ``-dfsan-conditional-callbacks`` -- An experimental feature that inserts; callbacks for control flow conditional expressions.; This can be used to find where tainted values can control execution. In addition to this compilation flag, a callback handler must be registered; using ``dfsan_set_conditional_callback(my_callback);``, where my_callback is; a function with a signature matching; ``void my_callback(dfsan_label l, dfsan_origin o);``.; This signature is the same when origin tracking is disabled - in this case; the dfsan_origin passed in it will always be 0. The callback will only be called when a tainted value reaches a conditional; expression for control flow (such as an if's condition).; The callback will be skipped for conditional expressions inside signal; handlers, as this is prone to deadlock. Tainted values used in conditional; expressions inside signal handlers will instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11038,Security,sanitiz,sanitizer,11038,"is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12445,Security,sanitiz,sanitizer,12445,"l; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-tra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11078,Testability,assert,assert,11078,"size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11401,Testability,assert,assert,11401,". Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11454,Testability,assert,assert,11454,". Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11507,Testability,assert,assert,11507,". Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11572,Testability,assert,assert,11572,". Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11647,Testability,assert,assert,11647,"ls, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11692,Testability,assert,assert,11692,"ls, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11737,Testability,assert,assert,11737,"ls, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11836,Testability,assert,assert,11836,"opagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11891,Testability,assert,assert,11891,"opagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11946,Testability,assert,assert,11946,"opagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12001,Testability,assert,assert,12001,"opagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12077,Testability,assert,assert,12077," int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12123,Testability,assert,assert,12123," int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12169,Testability,assert,assert,12169," int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12426,Testability,test,test,12426,"l); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12758,Testability,test,test,12758,"(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x8",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12941,Testability,test,test,12941,"et_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x86\_64 Linux. Design; ======. Please refer to the :doc:`design document<DataFlowSanitizerDesign>`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:13090,Testability,test,test,13090,"et_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x86\_64 Linux. Design; ======. Please refer to the :doc:`design document<DataFlowSanitizerDesign>`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:10767,Usability,simpl,simply,10767,"bvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:9350,Availability,mask,masks,9350,"-----------------+; | 0x500000000000|0x510000000000 | shadow 1 |; +---------------+---------------+--------------------+; | 0x400000000000|0x500000000000 | unused |; +---------------+---------------+--------------------+; | 0x300000000000|0x400000000000 | origin 3 |; +---------------+---------------+--------------------+; | 0x200000000000|0x300000000000 | shadow 3 |; +---------------+---------------+--------------------+; | 0x110000000000|0x200000000000 | origin 2 |; +---------------+---------------+--------------------+; | 0x100000000000|0x110000000000 | unused |; +---------------+---------------+--------------------+; | 0x010000000000|0x100000000000 | shadow 2 |; +---------------+---------------+--------------------+; | 0x000000000000|0x010000000000 | application 1 |; +---------------+---------------+--------------------+. Each byte of application memory corresponds to a single byte of shadow; memory, which is used to store its taint label. We map memory, shadow, and; origin regions to each other with these masks and offsets:. * shadow_addr = memory_addr ^ 0x500000000000. * origin_addr = shadow_addr + 0x100000000000. As for LLVM SSA registers, we have not found it necessary to associate a label; with each byte or bit of data, as some other tools do. Instead, labels are; associated directly with registers. Loads will result in a union of; all shadow labels corresponding to bytes loaded, and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:10407,Availability,toler,tolerant,10407,"found it necessary to associate a label; with each byte or bit of data, as some other tools do. Instead, labels are; associated directly with registers. Loads will result in a union of; all shadow labels corresponding to bytes loaded, and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:801,Energy Efficiency,monitor,monitor,801,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:3841,Energy Efficiency,allocate,allocated,3841,"ctions are provided to check origin tracking status and results. .. code-block:: c. /// Retrieves the immediate origin associated with the given data. The returned; /// origin may point to another origin.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_origin dfsan_get_origin(long data);. /// Retrieves the very first origin associated with the data at the given; /// address.; dfsan_origin dfsan_get_init_origin(const void *addr);. /// Prints the origin trace of the label at the address `addr` to stderr. It also; /// prints description at the beginning of the trace. If origin tracking is not; /// on, or the address is not labeled, it prints nothing.; void dfsan_print_origin_trace(const void *addr, const char *description);. /// Prints the origin trace of the label at the address `addr` to a pre-allocated; /// output buffer. If origin tracking is not on, or the address is`; /// not labeled, it prints nothing.; ///; /// `addr` is the tainted memory address whose origin we are printing.; /// `description` is a description printed at the beginning of the trace.; /// `out_buf` is the output buffer to write the results to. `out_buf_size` is; /// the size of `out_buf`. The function returns the number of symbols that; /// should have been written to `out_buf` (not including trailing null byte '\0').; /// Thus, the string is truncated iff return value is not less than `out_buf_size`.; size_t dfsan_sprint_origin_trace(const void *addr, const char *description,; char *out_buf, size_t out_buf_size);. /// Returns the value of `-dfsan-track-origins`.; int dfsan_get_track_origins(void);. The following functions are provided to register hooks called by custom wrappers. .. code-block:: c. /// Sets a callback to be invoked on calls to `write`. The callback is invoked; ///",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:10691,Energy Efficiency,efficient,efficient,10691," and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolow",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:4707,Integrability,wrap,wrappers,4707,"t prints nothing.; void dfsan_print_origin_trace(const void *addr, const char *description);. /// Prints the origin trace of the label at the address `addr` to a pre-allocated; /// output buffer. If origin tracking is not on, or the address is`; /// not labeled, it prints nothing.; ///; /// `addr` is the tainted memory address whose origin we are printing.; /// `description` is a description printed at the beginning of the trace.; /// `out_buf` is the output buffer to write the results to. `out_buf_size` is; /// the size of `out_buf`. The function returns the number of symbols that; /// should have been written to `out_buf` (not including trailing null byte '\0').; /// Thus, the string is truncated iff return value is not less than `out_buf_size`.; size_t dfsan_sprint_origin_trace(const void *addr, const char *description,; char *out_buf, size_t out_buf_size);. /// Returns the value of `-dfsan-track-origins`.; int dfsan_get_track_origins(void);. The following functions are provided to register hooks called by custom wrappers. .. code-block:: c. /// Sets a callback to be invoked on calls to `write`. The callback is invoked; /// before the write is done. The write is not guaranteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:11228,Integrability,wrap,wrappers,11228,"n type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret {",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:11348,Integrability,wrap,wrappers,11348,"d ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI func",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:1867,Modifiability,extend,extended,1867,"ces) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_label dfsan_get_label(long data);. /// Retrieves the label associated with the data at the given address.; dfsan_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label elem);. /// Computes the union of \c l1 and \c l2, resulting in a union label.; dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);. /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated; /// with the application memory. Use this call to start over the taint tracking; /// within the same process.; ///; /// Note: If another thread is working with tainted data during the flush, that; /// taint could still be written to shadow after the flush.; void dfsan_flush(void);. The following functions are provided to check origin ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:3140,Modifiability,extend,extended,3140,"an_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label elem);. /// Computes the union of \c l1 and \c l2, resulting in a union label.; dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);. /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated; /// with the application memory. Use this call to start over the taint tracking; /// within the same process.; ///; /// Note: If another thread is working with tainted data during the flush, that; /// taint could still be written to shadow after the flush.; void dfsan_flush(void);. The following functions are provided to check origin tracking status and results. .. code-block:: c. /// Retrieves the immediate origin associated with the given data. The returned; /// origin may point to another origin.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_origin dfsan_get_origin(long data);. /// Retrieves the very first origin associated with the data at the given; /// address.; dfsan_origin dfsan_get_init_origin(const void *addr);. /// Prints the origin trace of the label at the address `addr` to stderr. It also; /// prints description at the beginning of the trace. If origin tracking is not; /// on, or the address is not labeled, it prints nothing.; void dfsan_print_origin_trace(const void *addr, const char *description);. /// Prints the origin trace of the label at the address `addr` to a pre-allocated; /// output buffer. If origin tracking is not on, or the address is`; /// not labeled, it prints nothing.; ///; /// `addr` is the tainted memory address whose origin we are printing.; /// `description` is a description printed at the beginning of the trace.; /// `out_buf` is t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:6849,Modifiability,variab,variable,6849,"on with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is the memory layout for Linux/x86\_64:. +---------------+---------------+--------------------+; | Start | End | Use ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:10295,Modifiability,variab,variables,10295,"mory, shadow, and; origin regions to each other with these masks and offsets:. * shadow_addr = memory_addr ^ 0x500000000000. * origin_addr = shadow_addr + 0x100000000000. As for LLVM SSA registers, we have not found it necessary to associate a label; with each byte or bit of data, as some other tools do. Instead, labels are; associated directly with registers. Loads will result in a union of; all shadow labels corresponding to bytes loaded, and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:5705,Performance,optimiz,optimizing,5705," /// Sets a callback to be invoked on calls to `write`. The callback is invoked; /// before the write is done. The write is not guaranteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:7397,Performance,load,loads,7397,"y first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is the memory layout for Linux/x86\_64:. +---------------+---------------+--------------------+; | Start | End | Use |; +===============+===============+====================+; | 0x700000000000|0x800000000000 | application 3 |; +---------------+---------------+--------------------+; | 0x610000000000|0x700000000000 | unused |; +---------------+---------------+--------------------+; | 0x600000000000|0x610000000000 | origin 1 |; +---------------+---------------+--------------------+; | 0x510000000000|0x600000000000 | application 2 |; +---------------+---------------+--------------------+; | 0x500000000000|0x5",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:9728,Performance,load,loaded,9728,"-+; | 0x110000000000|0x200000000000 | origin 2 |; +---------------+---------------+--------------------+; | 0x100000000000|0x110000000000 | unused |; +---------------+---------------+--------------------+; | 0x010000000000|0x100000000000 | shadow 2 |; +---------------+---------------+--------------------+; | 0x000000000000|0x010000000000 | application 1 |; +---------------+---------------+--------------------+. Each byte of application memory corresponds to a single byte of shadow; memory, which is used to store its taint label. We map memory, shadow, and; origin regions to each other with these masks and offsets:. * shadow_addr = memory_addr ^ 0x500000000000. * origin_addr = shadow_addr + 0x100000000000. As for LLVM SSA registers, we have not found it necessary to associate a label; with each byte or bit of data, as some other tools do. Instead, labels are; associated directly with registers. Loads will result in a union of; all shadow labels corresponding to bytes loaded, and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:12101,Performance,load,load,12101,"s implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI function directly and the pass will compute the appropriate label; internally. This has the advantage of reducing the number of union operations; required when the return value label is known to be zero (i.e. ``discard``; functions, or ``functional`` functions with known unlabelled arguments). Checking ABI Consistency; ------------------------. DFSan changes the ABI of each function in the module. This makes it possible; for a function with the native ABI to be called with the instrumented ABI,; or vice versa, thus possibly invoking undefined behavior. A simple way; of statically detecting instances of this problem is to append the suffix; "".dfsan"" to the name of each instrumented-ABI function. This will not catch ever",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:12248,Performance,optimiz,optimization,12248," the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI function directly and the pass will compute the appropriate label; internally. This has the advantage of reducing the number of union operations; required when the return value label is known to be zero (i.e. ``discard``; functions, or ``functional`` functions with known unlabelled arguments). Checking ABI Consistency; ------------------------. DFSan changes the ABI of each function in the module. This makes it possible; for a function with the native ABI to be called with the instrumented ABI,; or vice versa, thus possibly invoking undefined behavior. A simple way; of statically detecting instances of this problem is to append the suffix; "".dfsan"" to the name of each instrumented-ABI function. This will not catch every such problem; in particular function pointers passed; across the instrumented-native barrier cannot be used on the other side.; These problems could potentially be caught dynamically.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:226,Safety,detect,detect,226,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:370,Safety,detect,detect,370,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:12912,Safety,detect,detecting,12912," the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI function directly and the pass will compute the appropriate label; internally. This has the advantage of reducing the number of union operations; required when the return value label is known to be zero (i.e. ``discard``; functions, or ``functional`` functions with known unlabelled arguments). Checking ABI Consistency; ------------------------. DFSan changes the ABI of each function in the module. This makes it possible; for a function with the native ABI to be called with the instrumented ABI,; or vice versa, thus possibly invoking undefined behavior. A simple way; of statically detecting instances of this problem is to append the suffix; "".dfsan"" to the name of each instrumented-ABI function. This will not catch every such problem; in particular function pointers passed; across the instrumented-native barrier cannot be used on the other side.; These problems could potentially be caught dynamically.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:565,Security,access,accessible,565,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:921,Security,secur,security,921,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:959,Security,audit,audit,959,"DataFlowSanitizer Design Document; =================================. This document sets out the design for DataFlowSanitizer, a general; dynamic data flow analysis. Unlike other Sanitizer tools, this tool is; not designed to detect a specific class of bugs on its own. Instead,; it provides a generic dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:1314,Security,sanitiz,sanitizer,1314," dynamic data flow analysis framework to be used; by clients to help detect application-specific issues within their; own code. DataFlowSanitizer is a program instrumentation which can associate; a number of taint labels with any data stored in any memory region; accessible by the program. The analysis is dynamic, which means that; it operates on a running program, and tracks how the labels propagate; through that program. Use Cases; ---------. This instrumentation can be used as a tool to help monitor how data; flows from a program's inputs (sources) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_label dfsan_get_label(long data);. /// Retrieves the label associated with the data at the given address.; dfsan_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label el",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:6547,Security,hash,hash,6547,"---------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:6597,Security,hash,hash,6597,"entation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:6754,Security,hash,hash,6754,"e instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:5854,Testability,log,logical,5854,"anteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:5926,Usability,simpl,simply,5926,"anteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:7453,Usability,simpl,simply,7453,"n bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_history_size``; can set the depth limit. Non-positive values mean unlimited. Its default value; is 16. When reaching the limit, origin tracking ignores following propagation; chains. The first chain of a trace starts by `dfsan_set_label` with non-zero labels. A; new chain is appended at the end of a trace at stores or memory transfers when; ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory transfer; instructions, glibc memcpy and memmove. When ``-dfsan-track-origins`` is 2, a; new chain is also appended at loads. Other instructions do not create new chains, but simply propagate origin trace; IDs. If an instruction has more than one operands with non-zero labels, the origin; treace ID of the last operand with non-zero label is propagated to the result of; the instruction. Memory layout and label management; ----------------------------------. The following is the memory layout for Linux/x86\_64:. +---------------+---------------+--------------------+; | Start | End | Use |; +===============+===============+====================+; | 0x700000000000|0x800000000000 | application 3 |; +---------------+---------------+--------------------+; | 0x610000000000|0x700000000000 | unused |; +---------------+---------------+--------------------+; | 0x600000000000|0x610000000000 | origin 1 |; +---------------+---------------+--------------------+; | 0x510000000000|0x600000000000 | application 2 |; +---------------+---------------+--------------------+; | 0x500000000000|0x510000000000 | shadow 1 |; +---------------+---------------+--------------------+;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:12886,Usability,simpl,simple,12886," the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI function directly and the pass will compute the appropriate label; internally. This has the advantage of reducing the number of union operations; required when the return value label is known to be zero (i.e. ``discard``; functions, or ``functional`` functions with known unlabelled arguments). Checking ABI Consistency; ------------------------. DFSan changes the ABI of each function in the module. This makes it possible; for a function with the native ABI to be called with the instrumented ABI,; or vice versa, thus possibly invoking undefined behavior. A simple way; of statically detecting instances of this problem is to append the suffix; "".dfsan"" to the name of each instrumented-ABI function. This will not catch every such problem; in particular function pointers passed; across the instrumented-native barrier cannot be used on the other side.; These problems could potentially be caught dynamically.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:11615,Availability,down,downside,11615,"iting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with the C++ philosophy of ""Pay for what you use"". Get the asynchronous stack; ==========================. Another important requirement to debug a coroutine is to print the asynchronous; stack to identify the asynchronous caller of the coroutine. As many; implementations of coroutine types store `std::coroutine_handle<> continuation`; in the promise type, identifying the caller should be trivial. The; `continuation` is typically the awaiting coroutine for the current coroutine.; That is, the asynchronous parent. Since the `promise_type` is obtainable from the address of a coroutine and; contains the corresponding continuation (which itself is a coroutine with a; `promise_type`), it should be trivial to print the entire asynchronous stack. This logic should be quite easily captured in a debugger script. Examples to print asynchronous stack; ------------------------------------. Here is an example to print the asynchronous stac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:2530,Energy Efficiency,allocate,allocated,2530,"k` and; `Generator` are commonly referred to coroutine types. coroutine; ---------. By technical definition, a `coroutine` is a suspendable function. However,; programmers typically use `coroutine` to refer to an individual instance.; For example:. .. code-block:: c++. std::vector<Task> Coros; // Task is a coroutine type.; for (int i = 0; i < 3; i++); Coros.push_back(CoroTask()); // CoroTask is a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typically say ""`Coros` contains 3 coroutines"" in the above; example, though this is not strictly correct. More technically, this should; say ""`Coros` contains 3 coroutine instances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they shoul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8623,Modifiability,variab,variable,8623,"nt_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8871,Modifiability,variab,variable,8871,". The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10257,Modifiability,variab,variable,10257,"wait await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10324,Modifiability,variab,variables,10324,"\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10422,Modifiability,variab,variables,10422,"\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10733,Modifiability,variab,variable,10733,"e equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:134,Performance,perform,performance,134,"========================; Debugging C++ Coroutines; ========================. .. contents::; :local:. Introduction; ============. For performance and other architectural reasons, the C++ Coroutines feature in; the Clang compiler is implemented in two parts of the compiler. Semantic; analysis is performed in Clang, and Coroutine construction and optimization; takes place in the LLVM middle-end. However, this design forces us to generate insufficient debugging information.; Typically, the compiler generates debug information in the Clang frontend, as; debug information is highly language specific. However, this is not possible; for Coroutine frames because the frames are constructed in the LLVM middle-end. To mitigate this problem, the LLVM middle end attempts to generate some debug; information, which is unfortunately incomplete, since much of the language; specific information is missing in the middle end. This document describes how to use this debug information to better debug; coroutines. Terminology; ===========. Due to the recent nature of C++20 Coroutines, the terminology used to describe; the concepts of Coroutines is not settled. This section defines a common,; understandable terminology to be used consistently throughout this document. coroutine type; --------------. A `coroutine function` is any function that contains any of the Coroutine; Keywords `co_await`, `co_yield`, or `co_return`. A `coroutine type` is a; possible return type of one of these `coroutine functions`. `Task` and; `Generator` are commonly referred to coroutine types. coroutine; ---------. By technical definition, a `coroutine` is a suspendable function. However,; programmers typically use `coroutine` to refer to an individual instance.; For example:. .. code-block:: c++. std::vector<Task> Coros; // Task is a coroutine type.; for (int i = 0; i < 3; i++); Coros.push_back(CoroTask()); // CoroTask is a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typical",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:296,Performance,perform,performed,296,"========================; Debugging C++ Coroutines; ========================. .. contents::; :local:. Introduction; ============. For performance and other architectural reasons, the C++ Coroutines feature in; the Clang compiler is implemented in two parts of the compiler. Semantic; analysis is performed in Clang, and Coroutine construction and optimization; takes place in the LLVM middle-end. However, this design forces us to generate insufficient debugging information.; Typically, the compiler generates debug information in the Clang frontend, as; debug information is highly language specific. However, this is not possible; for Coroutine frames because the frames are constructed in the LLVM middle-end. To mitigate this problem, the LLVM middle end attempts to generate some debug; information, which is unfortunately incomplete, since much of the language; specific information is missing in the middle end. This document describes how to use this debug information to better debug; coroutines. Terminology; ===========. Due to the recent nature of C++20 Coroutines, the terminology used to describe; the concepts of Coroutines is not settled. This section defines a common,; understandable terminology to be used consistently throughout this document. coroutine type; --------------. A `coroutine function` is any function that contains any of the Coroutine; Keywords `co_await`, `co_yield`, or `co_return`. A `coroutine type` is a; possible return type of one of these `coroutine functions`. `Task` and; `Generator` are commonly referred to coroutine types. coroutine; ---------. By technical definition, a `coroutine` is a suspendable function. However,; programmers typically use `coroutine` to refer to an individual instance.; For example:. .. code-block:: c++. std::vector<Task> Coros; // Task is a coroutine type.; for (int i = 0; i < 3; i++); Coros.push_back(CoroTask()); // CoroTask is a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typical",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:347,Performance,optimiz,optimization,347,"========================; Debugging C++ Coroutines; ========================. .. contents::; :local:. Introduction; ============. For performance and other architectural reasons, the C++ Coroutines feature in; the Clang compiler is implemented in two parts of the compiler. Semantic; analysis is performed in Clang, and Coroutine construction and optimization; takes place in the LLVM middle-end. However, this design forces us to generate insufficient debugging information.; Typically, the compiler generates debug information in the Clang frontend, as; debug information is highly language specific. However, this is not possible; for Coroutine frames because the frames are constructed in the LLVM middle-end. To mitigate this problem, the LLVM middle end attempts to generate some debug; information, which is unfortunately incomplete, since much of the language; specific information is missing in the middle end. This document describes how to use this debug information to better debug; coroutines. Terminology; ===========. Due to the recent nature of C++20 Coroutines, the terminology used to describe; the concepts of Coroutines is not settled. This section defines a common,; understandable terminology to be used consistently throughout this document. coroutine type; --------------. A `coroutine function` is any function that contains any of the Coroutine; Keywords `co_await`, `co_yield`, or `co_return`. A `coroutine type` is a; possible return type of one of these `coroutine functions`. `Task` and; `Generator` are commonly referred to coroutine types. coroutine; ---------. By technical definition, a `coroutine` is a suspendable function. However,; programmers typically use `coroutine` to refer to an individual instance.; For example:. .. code-block:: c++. std::vector<Task> Coros; // Task is a coroutine type.; for (int i = 0; i < 3; i++); Coros.push_back(CoroTask()); // CoroTask is a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typical",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:4431,Performance,optimiz,optimization,4431," the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_type` is `task::promise_type`, printing; the `promise_type` can be done by:. .. parsed-literal::. print (task::promise_type)*(0x416eb0+0x10). This is possible because the `promise_type` is guaranteed by the ABI to be at a; 16 bit offset from the coroutine frame. Note that there is also an ABI independent method:. .. parsed-literal::. print std::coroutine_handle<task::promise_type>::from_address((void*)0x416eb0).promise(). The functions `from_address(void*)` and `promise()` are often small enough to; be removed during optimization, so this method may not be possible. Print coroutine frames; ======================. LLVM generates the debug information for the coroutine frame in the LLVM middle; end, which permits printing of the coroutine frame in the debugger. Much like; the `promise_type`, when stopped at a breakpoint inside a coroutine we can; print the coroutine frame by:. .. parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8316,Performance,optimiz,optimizations,8316,"int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8575,Performance,optimiz,optimized,8575,"nt_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8835,Performance,optimiz,optimization,8835,". The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:9599,Performance,optimiz,optimizer,9599," of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:9656,Performance,load,load,9656," of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:9700,Performance,optimiz,optimized,9700,"this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:9853,Performance,load,load,9853,"s the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine librarie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:9982,Performance,load,load,9982,"s the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine librarie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10340,Performance,optimiz,optimized,10340,"\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5232,Safety,avoid,avoid,5232,"t offset from the coroutine frame. Note that there is also an ABI independent method:. .. parsed-literal::. print std::coroutine_handle<task::promise_type>::from_address((void*)0x416eb0).promise(). The functions `from_address(void*)` and `promise()` are often small enough to; be removed during optimization, so this method may not be possible. Print coroutine frames; ======================. LLVM generates the debug information for the coroutine frame in the LLVM middle; end, which permits printing of the coroutine frame in the debugger. Much like; the `promise_type`, when stopped at a breakpoint inside a coroutine we can; print the coroutine frame by:. .. parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_ty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:26500,Safety,avoid,avoid,26500,"xt. (gdb) show-coro-frame 0x4412c0; {; __resume_fn = 0x410960 <detail::chain_fn<18>()>,; __destroy_fn = 0x410d60 <detail::chain_fn<18>()>,; __promise = {; continuation = {; _M_fr_ptr = 0x441270; },; result = 0; },; struct_Awaiter_0 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x441310; }; }; },; struct_task_1 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; }; },; struct_task__promise_type__FinalSuspend_2 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; },; __coro_index = 1 '\001',; struct_std____n4861__suspend_always_3 = {; __int_8 = 0 '\000'; }. Get the living coroutines; =========================. Another useful task when debugging coroutines is to enumerate the list of; living coroutines, which is often done with threads. While technically; possible, this task is not recommended in production code as it is costly at; runtime. One such solution is to store the list of currently running coroutines; in a collection:. .. code-block:: c++. inline std::unordered_set<void*> lived_coroutines;; // For all promise_type we want to record; class promise_type {; public:; promise_type() {; // Note to avoid data races; lived_coroutines.insert(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; ~promise_type() {; // Note to avoid data races; lived_coroutines.erase(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; };. In the above code snippet, we save the address of every lived coroutine in the; `lived_coroutines` `unordered_set`. As before, once we know the address of the; coroutine we can derive the function, `promise_type`, and other members of the; frame. Thus, we could print the list of lived coroutines from that collection. Please note that the above is expensive from a storage perspective, and requires; some level of locking (not pictured) on the collection to prevent data races.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:26645,Safety,avoid,avoid,26645,"xt. (gdb) show-coro-frame 0x4412c0; {; __resume_fn = 0x410960 <detail::chain_fn<18>()>,; __destroy_fn = 0x410d60 <detail::chain_fn<18>()>,; __promise = {; continuation = {; _M_fr_ptr = 0x441270; },; result = 0; },; struct_Awaiter_0 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x441310; }; }; },; struct_task_1 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; }; },; struct_task__promise_type__FinalSuspend_2 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; },; __coro_index = 1 '\001',; struct_std____n4861__suspend_always_3 = {; __int_8 = 0 '\000'; }. Get the living coroutines; =========================. Another useful task when debugging coroutines is to enumerate the list of; living coroutines, which is often done with threads. While technically; possible, this task is not recommended in production code as it is costly at; runtime. One such solution is to store the list of currently running coroutines; in a collection:. .. code-block:: c++. inline std::unordered_set<void*> lived_coroutines;; // For all promise_type we want to record; class promise_type {; public:; promise_type() {; // Note to avoid data races; lived_coroutines.insert(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; ~promise_type() {; // Note to avoid data races; lived_coroutines.erase(std::coroutine_handle<promise_type>::from_promise(*this).address());; }; };. In the above code snippet, we save the address of every lived coroutine in the; `lived_coroutines` `unordered_set`. As before, once we know the address of the; coroutine we can derive the function, `promise_type`, and other members of the; frame. Thus, we could print the list of lived coroutines from that collection. Please note that the above is expensive from a storage perspective, and requires; some level of locking (not pictured) on the collection to prevent data races.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5790,Security,access,accessible,5790," parsed-literal::. print __coro_frame. Just as printing the `promise_type` is possible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:12464,Testability,log,logic,12464,"an locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with the C++ philosophy of ""Pay for what you use"". Get the asynchronous stack; ==========================. Another important requirement to debug a coroutine is to print the asynchronous; stack to identify the asynchronous caller of the coroutine. As many; implementations of coroutine types store `std::coroutine_handle<> continuation`; in the promise type, identifying the caller should be trivial. The; `continuation` is typically the awaiting coroutine for the current coroutine.; That is, the asynchronous parent. Since the `promise_type` is obtainable from the address of a coroutine and; contains the corresponding continuation (which itself is a coroutine with a; `promise_type`), it should be trivial to print the entire asynchronous stack. This logic should be quite easily captured in a debugger script. Examples to print asynchronous stack; ------------------------------------. Here is an example to print the asynchronous stack for the normal task implementation. .. code-block:: c++. // debugging-example.cpp; #include <coroutine>; #include <iostream>; #include <utility>. struct task {; struct promise_type {; task get_return_object();; std::suspend_always initial_suspend() { return {}; }. void unhandled_exception() noexcept {}. struct FinalSuspend {; std::coroutine_handle<> continuation;; auto await_ready() noexcept { return false; }; auto await_suspend(std::coroutine_handle<> handle) noexcept {; return continuation;; }; void await_resume() noexcept {}; };; FinalSuspend final_suspend() noexcept { return {continuation}; }. void return_value(int res) { result = res; }. std::coroutine_handle<> continuation = std::noop_coroutine();; int result = 0;; };. task(std::coroutine_handle<promise_type> handle) : handle(handle) {}; ~task() {; if (handle); handle.dest",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:25128,Testability,log,log,25128,"0x440fb0', 'continuation_addr = 0x440fb0'] at debugging-example.cpp:66; #29 0x419e90 in detail::chain_fn<29>() ['frame_addr = 0x440f50', 'promise_addr = 0x440f60', 'continuation_addr = 0x440f60'] at debugging-example.cpp:66; #30 0x41ac20 in detail::chain_fn<30>() ['frame_addr = 0x440f00', 'promise_addr = 0x440f10', 'continuation_addr = 0x440f10'] at debugging-example.cpp:66; #31 0x41b9b0 in chain() ['frame_addr = 0x440eb0', 'promise_addr = 0x440ec0', 'continuation_addr = 0x440ec0'] at debugging-example.cpp:77. Now we get the complete asynchronous stack!; It is also possible to print other asynchronous stack which doesn't live in the top of the stack.; We can make it by passing the address of the corresponding coroutine frame to ``async-bt`` command. By the debugging scripts, we can print any coroutine frame too as long as we know the address.; For example, we can print the coroutine frame for ``detail::chain_fn<18>()`` in the above example.; From the log record, we know the address of the coroutine frame is ``0x4412c0`` in the run. Then we can:. .. code-block:: text. (gdb) show-coro-frame 0x4412c0; {; __resume_fn = 0x410960 <detail::chain_fn<18>()>,; __destroy_fn = 0x410d60 <detail::chain_fn<18>()>,; __promise = {; continuation = {; _M_fr_ptr = 0x441270; },; result = 0; },; struct_Awaiter_0 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x441310; }; }; },; struct_task_1 = {; struct_std____n4861__coroutine_handle_0 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; }; },; struct_task__promise_type__FinalSuspend_2 = {; struct_std____n4861__coroutine_handle = {; PointerType = 0x0; }; },; __coro_index = 1 '\001',; struct_std____n4861__suspend_always_3 = {; __int_8 = 0 '\000'; }. Get the living coroutines; =========================. Another useful task when debugging coroutines is to enumerate the list of; living coroutines, which is often done with threads. While technically; possible, this ta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:2869,Usability,resume,resume,2869,"a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typically say ""`Coros` contains 3 coroutines"" in the above; example, though this is not strictly correct. More technically, this should; say ""`Coros` contains 3 coroutine instances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:3143,Usability,resume,resume,3143,"nstances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_type` is `task::promise_type`, printing; the `promise_type` can be done by:. .. parsed-literal::. print (task::promise_type)*(0x416eb0+0x10). This is possible because the `promise_type` is guaranteed by the ABI to be at a; 16 bit offset from the coroutine fra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:5869,Usability,simpl,simplified,5869,"ossible from the coroutine address,; printing the details of the coroutine frame from an address is also possible:. ::. (gdb) # Get the address of coroutine frame; (gdb) print/x *0x418eb0; $1 = 0x4019e0; (gdb) # Get the linkage name for the coroutine; (gdb) x 0x4019e0; 0x4019e0 <_ZL9coro_taski>: 0xe5894855; (gdb) # Turn off the demangler temporarily to avoid the debugger misunderstanding the name.; (gdb) set demangle-style none; (gdb) # The coroutine frame type is 'linkage_name.coro_frame_ty'; (gdb) print ('_ZL9coro_taski.coro_frame_ty')*(0x418eb0); $2 = {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:6450,Usability,resume,resume,6450," <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:6478,Usability,resume,resume,6478,"stroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_coun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7134,Usability,resume,resume,7134,"{; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the fir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7147,Usability,resume,resume,7147,"eturn_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7160,Usability,resume,resume,7160,"turn std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7659,Usability,clear,clearly,7659,"d(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8710,Usability,simpl,simple,8710,"unter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8746,Usability,clear,clear,8746,"unter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10660,Usability,simpl,simple,10660,"e equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10805,Usability,simpl,simple,10805,"in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with the C++ philosophy of ""Pay for what you use"". Get the asynchronous stack; =====================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:13932,Usability,resume,resume,13932,"oexcept {}. struct FinalSuspend {; std::coroutine_handle<> continuation;; auto await_ready() noexcept { return false; }; auto await_suspend(std::coroutine_handle<> handle) noexcept {; return continuation;; }; void await_resume() noexcept {}; };; FinalSuspend final_suspend() noexcept { return {continuation}; }. void return_value(int res) { result = res; }. std::coroutine_handle<> continuation = std::noop_coroutine();; int result = 0;; };. task(std::coroutine_handle<promise_type> handle) : handle(handle) {}; ~task() {; if (handle); handle.destroy();; }. auto operator co_await() {; struct Awaiter {; std::coroutine_handle<promise_type> handle;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; im",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:14614,Usability,resume,resumed,14614,"le;; auto await_ready() { return false; }; auto await_suspend(std::coroutine_handle<> continuation) {; handle.promise().continuation = continuation;; return handle;; }; int await_resume() {; int ret = handle.promise().result;; handle.destroy();; return ret;; }; };; return Awaiter{std::exchange(handle, nullptr)};; }. int syncStart() {; handle.resume();; return handle.promise().result;; }. private:; std::coroutine_handle<promise_type> handle;; };. task task::promise_type::get_return_object() {; return std::coroutine_handle<promise_type>::from_promise(*this);; }. namespace detail {; template <int N>; task chain_fn() {; co_return N + co_await chain_fn<N - 1>();; }. template <>; task chain_fn<0>() {; // This is the default breakpoint.; __builtin_debugtrap();; co_return 0;; }; } // namespace detail. task chain() {; co_return co_await detail::chain_fn<30>();; }. int main() {; std::cout << chain().syncStart() << ""\n"";; return 0;; }. In the example, the ``task`` coroutine holds a ``continuation`` field,; which would be resumed once the ``task`` completes.; In another word, the ``continuation`` is the asynchronous caller for the ``task``.; Just like the normal function returns to its caller when the function completes. So we can use the ``continuation`` field to construct the asynchronous stack:. .. code-block:: python. # debugging-helper.py; import gdb; from gdb.FrameDecorator import FrameDecorator. class SymValueWrapper():; def __init__(self, symbol, value):; self.sym = symbol; self.val = value. def __str__(self):; return str(self.sym) + "" = "" + str(self.val). def get_long_pointer_size():; return gdb.lookup_type('long').pointer().sizeof. def cast_addr2long_pointer(addr):; return gdb.Value(addr).cast(gdb.lookup_type('long').pointer()). def dereference(addr):; return long(cast_addr2long_pointer(addr).dereference()). class CoroutineFrame(object):; def __init__(self, task_addr):; self.frame_addr = task_addr; self.resume_addr = task_addr; self.destroy_addr = task_addr + get_long",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4032,Availability,avail,available,4032,"ject files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must have enough information to forward; command line arguments to child processes correctly. Design Overview; ---------------. The diagram below shows the significant components of the driver; architecture and how they relate to one another. The orange components; represent concrete data structures built by the driver, the green; components indicate conceptually distinct stages which manipulate these; data structures, and the blue components are important helper classes. .. image:: DriverArchitecture.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; -------------. The driver functionality is conceptually divided into five stages:. #. **Parse: Option Parsing**. The command line argument strings are decomposed into arguments; (``Arg`` instances). The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:5818,Availability,down,down,5818," options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8687,Availability,down,down,8687," -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; archite",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14083,Availability,down,downside,14083," list (into; a new ArgList data structure). Although this allows the clang driver to; match gcc easily, it also makes the driver operation much harder to; understand (since the Tools stop seeing some arguments the user; provided, and see new ones instead). For example, on Darwin ``-gfull`` gets translated into two separate; arguments, ``-g`` and ``-fno-eliminate-unused-debug-symbols``. Trying to; write Tool logic to do something with ``-gfull`` will not work, because; Tool argument translation is done after the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14789,Availability,error,errors,14789," change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15960,Availability,error,error,15960,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1396,Deployability,integrat,integrated,1396,"tended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:7398,Deployability,pipeline,pipeline,7398,"he majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-block:: console. $ clang -ccc-print-phases -c -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8937,Deployability,integrat,integrated,8937,", ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:11882,Deployability,pipeline,pipeline,11882,"c versions of the tools are being used on PowerPC. #. **Translate: Tool Specific Argument Translation**. Once a Tool has been selected to perform a particular Action, the; Tool must construct concrete Commands which will be executed during; compilation. The main work is in translating from the gcc style; command line options to whatever options the subprocess expects. Some tools, such as the assembler, only interact with a handful of; arguments and just determine the path of the executable to call and; pass on their input and output arguments. Others, like the compiler; or the linker, may translate a large number of arguments in addition. The ArgList class provides a number of simple helper methods to; assist with translating arguments; for example, to pass on only the; last of arguments corresponding to some option, or all arguments for; an option. The result of this stage is a list of Commands (executable paths and; argument strings) to execute. #. **Execute**. Finally, the compilation pipeline is executed. This is mostly; straightforward, although there is some interaction with options like; ``-pipe``, ``-pass-exit-codes`` and ``-time``. Additional Notes; ----------------. The Compilation Object; ^^^^^^^^^^^^^^^^^^^^^^. The driver constructs a Compilation object for each set of command line; arguments. The Driver itself is intended to be invariant during; construction of a Compilation; an IDE should be able to construct a; single long lived driver instance to use for an entire build, for; example. The Compilation object holds information that is particular to each; compilation sequence. For example, the list of used temporary files; (which must be removed once compilation is finished) and result files; (which should be removed if compilation fails). Unified Parsing & Pipelining; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Parsing and pipelining both occur without reference to a Compilation; instance. This is by design; the driver expects that both of these; phases are platform ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15293,Deployability,integrat,integrated,15293,"icularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Too",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16235,Deployability,pipeline,pipeline,16235,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1933,Energy Efficiency,efficient,efficient,1933,"; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2134,Energy Efficiency,efficient,efficiently,2134,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:3544,Energy Efficiency,green,green,3544,"ation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must have enough information to forward; command line arguments to child processes correctly. Design Overview; ---------------. The diagram below shows the significant components of the driver; architecture and how they relate to one another. The orange components; represent concrete data structures built by the driver, the green; components indicate conceptually distinct stages which manipulate these; data structures, and the blue components are important helper classes. .. image:: DriverArchitecture.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; -------------. The driver functionality is conceptually divided into five stages:. #. **Parse: Option Parsing**. The command line argument strings are decomposed into arguments; (``Arg`` instances). The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6640,Energy Efficiency,adapt,adapt,6640,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15869,Energy Efficiency,efficient,efficient,15869,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:509,Integrability,interface,interface,509,"=========================; Driver Design & Internals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1082,Integrability,interface,interface,1082,"nals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1396,Integrability,integrat,integrated,1396,"tended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1618,Integrability,interface,interface,1618," gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2119,Integrability,interface,interfaces,2119,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8937,Integrability,integrat,integrated,8937,", ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:9276,Integrability,depend,depend,9276,"d to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. code-block:: console. $ clang -ccc-print-bindings -arch i386 -arch ppc t0.c; # ""i386-apple-darwin9"" - ""clang"", inputs: [""t0.c""], output: ""/tmp/cc-Sn4RKF.s""; # ""i386-apple-darwin9"" - ""darwin::Assemble"", inputs: [""/tmp/cc-Sn4RKF.s""], output: ""/tmp/cc-gvSnbS.o""; # ""i386-apple-darwin9"" - ""darwin::Link"", inputs: [""/tmp/cc-gvSnbS.o""], output: ""/tmp/cc-jgHQxi.out""; # ""ppc-apple-darwin9"" - ""gcc::Compile"", input",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15293,Integrability,integrat,integrated,15293,"icularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Too",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16175,Integrability,rout,routines,16175,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16661,Integrability,interface,interfaces,16661,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1221,Modifiability,flexible,flexible,1221,"n goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", gi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6640,Modifiability,adapt,adapt,6640,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16503,Modifiability,portab,portable,16503,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2888,Performance,perform,perform,2888,"ead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must have enough information to forward; command line arguments to child processes correctly. Design Overview; ---------------. The diagram below shows the significant components of the driver; architecture and how they relate to one another. The orange components; represent concrete data structures built by the driver, the green; components indicate conceptually distinct stages which manipulate these; data structures, and the blue components are important helper classes. .. image:: DriverArchitecture.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; --------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4766,Performance,load,loaded,4766,"ure.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; -------------. The driver functionality is conceptually divided into five stages:. #. **Parse: Option Parsing**. The command line argument strings are decomposed into arguments; (``Arg`` instances). The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - N",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8258,Performance,perform,performed,8258,"the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-block:: console. $ clang -ccc-print-phases -c -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8672,Performance,perform,performs,8672," -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; archite",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8787,Performance,perform,perform,8787,", ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:9382,Performance,perform,perform,9382,"l output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. code-block:: console. $ clang -ccc-print-bindings -arch i386 -arch ppc t0.c; # ""i386-apple-darwin9"" - ""clang"", inputs: [""t0.c""], output: ""/tmp/cc-Sn4RKF.s""; # ""i386-apple-darwin9"" - ""darwin::Assemble"", inputs: [""/tmp/cc-Sn4RKF.s""], output: ""/tmp/cc-gvSnbS.o""; # ""i386-apple-darwin9"" - ""darwin::Link"", inputs: [""/tmp/cc-gvSnbS.o""], output: ""/tmp/cc-jgHQxi.out""; # ""ppc-apple-darwin9"" - ""gcc::Compile"", inputs: [""t0.c""], output: ""/tmp/cc-Q0bTox.s""; # ""ppc-apple-darwin9"" - ""gcc::Assemble"", inputs: [""/tmp/cc-Q0bTox.s""], output: ""/t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:11017,Performance,perform,perform,11017,"/tmp/cc-Sn4RKF.s""], output: ""/tmp/cc-gvSnbS.o""; # ""i386-apple-darwin9"" - ""darwin::Link"", inputs: [""/tmp/cc-gvSnbS.o""], output: ""/tmp/cc-jgHQxi.out""; # ""ppc-apple-darwin9"" - ""gcc::Compile"", inputs: [""t0.c""], output: ""/tmp/cc-Q0bTox.s""; # ""ppc-apple-darwin9"" - ""gcc::Assemble"", inputs: [""/tmp/cc-Q0bTox.s""], output: ""/tmp/cc-WCdicw.o""; # ""ppc-apple-darwin9"" - ""gcc::Link"", inputs: [""/tmp/cc-WCdicw.o""], output: ""/tmp/cc-HHBEBh.out""; # ""i386-apple-darwin9"" - ""darwin::Lipo"", inputs: [""/tmp/cc-jgHQxi.out"", ""/tmp/cc-HHBEBh.out""], output: ""a.out"". This shows the tool chain, tool, inputs and outputs which have been; bound for this compilation sequence. Here clang is being used to; compile t0.c on the i386 architecture and darwin specific versions of; the tools are being used to assemble and link the result, but generic; gcc versions of the tools are being used on PowerPC. #. **Translate: Tool Specific Argument Translation**. Once a Tool has been selected to perform a particular Action, the; Tool must construct concrete Commands which will be executed during; compilation. The main work is in translating from the gcc style; command line options to whatever options the subprocess expects. Some tools, such as the assembler, only interact with a handful of; arguments and just determine the path of the executable to call and; pass on their input and output arguments. Others, like the compiler; or the linker, may translate a large number of arguments in addition. The ArgList class provides a number of simple helper methods to; assist with translating arguments; for example, to pass on only the; last of arguments corresponding to some option, or all arguments for; an option. The result of this stage is a list of Commands (executable paths and; argument strings) to execute. #. **Execute**. Finally, the compilation pipeline is executed. This is mostly; straightforward, although there is some interaction with options like; ``-pipe``, ``-pass-exit-codes`` and ``-time``. Additional Notes; --",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:13131,Performance,perform,perform,13131,"r constructs a Compilation object for each set of command line; arguments. The Driver itself is intended to be invariant during; construction of a Compilation; an IDE should be able to construct a; single long lived driver instance to use for an entire build, for; example. The Compilation object holds information that is particular to each; compilation sequence. For example, the list of used temporary files; (which must be removed once compilation is finished) and result files; (which should be removed if compilation fails). Unified Parsing & Pipelining; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Parsing and pipelining both occur without reference to a Compilation; instance. This is by design; the driver expects that both of these; phases are platform neutral, with a few very well defined exceptions; such as whether the platform uses a driver driver. ToolChain Argument Translation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to match gcc very closely, the clang driver currently allows; tool chains to perform their own translation of the argument list (into; a new ArgList data structure). Although this allows the clang driver to; match gcc easily, it also makes the driver operation much harder to; understand (since the Tools stop seeing some arguments the user; provided, and see new ones instead). For example, on Darwin ``-gfull`` gets translated into two separate; arguments, ``-g`` and ``-fno-eliminate-unused-debug-symbols``. Trying to; write Tool logic to do something with ``-gfull`` will not work, because; Tool argument translation is done after the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4710,Safety,avoid,avoid,4710,"ure.png; :align: center; :alt: Driver Architecture Diagram. Driver Stages; -------------. The driver functionality is conceptually divided into five stages:. #. **Parse: Option Parsing**. The command line argument strings are decomposed into arguments; (``Arg`` instances). The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - N",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:448,Security,access,access,448,"=========================; Driver Design & Internals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14705,Security,access,accessors,14705,"r the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14900,Security,access,accessed,14900," change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:631,Testability,log,logically,631,"=========================; Driver Design & Internals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1141,Testability,test,test,1141,"nals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:13587,Testability,log,logic,13587,"mpilation fails). Unified Parsing & Pipelining; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Parsing and pipelining both occur without reference to a Compilation; instance. This is by design; the driver expects that both of these; phases are platform neutral, with a few very well defined exceptions; such as whether the platform uses a driver driver. ToolChain Argument Translation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to match gcc very closely, the clang driver currently allows; tool chains to perform their own translation of the argument list (into; a new ArgList data structure). Although this allows the clang driver to; match gcc easily, it also makes the driver operation much harder to; understand (since the Tools stop seeing some arguments the user; provided, and see new ones instead). For example, on Darwin ``-gfull`` gets translated into two separate; arguments, ``-g`` and ``-fno-eliminate-unused-debug-symbols``. Trying to; write Tool logic to do something with ``-gfull`` will not work, because; Tool argument translation is done after the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:13841,Testability,log,logic,13841,"gn; the driver expects that both of these; phases are platform neutral, with a few very well defined exceptions; such as whether the platform uses a driver driver. ToolChain Argument Translation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to match gcc very closely, the clang driver currently allows; tool chains to perform their own translation of the argument list (into; a new ArgList data structure). Although this allows the clang driver to; match gcc easily, it also makes the driver operation much harder to; understand (since the Tools stop seeing some arguments the user; provided, and see new ones instead). For example, on Darwin ``-gfull`` gets translated into two separate; arguments, ``-g`` and ``-fno-eliminate-unused-debug-symbols``. Trying to; write Tool logic to do something with ``-gfull`` will not work, because; Tool argument translation is done after the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1974,Usability,simpl,simple,1974,"; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2112,Usability,simpl,simple,2112,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2226,Usability,simpl,simple,2226,"ble and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must hav",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4980,Usability,simpl,simply,4980,". The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6622,Usability,simpl,simply,6622,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8219,Usability,simpl,simple,8219,"the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-block:: console. $ clang -ccc-print-phases -c -arch i386 -arch x86_64 t0.c t1.c; 0: input, ""t0.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: bind-arch, ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:11565,Usability,simpl,simple,11565," inputs and outputs which have been; bound for this compilation sequence. Here clang is being used to; compile t0.c on the i386 architecture and darwin specific versions of; the tools are being used to assemble and link the result, but generic; gcc versions of the tools are being used on PowerPC. #. **Translate: Tool Specific Argument Translation**. Once a Tool has been selected to perform a particular Action, the; Tool must construct concrete Commands which will be executed during; compilation. The main work is in translating from the gcc style; command line options to whatever options the subprocess expects. Some tools, such as the assembler, only interact with a handful of; arguments and just determine the path of the executable to call and; pass on their input and output arguments. Others, like the compiler; or the linker, may translate a large number of arguments in addition. The ArgList class provides a number of simple helper methods to; assist with translating arguments; for example, to pass on only the; last of arguments corresponding to some option, or all arguments for; an option. The result of this stage is a list of Commands (executable paths and; argument strings) to execute. #. **Execute**. Finally, the compilation pipeline is executed. This is mostly; straightforward, although there is some interaction with options like; ``-pipe``, ``-pass-exit-codes`` and ``-time``. Additional Notes; ----------------. The Compilation Object; ^^^^^^^^^^^^^^^^^^^^^^. The driver constructs a Compilation object for each set of command line; arguments. The Driver itself is intended to be invariant during; construction of a Compilation; an IDE should be able to construct a; single long lived driver instance to use for an entire build, for; example. The Compilation object holds information that is particular to each; compilation sequence. For example, the list of used temporary files; (which must be removed once compilation is finished) and result files; (which should be re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15339,Usability,simpl,simply,15339,"ot support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; bi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/DriverInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:1098,Availability,avail,available,1098,"mples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3211,Availability,robust,robust,3211,"-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved iden",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3430,Availability,error,errors,3430,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:383,Deployability,integrat,integrate,383,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:383,Integrability,integrat,integrate,383,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2735,Integrability,wrap,wrapper,2735,"sed code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:4218,Integrability,protocol,protocols,4218,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2875,Modifiability,plugin,plugin,2875,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2943,Modifiability,variab,variables,2943,"nted compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3302,Modifiability,plugin,plugin,3302," will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3596,Modifiability,plugin,plugin,3596,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3797,Modifiability,refactor,refactoring,3797,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3939,Modifiability,plugin,plugin,3939,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:4336,Modifiability,plugin,plugins,4336,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2034,Performance,perform,performs,2034,"hat can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; """,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2151,Security,validat,validation,2151,"===============. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:220,Usability,guid,guides,220,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2850,Usability,learn,learn,2850,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3287,Usability,simpl,simplest,3287," will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst:181,Availability,error,errors,181,"================================; Frequently Asked Questions (FAQ); ================================. .. contents::; :local:. Driver; ======. I run ``clang -cc1 ...`` and get weird errors about missing headers; -------------------------------------------------------------------. Given this source file:. .. code-block:: c. #include <stdio.h>. int main() {; printf(""Hello world\n"");; }. If you run:. .. code-block:: console. $ clang -cc1 hello.c; hello.c:1:10: fatal error: 'stdio.h' file not found; #include <stdio.h>; ^; 1 error generated. ``clang -cc1`` is the frontend, ``clang`` is the :doc:`driver; <DriverInternals>`. The driver invokes the frontend with options appropriate; for your system. To see these options, run:. .. code-block:: console. $ clang -### -c hello.c. Some clang command line options are driver-only options, some are frontend-only; options. Frontend-only options are intended to be used only by clang developers.; Users should not run ``clang -cc1`` directly, because ``-cc1`` options are not; guaranteed to be stable. If you want to use a frontend-only option (""a ``-cc1`` option""), for example; ``-ast-dump``, then you need to take the ``clang -cc1`` line generated by the; driver and add the option you need. Alternatively, you can run; ``clang -Xclang <option> ...`` to force the driver pass ``<option>`` to; ``clang -cc1``. I get errors about some headers being missing (``stddef.h``, ``stdarg.h``); --------------------------------------------------------------------------. Some header files (``stddef.h``, ``stdarg.h``, and others) are shipped with; Clang --- these are called builtin includes. Clang searches for them in a; directory relative to the location of the ``clang`` binary. If you moved the; ``clang`` binary, you need to move the builtin headers, too. More information can be found in the :ref:`libtooling_builtin_includes`; section. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/FAQ.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst:467,Availability,error,error,467,"================================; Frequently Asked Questions (FAQ); ================================. .. contents::; :local:. Driver; ======. I run ``clang -cc1 ...`` and get weird errors about missing headers; -------------------------------------------------------------------. Given this source file:. .. code-block:: c. #include <stdio.h>. int main() {; printf(""Hello world\n"");; }. If you run:. .. code-block:: console. $ clang -cc1 hello.c; hello.c:1:10: fatal error: 'stdio.h' file not found; #include <stdio.h>; ^; 1 error generated. ``clang -cc1`` is the frontend, ``clang`` is the :doc:`driver; <DriverInternals>`. The driver invokes the frontend with options appropriate; for your system. To see these options, run:. .. code-block:: console. $ clang -### -c hello.c. Some clang command line options are driver-only options, some are frontend-only; options. Frontend-only options are intended to be used only by clang developers.; Users should not run ``clang -cc1`` directly, because ``-cc1`` options are not; guaranteed to be stable. If you want to use a frontend-only option (""a ``-cc1`` option""), for example; ``-ast-dump``, then you need to take the ``clang -cc1`` line generated by the; driver and add the option you need. Alternatively, you can run; ``clang -Xclang <option> ...`` to force the driver pass ``<option>`` to; ``clang -cc1``. I get errors about some headers being missing (``stddef.h``, ``stdarg.h``); --------------------------------------------------------------------------. Some header files (``stddef.h``, ``stdarg.h``, and others) are shipped with; Clang --- these are called builtin includes. Clang searches for them in a; directory relative to the location of the ``clang`` binary. If you moved the; ``clang`` binary, you need to move the builtin headers, too. More information can be found in the :ref:`libtooling_builtin_includes`; section. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/FAQ.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst
